<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis持久化问题排查</title>
    <url>/2022/10/29/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="redis持久化问题排查">Redis持久化问题排查</h2>
<blockquote>
<p>前言：在学习黑马的Redis持久化课程时因为老师用的MobaXterm软件与我使用的VMware存在差异，同时，老师上传的视频的redis配置与我大为不同而导致了一系列的问题，在进行了一天的排查（死杠）后终于解决了问题，感慨良多。在遇到问题解决不了的时候还是要多回头看，没准在出发点就能找到问题了。
下面就将展示问题的描述和解决方案</p>
</blockquote>
<h3 id="问题描述">问题描述</h3>
<blockquote>
<p>老师在使用MobaXterm软件时使用<code>redis-server redis.conf</code>命令指定配置文件在<strong>前台</strong>启动Redis</p>
<p>然而我在使用redis-server命令却出现了下面的两种情况：</p>
</blockquote>
<p>第一种：不指定配置文件启动Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291124212.png"></p>
<p>发现监听6379端口失败</p>
<p>第二种：指定配置文件启动Redis</p>
<p>这里要先cd到自己的Redis安装路径下，然后使用命令<code>redis-server redis.conf</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291126030.png"></p>
<p>发现没有产生日志，这里使用<code>ps -ef | grep redis</code>查看后端端口占用情况</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291127803.png"></p>
<p>显然，后台端口已经被占用了，这里是因为Redis配置了开机自启动和后台启动，导致端口占用而无法使用redis-server命令</p>
<h3 id="问题解决">问题解决</h3>
<p>在执行以下操作前建议使用VMware创建一个快照，防止后续操作不当导致虚拟机设置出现问题<br></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282129924.png"></p>
<p>先使用以下命令关闭后台端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭Redis后台启动，xxx是自己设置的密码</span></span><br><span class="line">redis-cli -p 6379 -a xxxx shutdown</span><br></pre></td></tr></table></figure>
<p>此时cd到Redis的安装目录下，使用命令<code>ps -ef | grep redis</code>查看后台端口占用情况，发现后台端口关闭</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291139316.png"></p>
<p>然后在当前路径下使用<code>vi redis.conf</code>关闭Redis后台启动</p>
<p>将 daemonize 修改为 no</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291141606.png"></p>
<p>这样Redis就不会在后台启动了！</p>
<p>接着可以开心的使用<code>redis-server redis.conf</code>指定配置文件启动redis了！</p>
<p>然而，如果你使用该命令后又出现了如下情况</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291145134.png"></p>
<p>发现当前窗口确实是像前台启动一样阻塞的，但是却没有任何日志信息输出，这时我们打开RESP等图形化界面看一下连接是否成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291146893.png"></p>
<p>嗯，确实成功了，说明Redis服务确实启动了，但还是没有日志文件，那么这是怎么回事呢？</p>
<p>哈哈，不用着急，我们先使用<code>ctrl + c</code>停止当前端口，然后再回到RESP上发现连接终止，这就说明我们之前做的操作没有问题！现在我们回到终端，使用<code>vi redis.conf</code>命令进入到配置文件中</p>
<p>找到<strong>logfile</strong>，发现logfile后面的引号内为一个日志文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291150818.png"></p>
<p>这个时候一切都真相大白了，因为在一开始配置Redis时，我们将在logfile的引号内<strong>写入了一个日志文件名称</strong>（一开始的logfile内的引号默认是空的），这就导致了我们使用redis-server命令输出的日志都进入到这个日志文件中，所以启动时当然看不到任何信息了！现在我们将引号内的文件命删除，保存并退出</p>
<p>再次使用<code>redis-server redis.conf</code>命令启动Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291153693.png"></p>
<p>启动成功，大功告成！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>VMWare演示Redis持久化</title>
    <url>/2022/10/28/VMWare%E6%BC%94%E7%A4%BARedis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="vmware演示redis持久化">VMware演示Redis持久化</h2>
<h3 id="redis持久化的作用">Redis持久化的作用</h3>
<p>Redis是内存存储，如果出现服务器宕机、服务重启等情况可能会丢失数据，利用Redis持久化可以将数据写入磁盘中，这样Redis就可以利用持久化的文件进行数据恢复，数据安全性得以大大提升。<br></p>
<h3 id="rdb">RDB</h3>
<blockquote>
<p>RDB全称为Redis Database Backup
file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存重的所有数据都记录道磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
</blockquote>
<p>RDB实现数据持久化有两种命令：<code>save</code>和<code>bgsave</code></p>
<p>save命令适合用于准备将Redis停机的情况。</p>
<p>在执行save命令时会占用Redis的主进程，阻塞所有命令，因此不适用于Redis正在运行的情况。</p>
<p>而bgsave命令会执行fork操作开启一个子进程，避免主进程收到影响。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282119328.png"></p>
<p>此外，当Redis停机时会执行一次RDB操作进行数据备份。</p>
<p>下面将对该情况进行验证</p>
<h3 id="rdb演示">RDB演示</h3>
<p>使用<code>redis-server redis.conf</code>指令在任意路径下运行Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291303145.png"></p>
<p>接下来创建一个新的终端创建连接，存入键值对</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301657349.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301708367.png"></p>
<p>接着回到上一个终端使用<code>ctrl + c</code>关闭Redis，可以看到<code>DB saved on disk</code>表示文件正常保存</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282139525.png"></p>
<p>在当前路径下使用ll查看所有文件，看到dump.rdb快照文件已经生成<img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282141216.png"></p>
<p>接着再次在当前终端使用<code>redis-server redis.conf</code>启动Redis，此时数据会自动恢复，回到另一个终端窗口</p>
<p>此时将使用<code>ctrl + c</code>关闭当前命令行客户端，重新使用<code>redis-cli</code>开启一个新的命令行</p>
<p>这时使用get num命令发现数据返回为789，（如果get
num返回错误<strong>Error：Server closed the
connection</strong>要将redis.conf的<strong>protected-mode</strong>设置为No关闭保护模式）表明数据备份成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301704159.png"></p>
<p><strong>Redis停机自动执行RDB证明完毕！</strong></p>
<h3 id="实现rdb的相关配置">实现RDB的相关配置</h3>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282152250.png"></p>
<p>这里需要 cd 到redis的安装目录下，我的安装目录在
/usr/local/src/redis-6.2.6下</p>
<p>这里老师用的MobaXterm可以直接使用第三方文件打开配置文件进行修改，因为我用的是VMware所以只能使用Linux命令进行修改配置</p>
<p>使用 <code>vi redis.conf</code>修改配置文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282159322.png"></p>
<p>这里有一些小技巧：</p>
<ul>
<li>按下INSERT键进入修改状态，此时才可以对文件进行修改</li>
<li>按下ESC键可以使用一些命令：<code>/xxx</code>可以查找跳跃到当前文件中的xxx名称，<code>:wq</code>保存当前文件并退出，<code>:q</code>不保存并退出当前文件，<code>:q!</code>不保存并强制退出当前文件</li>
</ul>
<p>下面就可以对配置文件进行修改了！</p>
<p>修改为五秒内执行一次操作就出发RDB备份</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282209053.png"></p>
<p>接着</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282211172.png"></p>
<p>再查找rdbcompression后修改为yes即可</p>
<p>使用:wq保存并退出</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282214630.png"></p>
<p>rdb文件名修改后使用终端再次运行Redis，发现此时没有DB文件录入消息，之前的dump.rdb文件已不能被读取</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291316731.png"></p>
<p>到另一个终端重新使用redis-cli开启命令行，使用get
num命令发现结果为空，再set
一个新的键值，回到Redis窗口发现出现<code>Background saving started</code>字段即表示成功！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282221596.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291318662.png"></p>
<h3 id="aof">AOF</h3>
<blockquote>
<p>AOF全称为Append Only File
(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
</blockquote>
<p>开启AOF需要在Redis的配置文件中修改配置，AOF记录命令的频率有三种:<code>always</code>
、<code>everysec</code>和<code>no</code></p>
<p>always配置胜在能记录每一次Redis执行的写命令，几乎不会丢失数据，但对性能会有很大的影响</p>
<p>everysec配置每隔一秒将缓冲区里的数据写入到AOF文件，避免直接对AOF文件操作而性能上有了提升，但是在数据间隔的一秒内如果出现服务宕机的情况会丢失最多一秒的数据</p>
<p>no配置执行频率最低，性能最好，但是可靠性很低，不推荐使用</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301559763.png"></p>
<h3 id="aof演示">AOF演示</h3>
<p>先使用 cd 命令进入到Redis的安装路径下</p>
<p>使用<code>vi redis.conf</code>命令修改redis配置文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301615021.png"></p>
<p>将之前的save 5 1注释掉，写入save ""，表示禁用RDB</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301617321.png"></p>
<p>将appendonly修改为yes，开启AOF</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301618239.png"></p>
<p>AOF执行频率的命令配置默认为<code>appendfsync everysec</code>，不需要修改</p>
<p>修改完毕后回到终端，使用<code>rm -rf *.rdb</code>删除之前的RDB文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301622298.png"></p>
<p>可以看到当前目录下rdb文件已删除</p>
<p>使用<code>redis-server redis.conf</code>命令重启Redis</p>
<p>发现日志中出现没有对RDB的读取，修改成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301626879.png"></p>
<p>在另一终端打开命令行，输入如下指令</p>
<p>返回空集合，说明所有数据已被清除</p>
<figure>
<img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301703747.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>set一个键值对</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301630032.png"></p>
<p>这时我们打开文件夹进入本机的Redis的安装路径下，发现AOF文件已经被创建成功，打开AOF文件，set命令已经被写入成功，说明<strong>AOF已经生效了</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301633106.png"></p>
<p>接下来验证AOF的重启恢复，先重启Redis服务，红框内的日志表示数据已经从AOF文件加载完毕</p>
<p><img src="/2022/10/28/VMWare%E6%BC%94%E7%A4%BARedis%E6%8C%81%E4%B9%85%E5%8C%96/Users\86130\AppData\Roaming\Tencent\Users\2484792357\QQ\WinTemp\RichOle\LBDM52Q%5BBMBTK%7DPKDK~HB2V.png"></p>
<p>这时候我们回到命令行使用<code>keys *</code>命令，返回num，依然有数据，说明AOF重启能保证数据的恢复，证明完毕</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301640485.png"></p>
<h3 id="rdb和aof的比较">RDB和AOF的比较</h3>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301647804.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware软件安装及问题解决</title>
    <url>/2022/10/08/VMware%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="vmware软件安装">VMware软件安装</h2>
<blockquote>
<p>前言：最近学习Redis时需要使用Linux系统，导致不得不去安装一个虚拟机了，在准备安装VMware软件时遇到了一些问题，这里给出记录和解决方案，以做参考学习使用</p>
</blockquote>
<h3 id="准备工作">准备工作</h3>
<blockquote>
<p>本文将在Windows系统下使用VMware软件配置Linux虚拟机，下文将会详解VMware软件的安装步骤</p>
</blockquote>
<p>VMware软件下载地址：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a><br>
Linux CentOS 7版本下载映像文件地址：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a><br></p>
<p>按图片所示下载即可</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262109879.png"></p>
<p>这里我选择的是CentOS-7.0-x86_64-DVD-2009.iso 版本</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262106973.png"></p>
<p>在下载路径下右键以管理员身份运行</p>
<p><strong>在这里要敲重点！！！如果你没有以管理员身份运行这个选项，那么就看接下来的问题解决部分，如果你有这个选项请点击<a href="#1">跳转</a>自行无视。</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262117313.png"></p>
<h3 id="问题解决">问题解决</h3>
<blockquote>
<p>按住快捷键Win+R打开运行窗口，输入“regedit”，</p>
<p>这样就打开了注册表编辑器</p>
<p>在编辑器左侧依次找到HKEY_CURRENT_USER</p>
<p>然后将RestrictToPermittedSnapins的值设置为0</p>
</blockquote>
<p>上面的方法如果输入路径后发现MMC不存在，那么下面这个方法就派上用场了！</p>
<p>按下Win +
R键打开运行，输入gpedit.msc打开组策略编辑器，这里可能你又会惊讶的发现，gpedit.msc打不开了！别着急，下面还有解决方案。当然，如果你能打开组策略编辑器的话可以点击<a href="#2">这里</a>继续往下看</p>
<p>对于无法打开组策略编辑器的情况，win + r
键打开运行后，输入notepad打开记事本，复制粘贴以下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . List.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">&quot;C:\Windows\servicing\Packages\%%i&quot;</span></span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>记事本左上角文件另存为到任意路径下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262129654.png"></p>
<p>文件名写为gpedit.cmd，保存类型选择所有文件，编码选择ANSI</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262131529.png"></p>
<p>点击保存后在你保存的路径下右键以管理员身份运行</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262132085.png"></p>
<p>等待运行结束后发现win + R键打开的gpedit.msc可以正常打开了<br></p>
<p><span id="2"></span></p>
<p>接下来进入组策略编辑器，双击计算机配置 --&gt; Windows设置 --&gt;
安全设置<br></p>
<p>双击本地策略</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262139507.png"></p>
<p>进入安全选项找到下面两项选择已启用</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262141895.png"></p>
<p><strong>大功告成！！！</strong></p>
<p><span id="1"></span></p>
<h3 id="安装vmware">安装VMware</h3>
<p>当解决上述问题后开始准备下载VM软件了，右键以管理员身份运行后等待片刻来到安装界面</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262147272.png"></p>
<p>一路下一步来到这个界面，安装路径自己选择，我选择安装在D盘下的目录里</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262148344.png"></p>
<p>勾选取消“启动时检查产品更新”</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262149952.png"></p>
<p>一路下一步，点击安装</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262151352.png"></p>
<p>点击许可证</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262153587.png"></p>
<p>这里要输入许可证密钥（这里大家自行网络上获取），然后点击输入，安装结束，注意不要误点到跳过了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262155195.png"></p>
<p>输入密钥确认安装后就可以使用VMware了！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】MapStruct实现优雅的数据复制</title>
    <url>/2024/05/05/%E3%80%90SpringBoot%E3%80%91MapStruct%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>做项目时你是否遇到过以下情况：</p>
<ol type="1">
<li><strong>DTO（数据传输对象）与Entity之间的转换</strong>：在Java的Web应用中，通常不会直接将数据库中的Entity实体对象返回给前端。而是会创建一个DTO对象，这个DTO对象只包含需要返回给前端的字段。此时，就需要将Entity转换为DTO。</li>
<li><strong>复杂对象的映射</strong>：当需要映射的对象包含大量的字段，或者字段之间存在复杂的依赖关系时，手动编写映射代码不仅繁琐，而且容易出错。</li>
</ol>
</blockquote>
<h2 id="为什么选择mapstruct">1.为什么选择MapStruct<a id="why"></a></h2>
<h3 id="常见的属性映射方法">1.1.常见的属性映射方法</h3>
<p>一般来说，不使用MapStruct框架进行属性映射，常有的方法以下两种：</p>
<ol type="1">
<li>Getter/Setter方法手动映射</li>
</ol>
<p>这种方法最朴素，手动编写代码将<strong>源对象</strong>的属性存入<strong>目标对象</strong>，需要注意实体类中嵌套属性的判空操作以防止空指针异常。</p>
<ol start="2" type="1">
<li>BeanUtils.copyProperties()方法进行映射</li>
</ol>
<p><code>BeanUtils</code>底层使用的是<strong>反射机制</strong>实现属性的映射。反射是一种在<strong>运行时</strong>动态获取类信息、调用方法或访问字段的机制，无法利用JVM的优化机制，因此通常比直接方法调用慢得多。</p>
<p>此外，<code>BeanUtils</code>
只能同属性映射，或者在属性相同的情况下，允许被映射的对象属性少；但当遇到被映射的属性数据类型被修改或者被映射的字段名被修改，则会导致映射失败。</p>
<h3 id="mapstruct的优势">1.2.MapStruct的优势</h3>
<blockquote>
<p>MapStruct是一个基于注解的Java代码生成器，它通过分析带有@Mapper注解的接口，在编译时自动生成实现该接口的映射器类。这个映射器类包含了用于执行对象之间映射的具体代码。</p>
</blockquote>
<p><strong>与常规方法相比，MapStruct具备的优势有：</strong></p>
<ol type="1">
<li><p><strong>简化代码</strong>。对于对象内属性较多的情况，使用MapStruct框架无须手动对每个属性进行get/set和属性判空操作。MapStruct可以通过注解和映射接口来定义映射规则，自动生成映射代码，从而大大简化了这种复杂对象的映射过程。</p></li>
<li><p><strong>性能优越</strong>。相较于反射这种映射方法，MapStruct在<strong>编译期</strong>生成映射的<strong>静态代码</strong>，可以充分利用JVM的优化机制，对于企业级的项目应用来说，这种方式能大大提高数据复制的性能。</p></li>
<li><p><strong>类型安全</strong>。由于MapStruct在编译期生成映射代码，这意味着如果源对象和目标对象的映射存在错误，那么可以在<strong>编译时</strong>就发现错误。相比之下，BeanUtils在运行时使用反射来执行属性复制，这可能会导致类型不匹配的问题在<strong>运行时</strong>才发现。</p></li>
<li><p><strong>灵活映射</strong>。MapStruct可以轻松处理嵌套对象和集合的映射。对于嵌套对象，MapStruct可以递归地应用映射规则；对于集合，MapStruct可以自动迭代集合中的每个元素并应用相应的映射规则。</p></li>
</ol>
<p>有开发者对比过两者的性能差距，如下表。这充分体现了MapStruct性能的强大。</p>
<table>
<thead>
<tr class="header">
<th>对象转换次数</th>
<th>属性个数</th>
<th>BeanUtils耗时</th>
<th>MapStruct耗时</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5千万次</td>
<td>6</td>
<td>14秒</td>
<td>1秒</td>
</tr>
<tr class="even">
<td>5千万次</td>
<td>15</td>
<td>36秒</td>
<td>1秒</td>
</tr>
<tr class="odd">
<td>5千万次</td>
<td>25</td>
<td>55秒</td>
<td>1秒</td>
</tr>
</tbody>
</table>
<h2 id="mapstruct快速入门">2.MapStruct快速入门<a id="how"></a></h2>
<p>在快速入门中，我们的任务是将dto的数据复制到实体类中。</p>
<h3 id="导入maven依赖">2.1.导入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建相关对象">2.2.创建相关对象</h3>
<p>注意，实体类要具有get/set方法，这里我使用了lombok的@Data注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String hotelCity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String hotelPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dto类我使用了@Builder注解，可以快速为对象赋初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建转换器converter">2.3.创建转换器Converter</h3>
<p>使用抽象类来定义转换器，只需中@Mapping注解中填写<code>target</code>和<code>source</code>的字段名，即可实现属性复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestConverter</span> &#123;</span><br><span class="line">    <span class="comment">//酒店详情</span></span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelCity&quot;, source = &quot;city&quot;),</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">2.4.测试</h3>
<p>在SpringBoot的测试类中测试，这里我使用DTO类的@Builder注解提供的方法为dto赋初值模拟实际开发，通过调用converter的方法实现属性映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">HotelDTO</span> <span class="variable">build</span> <span class="operator">=</span> HotelDTO.builder()</span><br><span class="line">              .name(<span class="string">&quot;五星级酒店&quot;</span>)</span><br><span class="line">              .address(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">              .city(<span class="string">&quot;北京&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">      <span class="type">TestConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestConverterImpl</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> converter.dto2Hotel(build);</span><br><span class="line"></span><br><span class="line">      System.out.println(hotel);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505204126389.png"></p>
<p>最后，我们可以发现在target包的converter的相同目录下，生成了TestConverter的实现类</p>
<p>里面为我们编写好了映射的代码。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505211703891.png"></p>
<h2 id="mapstruct进阶操作">3.MapStruct进阶操作<a id="rank"></a></h2>
<p>如果仅是这种简单层级的对象映射，还不足以体现MapStruct的灵活性。下面将介绍MapStruct的进阶技巧。</p>
<h3 id="嵌套映射">3.1.嵌套映射</h3>
<p>假设我们的Hotel实体类中嵌套了另外一个实体类Master</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String hotelCity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String hotelPhone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Master master;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dto对象为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer personAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要把<code>personName</code>和<code>personAge</code>映射到Hotel实体类的Master中，怎么做？</p>
<p>很简单，只需要在target属性中加上Hotel实体类<strong>嵌套实体类的字段名</strong>，加字符<code>.</code>，再跟上嵌套类的字段名即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelCity&quot;, source = &quot;city&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;master.personName&quot;, source = &quot;personName&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;master.personAge&quot;, source = &quot;personAge&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505210546756.png"></p>
<h3 id="集合映射">3.2.集合映射</h3>
<p>如果源对象和目标对象的集合的元素类型都是基本数据类型，直接在target和source中填写字段名即可。</p>
<p>若源对象和目标对象的集合元素类型不同，怎么做？</p>
<p>这个案例我们需要把DTO的personList映射到masterList中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDTO.Person&gt; personList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Master&gt; masters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写converter，这次需要进行两层映射。</p>
<p>第一层将person集合映射到master集合上。</p>
<p>第二层将person对象的属性映射到master对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;masters&quot;, source = &quot;personList&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;name&quot;, source = &quot;personName&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;age&quot;, source = &quot;personAge&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel.Master <span class="title function_">toList</span><span class="params">(HotelDTO.Person person)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505215457158.png"></p>
<p>查看target包下的代码，可以发现MapStruct除了两层映射外，还帮你自动生成了迭代集合添加元素的代码，从而实现集合元素的复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConverterImpl</span> <span class="keyword">extends</span> <span class="title class_">TestConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestConverterImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 第一层映射</span></span><br><span class="line">    <span class="keyword">public</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hotelDTO == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">            hotel.setMasters(<span class="built_in">this</span>.personListToMasterList(hotelDTO.getPersonList()));</span><br><span class="line">            hotel.setHotelAddress(hotelDTO.getAddress());</span><br><span class="line">            hotel.setHotelName(hotelDTO.getName());</span><br><span class="line">            <span class="keyword">return</span> hotel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 第二层映射</span></span><br><span class="line">    <span class="keyword">public</span> Hotel.Master <span class="title function_">toList</span><span class="params">(HotelDTO.Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Hotel.<span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>.Master();</span><br><span class="line">            master.setName(person.getPersonName());</span><br><span class="line">            master.setAge(person.getPersonAge());</span><br><span class="line">            <span class="keyword">return</span> master;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 调用第二层映射，将person集合的元素添加到master中</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Hotel.Master&gt; personListToMasterList(List&lt;HotelDTO.Person&gt; list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Hotel.Master&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list.size());</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                HotelDTO.<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (HotelDTO.Person)var3.next();</span><br><span class="line">                list1.add(<span class="built_in">this</span>.toList(person));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字段的逻辑处理">4.字段的逻辑处理<a id="logister"></a></h2>
<h3 id="复杂逻辑处理qualifiedbyname和named">4.1.复杂逻辑处理（qualifiedByName和@Named）</h3>
<p>这次我们需要把dto中的personName和personAge的list集合映射到实体类的masters集合中。常规的集合映射无法处理这种情况，这时需要使用到qualifiedByName和@Named进行特殊处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; personName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; personAge;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主人</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Master&gt; masters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就需要拿到两个list的数据，进行手动处理了。在@Mapping注解的qualifiedByName属性指定方法名定位处理逻辑的方法，<span class="citation" data-cites="Named">@Named</span>("dtoToMasters")。</p>
<p>利用stream流进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;masters&quot;, source = &quot;hotelDTO&quot;, qualifiedByName = &quot;dtoToMasters&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named(&quot;dtoToMasters&quot;)</span></span><br><span class="line">List&lt;Hotel.Master&gt; dtoToMasters(HotelDTO hotelDTO) &#123;</span><br><span class="line">    List&lt;String&gt; personNames = hotelDTO.getPersonName();</span><br><span class="line">    List&lt;Integer&gt; personAges = hotelDTO.getPersonAge();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (personNames != <span class="literal">null</span> &amp;&amp; personAges != <span class="literal">null</span> &amp;&amp; personNames.size() == personAges.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, personNames.size())</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Hotel</span>.Master(personNames.get(i), personAges.get(i)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果列表长度不匹配或其他错误情况，可以返回空列表或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505214305462.png"></p>
<h3 id="额外逻辑处理ignore和aftermapping">4.2.额外逻辑处理（ignore和@AfterMapping）</h3>
<p><span class="citation" data-cites="Mappings的ignore属性">@Mappings的ignore属性</span>，也可以对一个字段（不能是集合）进行额外逻辑处理。通常搭配@AfterMapping注解使用。</p>
<p>这个案例中，我们需要根据DTO的mount属性判断是否大于15，如果大于，则判断hotel实体类的isSuccess为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店生意是否兴隆</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer mount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写converter，注意@AfterMapping注解下的方法的参数列表，需要使用@MappingTarget注解指明<strong>目标对象</strong>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;isSuccess&quot;, ignore = true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterMapping</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">isSuccess</span><span class="params">(HotelDTO hotelDTO, <span class="meta">@MappingTarget</span> Hotel hotel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hotelDTO.getMount() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hotelDTO.getMount() &gt; <span class="number">15</span>;</span><br><span class="line">    hotel.setIsSuccess(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HotelDTO</span> <span class="variable">build</span> <span class="operator">=</span> HotelDTO.builder()</span><br><span class="line">            .name(<span class="string">&quot;五星级酒店&quot;</span>)</span><br><span class="line">            .address(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">            .mount(<span class="number">18</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="type">TestConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestConverterImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> converter.dto2Hotel(build);</span><br><span class="line"></span><br><span class="line">    System.out.println(hotel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505221140556.png"></p>
<h3 id="简单逻辑处理expression">4.3.简单逻辑处理（expression）</h3>
<p>expression可以在注解中编写简单的处理逻辑</p>
<p>在这个案例中我需要在实体类的nowTime字段获取当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime nowTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在expression属性中使用方法获取当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(expression = &quot;java(java.time.LocalDateTime.now())&quot;, target = &quot;nowTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505221724742.png"></p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>数据复制</tag>
        <tag>MapStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程】线程池参数及创建方法</title>
    <url>/2024/05/27/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是线程池">1.什么是线程池<a id="why"></a></h2>
<p><strong>线程池就是管理一系列线程的资源池</strong>。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<blockquote>
<p><strong>为什么要使用线程池？</strong></p>
</blockquote>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h2 id="线程池七大参数">2.线程池七大参数<a id="param"></a></h2>
<h3 id="核心线程数">2.1.核心线程数</h3>
<p><strong><code>corePoolSize</code></strong>：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。当提交一个新任务时，如果线程池中的线程数小于<code>corePoolSize</code>，那么就会创建一个新线程来执行任务。</p>
<h3 id="最大线程数">2.2.最大线程数</h3>
<p><strong><code>maximumPoolSize</code></strong>：线程池中允许的最大线程数。在当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务存放到工作队列中。如果队列也已满，则会去创建一个新线程处理任务。</p>
<h3 id="空闲线程存活时间">2.3.空闲线程存活时间</h3>
<p><strong><code>keepAliveTime</code></strong>：非核心线程的空闲存活时间。当线程数大于<code>corePoolSize</code>时，空闲时间超过<code>keepAliveTime</code>的线程将被终止。</p>
<p>这个参数在设置了<code>allowCoreThreadTimeOut=true</code>时对核心线程同样有效。</p>
<h3 id="空闲线程存活时间单位">2.4.空闲线程存活时间单位</h3>
<p><strong><code>unit</code></strong>：keepAliveTime的计量单位。例如，<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</p>
<h3 id="工作队列">2.5.工作队列</h3>
<p><strong><code>workQueue</code></strong>：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>
<p>①ArrayBlockingQueue</p>
<p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
<p>②LinkedBlockingQuene</p>
<p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
<p>③SynchronousQuene</p>
<p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
<p>④PriorityBlockingQueue</p>
<p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>
<h3 id="线程工厂">2.6.线程工厂</h3>
<p><strong><code>threadFactory</code></strong>：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
<h3 id="拒绝策略">2.7.拒绝策略</h3>
<p><strong><code>handler</code></strong>：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，线程池会执行拒绝策略。JDK中提供了4中拒绝策略：</p>
<p>①CallerRunsPolicy</p>
<p>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</p>
<p>②AbortPolicy</p>
<p>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</p>
<p>③DiscardPolicy</p>
<p>该策略下，直接丢弃任务，什么都不做。</p>
<p>④DiscardOldestPolicy</p>
<p>该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p>
<h2 id="如何设定线程池大小">3.如何设定线程池大小<a id="set"></a></h2>
<p>一般来说，有两种类型的线程：<strong>CPU 密集型</strong>和 <strong>IO
密集型</strong>。</p>
<ul>
<li>CPU
密集型的线程<strong>主要进行计算和逻辑处理</strong>，需要占用大量的 CPU
资源。</li>
<li>IO
密集型的线程<strong>主要进行输入输出操作</strong>，如读写文件、网络通信等，需要等待
IO 设备的响应，而不占用太多的 CPU 资源。</li>
</ul>
<p>常见且简单的公式：</p>
<ul>
<li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU
资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU
核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU
就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU
的空闲时间。</p></li>
<li><p><strong>I/O 密集型任务(2N)：</strong>
这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O
的时间段内不会占用 CPU 来处理，这时就可以将 CPU
交出给其它线程使用。因此在 I/O
密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是
2N。</p></li>
</ul>
<h2 id="如何创建线程池">4.如何创建线程池<a id="create"></a></h2>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p>通过这种方式可以根据服务器硬件配置，灵活设定线程池参数。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f057153326a8f01a3a3caeaad3a8ad2c.png"></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类
<code>Executors</code> 来创建（不推荐）。</strong></p>
<ul>
<li><strong><code>FixedThreadPool</code></strong>：该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong>
该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong>
该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。初始大小为
0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为
60
秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li><strong><code>ScheduledThreadPool</code></strong>：该方法返回一个<strong>用来在给定的延迟后运行任务或者定期执行任务的线程池</strong>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/37586365930865f8219693dce9c35e87.png"></p>
<blockquote>
<p><strong><code>Executors</code> 返回线程池对象的弊端</strong></p>
</blockquote>
<ul>
<li><strong><code>FixedThreadPool</code> 和
<code>SingleThreadExecutor</code></strong>：使用的是无界的
<code>LinkedBlockingQueue</code>，<strong>任务队列最大长度</strong>为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong>：使用的是同步队列
<code>SynchronousQueue</code>, 允许<strong>创建的线程数量</strong>为
<code>Integer.MAX_VALUE</code>
，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致
OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和
<code>SingleThreadScheduledExecutor</code></strong> :
使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，<strong>任务队列最大长度</strong>为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】一、配置篇</title>
    <url>/2023/12/07/%E4%B8%80%E3%80%81IDEA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>配置篇</strong>，将介绍如何<strong>使用IDEA整合git</strong>，从而实现项目管理。</p>
<p>本文将使用<strong>Gitee</strong>作为项目管理工具。</p>
<p>注意：本文假定你已经拥有了一个Gitee账号并已经配置了密钥。</p>
<h2 id="下载插件">下载插件</h2>
<p>打开设置</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101052093.png"></p>
<p>在插件中搜索<strong>Gitee</strong>并下载安装，安装完毕后IDEA会提醒重启IDE，重启后插件才会生效！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101052329.png"></p>
<h2 id="添加账号">添加账号</h2>
<p>IDEA重启后，再次打开设置，在版本控制中可以看到Gitee这一栏，点击加号添加账号</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101055207.png"></p>
<p>点击加号后我们选择<strong>Log in via Gitee</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101056039.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101057087.png"></p>
<p>授权完毕后点击应用。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101058578.png"></p>
<h2 id="项目管理">项目管理</h2>
<p>最后一个步骤就是正式的实现项目的版本控制了，实现这一步骤有两种操作。</p>
<p>第一种是<strong>将IDEA本地的项目上传到gitee中</strong></p>
<p>第二种是<strong>从远程clone一个仓库到IDEA本地中</strong></p>
<p>下面我们来逐个介绍这两种操作，并简述这两者之间的区别和使用场景。</p>
<h3 id="将idea本地的项目上传到gitee中">1.将IDEA本地的项目上传到Gitee中</h3>
<p>现在我们打开你想要托管给Gitee的项目，打开工具栏的VCS，点击<strong>Share
Project on Gitee</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101106369.png"></p>
<p>这里我们可以设置仓库名（Repository
name），Remote是远程分支名，可以不用修改，Description是这个仓库的描述，这里自己填写即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101108667.png"></p>
<p>填写完毕后点击share，弹出这个窗口。</p>
<p>我们需要在本窗口中添加需要进行版本管理的文件以进行初始化，可以看到，本项目的所有文件都是<strong>理论篇</strong>提到的红色文件名的文件，这是因为这个项目还没有上传到远程仓库，也就不存在被Git跟踪的文件，所以都是红色文件名。</p>
<p>这里我们填写下提交信息并点击添加按钮，就可以上传成功了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101111093.png"></p>
<p>上传完毕后，我们可以观察到IDEA中出现了这三个功能块，至于这些功能块有何具体作用，我们将在基础篇详细介绍，这里不过多解释了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101114291.png"></p>
<p>这时候我们可以打开gitee的网站，点击顶部工具栏的头像，选择我的仓库，就可以看到刚刚创建的仓库了!</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101117539.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101118688.png"></p>
<h3 id="从远程clone一个仓库到idea本地中">2.从远程clone一个仓库到IDEA本地中</h3>
<p>这一步我们将从远程仓库中clone一个项目到本地中。</p>
<p>我们在gitee中选择一个想要clone的远程仓库，这里我使用的是我自己的远程仓库：</p>
<p><a href="https://gitee.com/moduokesi_admin/work-space">https://gitee.com/moduokesi_admin/work-space</a></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101122842.png"></p>
<p>点击VCS，选择从版本控制中获取。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101127137.png"></p>
<p>在仓库URL中，在URL中粘贴我们刚才复制的HTTPS地址，在目录中选择我们想要放置远程仓库代码的本地地址，填写完毕后点击克隆。</p>
<p>注意：目录必须是一个空目录</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101128513.png"></p>
<p>等待克隆完成后项目会自动跳转到你选择的目录。</p>
<h2 id="总结">总结</h2>
<p>通过以上的介绍，我们了解到实现版本控制有两种操作：</p>
<p>第一种操作适用于以下场景：</p>
<ul>
<li>本地你已经开发好了项目，需要将项目托管给远程仓库。</li>
</ul>
<p>第二种操作适用于以下场景：</p>
<ul>
<li>团队已经有了远程仓库（有人已经将远程仓库创建好了），这时候我们直接clone即可。</li>
<li>在gitee或github中看到了优质项目，我们clone本地进行学习</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】三、实战篇</title>
    <url>/2023/12/15/%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>实战篇</strong>，将正式介绍如何使用IDEA结合Git进行项目管理。</p>
<p>注意：本文假设你已经成功在IDEA中配置了git</p>
<p>在配置篇中，当我们已经在本地推送/克隆了一个项目后，我们能看到如下两个功能块。</p>
<p>在本文中，我们称红色箭头所指为<strong>git日志</strong>，蓝色箭头所指为<strong>git工具栏</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102051273.png"></p>
<h2 id="设置默认添加文件">设置默认添加文件</h2>
<p>还记得<strong>基础篇</strong>我们提到的四个工作区域吗？如果我们想要将变更的文件推送到远程仓库，我们首先需要<strong>先保证变更的文件在暂存区中</strong>。</p>
<p>在<strong>基础篇</strong>中，我们提到每当创建一个文件时，idea都会询问我们是否将文件添加到git，即是否添加到暂存区中。为了避免这种麻烦，我们打开设置，按以下流程选择<strong>无提示添加</strong>，这样idea就会默认将我们创建的文件自动添加到git了。</p>
<p>配置完该设置后，相当于每次创建文件都会默认执行git命令<code>git add</code>，作用是将文件添加到暂存区中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102106887.png"></p>
<h2 id="推送更改的文件到本地库">推送更改的文件到本地库</h2>
<blockquote>
<p>当我们在本地完成了我们的工作后，我们可以先将变更的文件提交到本地库中保存。</p>
</blockquote>
<p>这里我们点击蓝色箭头所指git工具栏的第二个按钮，即提交按钮。</p>
<p>该按钮对应git命令<code>git commit</code>，作用是将文件提交到本地库中。</p>
<p>这里我简单的修改了下我自己的更改，填写完提交信息后点击提交。</p>
<blockquote>
<p>如果点击提交并推送的话，就可以直接将变更推送到远程仓库，省去了一个步骤。</p>
<p>提交并推送按钮对应git命令<code>git commit &amp; git push</code>，作用是将暂存区的变更直接推送到远程仓库</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102104592.png"></p>
<p>提交完毕后，我们打开git日志，能在当前的本地分支中看到我们刚才提交记录：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102115556.png"></p>
<h2 id="将本地库的提交记录推送到远程库中">将本地库的提交记录推送到远程库中</h2>
<blockquote>
<p>当我们已经确定本地库的工作已经结束后，我们就可以将本地库的记录推送到远程库中。</p>
</blockquote>
<p>我们点击git工具栏的第三个按钮，即推送按钮。</p>
<p>该按钮对应git命令<code>git push</code>，作用是将本地的提交记录推送到远程库中。</p>
<p>这里我准备了两个提交记录，按<code>ctrl + 鼠标左键</code>可以多选提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102123171.png"></p>
<p>点击推送按钮后，我们可以在git日志中看到远程仓库中出现了我们刚才推送的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102124929.png"></p>
<p>此时我们打开gitee，可以发现提交记录同样生效于gitee中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102126723.png"></p>
<h2 id="拉取远程分支的变更">拉取远程分支的变更</h2>
<blockquote>
<p>当你的远程仓库发生改变时（你的队友推送了提交记录到远程仓库中），而你自己的远程分支不会自动拉取别人的提交记录，也就是说你的远程分支不具备别人的提交历史。</p>
</blockquote>
<p>此时我们需要点击提取所有远程按钮，这时候就可以把远程仓库的所有本更拉取到自己的远程分支中。</p>
<p>提取所有远程按钮对应git命令<code>git fetch</code>，作用是将远程仓库的变更拉取到远程分支中。</p>
<p>这里我在gitee中手动添加了一个README.md文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102135718.png"></p>
<p>点击按钮后，可以看到远程分支中增加了这条记录，同时，我们可以注意到本地分支名后出现了向下的蓝色箭头，这代表着当前远程分支已经更新了，本地分支也应该进行更新。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102138603.png"></p>
<p>我们选中对应的本地分支，点击更新所选内容按钮，就可以把远程分支的提交记录添加到我们的本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102152552.png"></p>
<p>这里我们也可以选择git工具栏的第一个按钮，这样就可以指定方式传入变更。</p>
<p>该按钮对应git命令<code>git merge</code>或<code>git rebase</code>，作用是传入变更到当前分支</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102154586.png"></p>
<p>结果如下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102152982.png"></p>
<h2 id="新建分支">新建分支</h2>
<blockquote>
<p>正常来说我们开发项目肯定不可能只用一个本地分支，一般会在其他分支中开发完毕后再推送到主分支中，这时候就需要新建分支的操作了。</p>
</blockquote>
<p>分支可以简单的理解为<strong>我想基于这个提交以及它所有的父提交进行新的工作</strong>。当我们新建分支时，Git就会将<strong>HEAD指向的提交记录以及该提交记录之前的所有提交记录</strong>保存到新分支中。</p>
<p>如果我们要新建分支，可以点击左侧工具栏的加号按钮，这样就得到了一个新的分支。</p>
<p>该按钮对应git命令<code>git branch</code>，作用是基于当前提交历史创建新的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131915710.png"></p>
<p>新建后我们得到了一个全新的分支dev，他包含了master的全部提交历史。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131916579.png"></p>
<p>当然，由于HEAD当前指向的是最后一个提交记录，所以新分支dev就包含了master的全部提交记录。如果我们要基于<code>测试1</code>这个提交历史创建分支的话，需要右键该提交历史，点击新建分支后再输入分支名并创建即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132014188.png"></p>
<p>这样我们就得到了一个包含测试1之前所有提交记录的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132015309.png"></p>
<h2 id="回到指定的提交历史">回到指定的提交历史</h2>
<blockquote>
<p>假设你当前开发的代码出现了问题，如何找回之前的代码？这时候就可以通过<strong>签出</strong>这一git提供功能回到之前的提交历史。当你签出到一个提交历史时，你就获取到了这个提交历史的所有代码。</p>
<p>注意：在签出前确保你当前的代码已经提交到了本地或者远程分支中，签出到其他提交记录时IDEA不会帮你自动保存当前的代码。</p>
</blockquote>
<p>在签出的操作中，我们必须要明白<code>HEAD</code>这一概念，<code>HEAD</code>
是一个<strong>指向当前所在分支的指针</strong>，或者是<strong>指向当前所在提交记录的指针</strong>。在IDEA中，HEAD的位置可以通过黄色便签来看到，比如在下图master的提交历史中，HEAD指向的分支就是master，同时指向提交消息为<code>add README.md.</code>的提交记录。这里我们将下图称为图1。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131935531.png"></p>
<p>如果我们要切换到<code>测试1</code>的提交历史上，右键<code>测试1</code>，点击签出修订。</p>
<p>签出修订按钮对应git命令<code>git checkout</code>，作用是将HEAD指针转移到当前分支/提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131925168.png"></p>
<p>可以看到黄色便签转移到了测试1上，证明我们当前在测试1的提交历史上，这时我们就可以基于测试1的代码进行修改了。这里我们将下图称为图2。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131945582.png"></p>
<p>但是这里有个问题，为什么图2在master分支上的黄色便签消失了？而在图1中黄色便签既指向了master又指向了最后一个提交记录<code>add README.md.</code></p>
<p>这里要明白一个原理，那就是分支本身也能看作是一个指针，这个指针<strong>恒指向该分支的最后一个提交记录</strong>。</p>
<p>那么在图1中，HEAD其实是通过指向分支<strong>进而</strong>指向了该分支的最后一个提交记录，即<code>HEAD-&gt;master-&gt;add README.md.</code>。而在图2中，HEAD被称作<code>游离的HEAD</code>，是因为它指向的并不是分支而是该分支的一个提交历史，自然就不会指向master分支了，即<code>HEAD-&gt;测试1</code>。</p>
<h2 id="基于指定提交历史修改代码">基于指定提交历史修改代码</h2>
<blockquote>
<p>在上一个<code>回到指定的提交历史</code>的操作中，我们通过签出的操作获取到了指定的提交历史的代码，这时我们就能够基于这个提交历史的代码进行开发。</p>
</blockquote>
<p>举个例子，假设我们要回到之前刚添加md文件的提交历史上进行代码开发，给md文件进行修改。我们当前分支的最新提交为<code>博文3</code>，如何回到提交历史<code>add README.md.</code>上？</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262003659.png"></p>
<p>第一步我们肯定要签出到<code>add README.md.</code>上，签出后可以发现项目文件回到了刚开始提交md文件的时候。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262003012.png"></p>
<p>这时我们对md文件进行修改，这里我删除了一些段落。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262007614.png"></p>
<p>然后点击提交按钮，将这个修改历史<code>666</code>提交到本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262007485.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262008726.png"></p>
<p>此时Git给出了警告。如果我们无视警告，仍然点击提交按钮，就会发现原本存在于<code>add README.md.</code>提交记录的指针消失了，而且我们修改后的提交记录<code>666</code>也并没有被提交到本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262012288.png"></p>
<p>还记得之前我们提到的<strong>游离的HEAD</strong>吗？如果直接在特定提交上修改代码并运行
<code>git commit</code>，这实际上会在游离的 HEAD
状态下创建一个新的提交，而不会创建分支。这样的操作可能会导致出现一个<strong>游离的提交</strong>，Git
的垃圾回收机制可能会删除这些提交。</p>
<h3 id="解决方法1">解决方法1</h3>
<p>一种方法是：我们在<strong>指定提交历史上创建一个分支</strong>，然后<strong>在新分支上开发完毕后进行提交</strong>。这两步操作前文已经详细介绍了，不再赘述，如图所示。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262020744.png"></p>
<h3 id="解决方法2">解决方法2</h3>
<p>第二种方法则是：对指定提交记录执行<code>git revert</code>命令，该命令会基于指定提交记录创建一个新的提交历史</p>
<p>我们可以右键一个提交记录，选择还原提交选项。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262038451.png"></p>
<p>如果当前分支的提交记录和还原的提交记录的文件存在差异的话会出现代码冲突。这里因为我当前分支的第一个提交记录<code>博文3</code>和<code>add README.md.</code>在md文件上存在差异，所以出现了冲突。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262041894.png"></p>
<p>由于我们当前的目标是回到<code>add README.md.</code>这个提交记录的代码中，所以我们选择忽略来自其他提交的变更，保留<code>add README.md.</code>提交记录的原本代码即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262042823.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262044196.png"></p>
<p>写好提交消息后点击提交</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262045900.png"></p>
<p>可以发现我们这样就创建了一个和<code>add README.md.</code>一模一样的提交记录了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262046939.png"></p>
<p>接着我们可以基于这个提交记录的代码进行开发，这里前文已经详细介绍了，不再赘述。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262053876.png"></p>
<h2 id="将远程分支拉取到本地">将远程分支拉取到本地</h2>
<blockquote>
<p>设想这样一个场景：你的同事创建了一个新的远程分支并做了一个新的功能，而这个分支是你本地没有的，你现在的工作要基于这个新的功能才能进行下去，那么我们就需要把这个远程分支拉取到本地来。</p>
</blockquote>
<p>在这个例子中，你的同事创建了远程分支<code>origin/dev</code>，而我们本地并没有与其对应的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132128177.png"></p>
<p>我们只需要右键该分支，点击签出，即可将该远程分支拉取到本地。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132131971.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132131639.png"></p>
<h2 id="代码整合">代码整合</h2>
<blockquote>
<p>在项目合作中，将其他人的代码整合到自己的代码中是经常用到的操作，这时就需要利用到Git的合并或变基功能。</p>
</blockquote>
<p>一般来说代码整合会遇到以下几种情况：</p>
<ol type="1">
<li>当前分支正好比其他分支少了几条记录</li>
</ol>
<p>如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，当前dev1中没有dev中的<code>add README.md.</code>的修改记录。首先确保我们当前分支在dev1分支上。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132149480.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132150655.png"></p>
<p>我们右键dev分支，选择变基或合并均可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132152900.png"></p>
<p>可以看到dev的提交记录整合到了dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132154892.png"></p>
<ol start="2" type="1">
<li>当前分支和其他分支都修改了几条记录</li>
</ol>
<p>如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，dev1中我写的md文件的内容较少。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132200024.png"></p>
<p>在dev中我的队友写的md文件的内容较多。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132201457.png"></p>
<p>现在一样要确保当前分支在dev1中，并且右键dev分支选择合并/变基来整合代码。这个时候就出现了<code>冲突</code>，大家应该很容易就想明白了，因为我当前分支和我队友的分支都同时存在文件名相同、内容不同的文件，这个问题不解决的话自然无法整合。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132206002.png"></p>
<p>解决冲突的话就需要你和队友进行协商。比如这里我的分支dev1就比较少，队友的分支dev写的比我详细，所以我可以进行"妥协"，直接用队友的md文件即可，点击<code>接受他们的</code>这个按钮就可以使用队友的md文件了。</p>
<p>当然，我们也可以不进行妥协，IDEA提供了强大的修订功能，通过点击<code>合并</code>按钮，我们可以选择整合该文件的特定部分。具体如何操作，大家自行练习吧~</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132211620.png"></p>
<h2 id="删除提交">删除提交</h2>
<blockquote>
<p>我们在实际开发中难免会提交一些无用的提交记录，这时需要利用删除提交的操作。</p>
</blockquote>
<p>右键一个提交记录，选择删除提交选项，即可删除。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262055354.png"></p>
<p>很简单吧？但要注意已经推送到远程分支的提交是<strong>不可删除</strong>的。</p>
<p>这里的绿色提交记录代表还<strong>未推送到远程分支的提交记录</strong>，棕色代表<strong>已经推送到远程分支的提交记录</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262057344.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目开发】Java调用Python方法一文详解</title>
    <url>/2024/04/26/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E3%80%91Java%E8%B0%83%E7%94%A8Python%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在这个人工智能技术迅速发展的时代，对于我们学生而言，参加软件竞赛已不再是单纯的技术比拼。传统的纯Java编写项目，虽然有其稳定与高效的优势，但在面对日益复杂的算法需求时，其竞争力已逐渐减弱。因此，将Java与Python这两种编程语言的优势相结合，实现<strong>算法与软件</strong>的完美融合，已成为提升项目竞争力的关键。</p>
<p>本文将详细讲解使用Java调用Python的三大方法，并分析各个方法的优势。</p>
<h2 id="jython库不推荐">1.jython库（不推荐）</h2>
<p>首先在pom.xml中导入jython对应依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.python<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jython-standalone<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定Python的版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="手动编写python语句">1.1.手动编写Python语句</h3>
<p>这里我们编写一个简单的a + b函数的实现样例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Python解释器</span></span><br><span class="line">    <span class="type">PythonInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PythonInterpreter</span>();</span><br><span class="line">    <span class="comment">// 编写函数</span></span><br><span class="line">    interpreter.exec(<span class="string">&quot;def add(a, b):\n    return a + b\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Python 函数</span></span><br><span class="line">    <span class="type">PyObject</span> <span class="variable">eval</span> <span class="operator">=</span> interpreter.eval(<span class="string">&quot;add(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果并打印</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Py.tojava(eval, <span class="type">int</span>.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以得到返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result: <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3 id="读取python文件进行调用">1.2.读取Python文件进行调用</h3>
<p>编写一个jythonTest.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>使用PythonInterpreter.execfile方法调用py文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PythonInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PythonInterpreter</span>();</span><br><span class="line">    interpreter.execfile(<span class="string">&quot;D:\\Workspaces\\Project\\intelpython\\jythonTest.py&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用jythonTest.py中的add方法</span></span><br><span class="line">    <span class="type">PyFunction</span> <span class="variable">func</span> <span class="operator">=</span> interpreter.get(<span class="string">&quot;add&quot;</span>,PyFunction.class);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">PyObject</span> <span class="variable">pyobj</span> <span class="operator">=</span> func.__call__(<span class="keyword">new</span> <span class="title class_">PyInteger</span>(a), <span class="keyword">new</span> <span class="title class_">PyInteger</span>(b));</span><br><span class="line">    System.out.println(<span class="string">&quot;获得方法的返回值 = &quot;</span> + pyobj.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<p>上述两个方法的优点是其集成性，Jython允许你在Java中直接执行Python代码，使得Java和Python代码可以直接进行交互。</p>
<p>缺点也是明显的，首先，Jython说到底是Java的库，可能无法完全支持Python的所有库和功能，其次，Python工程师的工作高度耦合在Java代码中，如果你和你的Python同事不能够忍受这种开发方式，那么就不要用这种方法。</p>
<h2 id="java调用命令行推荐">2.Java调用命令行（推荐）</h2>
<p>这种方法的原理是通过Java代码调用操作系统的命令行接口，然后在命令行中执行Python脚本。</p>
<p>Java程序可以通过<code>Runtime.getRuntime().exec()</code>方法或者更高级的<code>ProcessBuilder</code>类来实现这一功能。执行Python脚本后，Java程序可以通过<code>InputStream</code>流来捕获并处理Python脚本的输出结果。</p>
<h3 id="runtime.getruntime.exec方法调用">2.1.Runtime.getRuntime().exec()方法调用</h3>
<ol type="1">
<li>首先需要编写执行Python脚本的命令行语句</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写要执行的命令，注意路径中的转义字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;python D:\\demo1.py agrs1&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用Runtime.getRuntime().exec()方法执行命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令  </span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用process.getInputStream()捕获InputStream流，从而获取执行结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取标准输出  </span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭读取器  </span></span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用process.getErrorStream()捕获标准错误流（可选），如果Python语句报错会打印报错信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 读取标准错误输出（可选）  </span><br><span class="line">BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));</span><br><span class="line">while ((line = errorReader.readLine()) != null) &#123;</span><br><span class="line">	System.err.println(line);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭错误读取器  </span><br><span class="line">errorReader.close();</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>等待进程结束 ，使用process.waitFor()方法获取返回码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 等待进程结束  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">System.out.println(<span class="string">&quot;返回码: &quot;</span> + exitCode);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>完整代码为：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 编写要执行的命令，注意路径中的转义字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;python D:\\demo1.py agrs1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行命令  </span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取标准输出  </span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭读取器  </span></span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取标准错误输出（可选）  </span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">errorReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()));</span><br><span class="line">        <span class="keyword">while</span> ((line = errorReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭错误读取器  </span></span><br><span class="line">        errorReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待进程结束  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">        System.out.println(<span class="string">&quot;Python script exited with code: &quot;</span> + exitCode);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processbuilder类调用最推荐">2.2.ProcessBuilder类调用（最推荐）</h3>
<ol type="1">
<li>编写命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置Python脚本的路径和要传递的参数  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">pythonScriptPath</span> <span class="operator">=</span> <span class="string">&quot;/path/to/your/python/script.py&quot;</span>;  </span><br><span class="line">String[] command = &#123;<span class="string">&quot;python&quot;</span>, pythonScriptPath, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>&#125;; <span class="comment">// 根据需要调整命令和参数  </span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用ProcessBuilder启动进程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ProcessBuilder启动进程  </span></span><br><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(command);  </span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>完整代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaCallPython</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 配置Python脚本的路径和要传递的参数  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pythonScriptPath</span> <span class="operator">=</span> <span class="string">&quot;/path/to/your/python/script.py&quot;</span>;  </span><br><span class="line">            String[] command = &#123;<span class="string">&quot;python&quot;</span>, pythonScriptPath, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>&#125;; <span class="comment">// 根据需要调整命令和参数  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 使用ProcessBuilder启动进程  </span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(command);  </span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 读取标准输出  </span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));  </span><br><span class="line">            String line;  </span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                System.out.println(line);  </span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取标准错误输出（可选）  </span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">errorReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((line = errorReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.err.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭读取器  </span></span><br><span class="line">            reader.close();</span><br><span class="line">            errorReader.close();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 等待进程结束并获取退出值  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();  </span><br><span class="line">            System.out.println(<span class="string">&quot;\nExited with error code : &quot;</span> + exitCode);  </span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<p>两种方法都是通过创建一个Process进程调用命令行获取Python脚本的执行结果。主要区别为第二种方法需要额外创建一个ProcessBuilder类，ProcessBuilder类接收的是String数组，相较于Runtime只接收一个String字符串，ProcessBuilder类编写命令更加灵活。</p>
<h2 id="调用云端模型最推荐">3.调用云端模型（最推荐）</h2>
<p>这种方法需要Python工程师在百度云、腾讯云等云平台上开启接口，然后通过Hutool的工具类发送HTTP请求调用云端接口。</p>
<p>首先需要导入Hutool库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>填写接口地址，使用Map作为表单数据（一般使用表单，比较灵活，文件和文本都可以传输）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://xxx.com/&quot;</span>;</span><br><span class="line">HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;student&quot;</span>, student);</span><br><span class="line">paramMap.put(<span class="string">&quot;answer&quot;</span>, answer);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用HttpRequest发送请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">    .header(AUTH_REQUEST_HEADER, AUTH_REQUEST_SECRET)</span><br><span class="line">    .form(paramMap)</span><br><span class="line">    .execute();</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>判断返回结果合法性，进行相关处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断返回结果是否为空</span></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(execute)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用结果为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接口是否调用成功</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> execute.getStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;执行失败，错误码：&quot;</span> + status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>获取返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印响应结果</span></span><br><span class="line">System.out.println(execute.body());</span><br></pre></td></tr></table></figure>
<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用hutool工具的HttpRequest类发送请求调用python接口</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;student&quot;</span>, student);</span><br><span class="line">paramMap.put(<span class="string">&quot;answer&quot;</span>, answer);</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">    .header(AUTH_REQUEST_HEADER, AUTH_REQUEST_SECRET)</span><br><span class="line">    .form(paramMap)</span><br><span class="line">    .execute();</span><br><span class="line"><span class="comment">// 判断返回结果是否为空</span></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(execute)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用结果为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接口是否调用成功</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> execute.getStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;执行失败，错误码：&quot;</span> + status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印响应结果</span></span><br><span class="line">System.out.println(execute.body());</span><br></pre></td></tr></table></figure>
<h2 id="总结">4.总结</h2>
<h3 id="jython库">jython库</h3>
<p>优点：</p>
<ul>
<li>直接在Java程序中执行，可以直接利用Java虚拟机（JVM）的性能优势，减少进程间通信的开销。</li>
</ul>
<p>缺点：</p>
<ul>
<li>Jython可能无法完全支持Python的所有库和功能。</li>
</ul>
<h3 id="java调用命令行">Java调用命令行</h3>
<p>优点：</p>
<ul>
<li>Java和Python进程是独立的，这使得它们可以更容易地并行运行，而不会影响彼此的性能。</li>
<li>对于对硬件要求比较高的Python模型， 本地部署可能存在一定的困难。</li>
<li>对于开发人员比较友好，两者的开发工作分离。</li>
</ul>
<p>缺点：</p>
<ul>
<li>进程间通讯可能会引入额外的开销和复杂性。</li>
</ul>
<h3 id="调用云端模型">调用云端模型</h3>
<p>优点：</p>
<ul>
<li>对于开发人员比较友好，两者的开发工作分离。</li>
<li>利于构建大型算法模型，如百度云等云端平台对于Python模型支持度很高，比起本地更容易部署。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要Java和Python工程师对HTTP请求有一定了解。</li>
<li>云端接口需要支付一定的费用。</li>
</ul>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>调用python</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】二、基础篇</title>
    <url>/2023/12/10/%E4%BA%8C%E3%80%81Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>基础篇</strong>，将简要介绍使用Git所应该知道的<strong>最基本</strong>的知识，因此不算深究原理，哈哈。</p>
<p>注意：本文假设你已经成功在IDEA中配置了git</p>
<h2 id="git的四个工作区域">Git的四个工作区域</h2>
<h3 id="基本概念">基本概念</h3>
<p>Git本地有三个工作区域，分别是<strong>工作区</strong>、<strong>暂存区</strong>、<strong>本地仓库</strong></p>
<p>Git远程有一个工作区域，叫做<strong>远程仓库</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072037674.png"></p>
<ul>
<li><p>工作区：开发者当前工作的目录，主要包含项目的实际文件，其中可能包括<strong>未进行版本管理</strong>的新文件和<strong>已修改</strong>的文件。</p></li>
<li><p>暂存区：作为一个临时存储区域，用于存放工作区中已经修改的文件的<strong>快照</strong>，以便将它们作为一个逻辑单元提交到本地仓库。</p></li>
<li><p>本地库：包含了项目的<strong>提交历史</strong>，开发者可以对其进行各种操作，如分支合并、变基、签出等。本地库是在开发者本地计算机上的存储库。</p></li>
<li><p>远程库：
存放在<strong>代码托管平台</strong>（如Gitee、GitHub）上的仓库，包含了已推送的代码版本、分支、标签等信息。开发者可以通过推送和拉取操作与远程库进行交互，以保持代码同步。</p></li>
</ul>
<h3 id="概念解释">概念解释</h3>
<h4 id="工作区">工作区</h4>
<p>一下子引入了这么多概念，可能大家会有点接受不了，那么这里对以上概念进行详细解释。</p>
<p>具体来说，工作区可以看做你在IDEA中打开的项目目录，如下图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072100334.png"></p>
<p>这里的项目目录就可以看作是工作区，但是在这个工作区中，既存在正常颜色（白色）的文件名，也存在红色、绿色和蓝色的文件名，那么这些文件分别代表什么含义？这里的文件的颜色，其实也就对应着上文所谓<strong>未进行版本管理</strong>的新文件和<strong>已修改</strong>的文件。如下表：</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>颜色</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>白色</td>
<td>在当前提交历史未改动或者已经提交到本地库的文件</td>
</tr>
<tr class="even">
<td>红色</td>
<td>未进行版本管理的新文件，也被称为未跟踪的文件</td>
</tr>
<tr class="odd">
<td>绿色</td>
<td>已经进行版本管理的新文件，该文件已被添加到暂存区中</td>
</tr>
<tr class="even">
<td>蓝色</td>
<td>当前工作区中被修改的文件，该文件已被添加到暂存区中，与绿色相似</td>
</tr>
</tbody>
</table>
<blockquote>
<p>红色文件名、绿色文件名实例</p>
</blockquote>
<p>大家可以自行测试下，如果你直接在项目目录中创建一个文件的话，IDEA会做出提醒：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072113939.png"></p>
<p>这时如果你选择添加的话，该文件就会变成绿色文件从而<strong>被Git进行版本管理</strong>，如果选择取消的话，说明你不希望该文件被Git管理，那么该文件就是红色文件而<strong>不能被提交到暂存区</strong>。</p>
<p>总结：</p>
<ol type="1">
<li><p>当你创建一个新文件时，它就是红色的，表示这是一个未跟踪的文件。通过运行
<code>git add</code>
命令，将文件添加到暂存区，此时文件变为绿色，表示它已经被 Git
管理并准备提交。</p></li>
<li><p>如果你不想将一个未跟踪的文件或已修改的文件纳入版本管理，你可以选择不使用
<code>git add</code> 命令，或者使用 <code>git reset</code>
命令来取消已经添加到暂存区的文件。取消后，文件会回到红色状态，表示它未被跟踪或未被修改。</p></li>
<li><p>但是对于我们日常开发来说，我们创建一个文件肯定是有用意的，一般都希望该文件被提交上去，所以我们一般都选择添加文件，这样才能通过添加到暂存区，再到本地库最终推送到远程仓库中。</p></li>
</ol>
<blockquote>
<p>白色、蓝色文件名实例</p>
</blockquote>
<p>比如这里我删除了md文件中的其中一行，md文件的文件名由白色转为了蓝色</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072130777.png"></p>
<p>该文件一般在该项目已经<strong>提交到本地库</strong>中后，我们准备开发新的功能时才会出现，也就是我们修改了当前已经存在于本地库中的文件，该文件就会被转化成蓝色文件。因为该文件已经被<strong>Git版本管理过了</strong>，所以可以直接提交到本地库。</p>
<p>总结：</p>
<ol type="1">
<li>蓝色文件可以直接提交到本地库中，因为其已经被Git版本管理了</li>
<li>蓝色文件可以简单认为就是白色文件被修改后的文件</li>
</ol>
<h4 id="暂存区">暂存区</h4>
<p>经过前面的内容，大家多少应该可以感觉到，暂存区其实是我们看不见、摸不着的存在，在暂存区中存在的文件一般是绿色和蓝色文件，也就是我们已经使用<code>git add</code>命令添加的文件。</p>
<p>当我们开发完毕一个新的功能后，我们就会准备将这次修改记录提交到<strong>本地仓库</strong>，这时候使用<code>git commit</code>命令就可以将暂存区中的文件提交到本地仓库中。</p>
<blockquote>
<p>提交实例</p>
</blockquote>
<p>在该实例中，我们删除了md文件的其中一行（可以看到changes一栏中是蓝色文件，如果你把一个新的文件也添加到暂存区的话就是前文提到的绿色文件），这里我们要在下方框中填写相关介绍，以便帮助其他团队成员或日后的自己知道这次的提交做了什么。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072141103.png"></p>
<h4 id="本地库">本地库</h4>
<p>具体来说，本地库包含了开发者本地完整的提交历史和所有的本地分支，本地库中的提交记录是暂存区通过执行<code>git commit</code>后得来的。</p>
<p>这里要注意<strong>本地分支</strong>和<strong>本地库</strong>的区别，<strong>本地分支</strong>只是本地库众多分支的<strong>其中一个分支</strong>，当然本地库也可以只包含一个本地分支（但是一般来说开发者不会这么做）。</p>
<blockquote>
<p>本地分支实例</p>
</blockquote>
<p>这里展示了本地库中的master分支，在这个分支中存在着该分支的提交历史和各种信息。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072150426.png"></p>
<h4 id="远程库">远程库</h4>
<p>远程库是存放在<strong>代码托管平台</strong>（如Gitee、GitHub）上的仓库，本地库执行<code>git push</code>命令可将本地的提交记录推送到远程仓库中。</p>
<p><strong>远程分支</strong>和<strong>远程库</strong>的区别同<strong>本地分支</strong>与<strong>本地库</strong>的区别一样</p>
<blockquote>
<p>远程分支实例</p>
</blockquote>
<p>同上本地分支实例。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072201594.png"></p>
<p>需要注意的是，由于我们在团队开发中涉及到多人的共同协作，因此每个人都可以向远程仓库中推送自己的代码，也就意味在当你在开发新的代码时，远程仓库可能已经发生了变动，那么远程分支也就不能实时和远程仓库的提交记录保持同步了，这时我们需要使用<code>git fetch</code>命令，将远程仓库的提交记录拉取到的远程分支中。</p>
<h2 id="总结">总结</h2>
<p>通过对于工作区域的认识，大家想必已经了解了一个文件如何从工作区一步步提交到远程仓库中，当然这里存在着很多操作中的细节，如切换分支，合并来自其他分支的结果等，而我们是使用IDEA结合Git实现版本管理，同样存在着如何具体使用的问题。由于本篇只讲理论，就不过多介绍了，本系列将会继续更新下去，大家敬请期待~</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】四、git冲突篇</title>
    <url>/2024/01/04/%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>在使用Git进行项目管理时，代码合并是一项常见而重要的操作。本文将重点探讨两种常用的代码合并操作：合并（merge）和变基（rebase）。在进行代码合并时，我们难免会遇到Git冲突的情况。本文也将通过举例详细介绍如何通过IDEA使用Git进行合并或变基操作时可能遇到的代码冲突情况，并提供解决方法。</p>
<h2 id="什么是git冲突">什么是git冲突</h2>
<p>在多分支并行处理时，每个分支可能基于不同版本的主干分支创建。如果每个分支都独立开发而没有进行代码合并，自然不会出现代码冲突。但是，当两个分支同时修改同一文件时，在代码合并时就会出现冲突。</p>
<p>下图为两个分支分别使用合并/变基操作解决冲突后的提交树。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041548373.png"></p>
<h2 id="解决git冲突">解决git冲突</h2>
<p>介绍完冲突出现的原因，那么如何解决冲突呢？在解决git冲突时，我们需要确定以哪个分支的文件版本为准，或者取两个分支的文件的部分片段进行整合。</p>
<p>IDEA提供了强大的冲突解决功能，供用户处理git冲突。下面将进行详细介绍。</p>
<p>当前分支dev1的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印hello world</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印你好 世界</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你好 世界&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>目标分支dev的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">access</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//打印Red Dead:redemption2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Red Dead:redemption2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">access2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//打印荒野大镖客：救赎2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;荒野大镖客：救赎2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们现在的目标是<strong>让两个分支合并后的代码中同时出现method1、method2、access和acess2这四个方法</strong>。</p>
<p>执行合并后，出现界面：</p>
<p>左侧为<strong>当前分支</strong>dev1的提交记录，中间为合并前的<strong>预览结果</strong>，右侧为<strong>目标分支</strong>dev的提交记录。</p>
<p>其中红色区域为代码存在差异的部分。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041920979.png"></p>
<p>先来看第一块红色区域的中间部分的代码。大家一定会疑惑预览结果中出现这段代码是什么意思？为什么会出现报错呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>
<p>这里其实是git对于左右侧存在差异的代码的标记。符号&lt;&lt;&lt;&lt;&lt;&lt;&lt;
xxx的下方是左侧存在差异的代码，符号&gt;&gt;&gt;&gt;&gt;&gt;
xxx的上方是右侧存在差异的代码，比如&lt;&lt;&lt;&lt;&lt;&lt;&lt;
HEAD箭头所指方向也就是我们当前分支的方向（在左侧），在该箭头下面的部分是当前分支的与目标分支的差异代码，这里因为左侧比右侧少了一段代码，因此下面啥东西没有；=======代表分割符号，该分割符号的下面就是目标分支的代码，即import
java.util.concurrent.TimeUnit；&gt;&gt;&gt;&gt;&gt;&gt;&gt;
dev也就代表目标分支的方向（在右侧）</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041931339.png"></p>
<p>那么如何解决冲突呢？对于我们的目标来说，我们的输出语句自然不需要导入这个包，因此把语句<code>import java.util.concurrent.TimeUnit;</code>给删除即可。</p>
<p>点击左侧的箭头符号，可以把<strong>中间区域被替换成左侧的红色区域</strong>（那根细线，也就是没有代码）。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041939164.png"></p>
<p>点击后中间区域消失。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041940548.png"></p>
<p>再来看第二个红色区域，根据我们的目标，我们要将这四个方法都添加进入中间区域。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041941892.png"></p>
<p>先点击左侧的箭头。可以发现<strong>中间区域被替换为左侧代码</strong>，右侧向左箭头变成了向左下箭头。</p>
<p>这个向左下的箭头代表<strong>将右侧的代码添加到中间代码的下方</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041942329.png"></p>
<p>点击后如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041945639.png"></p>
<p>那么一切就大功告成了，冲突解决成功，点击应用按钮。</p>
<p>git提示还有冲突未处理，这是为什么？</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041946034.png"></p>
<p>把界面翻到上面，发现这个红色区域还没有处理，我们点击那个查号，作用是<strong>将冲突标记为已解决</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041947522.png"></p>
<p>这时IDEA提示所有变更已被处理，那么我们就可以放心大胆的合并了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041948825.png"></p>
<p>合并成功！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041949361.png"></p>
<h2 id="合并变基详解">合并/变基详解</h2>
<h3 id="合并git-merge">合并（git merge）</h3>
<p>当前分支和目标分支执行合并操作时，Git会将当前分支的<strong>最新提交记录</strong>与目标分支的<strong>最新提交记录</strong>合并，并在当前分支<strong>形成一个新的提交记录</strong>。</p>
<h4 id="示例1">示例1</h4>
<p>当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041725999.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041724559.png"></p>
<p>执行合并操作，dev中的提交记录添加到了分支dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041724739.png"></p>
<h4 id="示例2">示例2</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730233.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730182.png"></p>
<p>执行合并操作，git给出提示（已是最新
删除dev），当前分支dev1没有变动。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730921.png"></p>
<h4 id="示例3">示例3</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录<code>添加测试类</code>，目标分子dev中有新提交记录<code>添加新文件</code>（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突）</p>
<p>dev1中添加了一个JavaTest文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041800046.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803802.png"></p>
<p>dev分支中添加了一个test.lua文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801717.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801057.png"></p>
<p>执行合并操作，在目标分支dev1中生成一个新的提交记录<code>Merge branch 'dev' into dev1</code>，该提交记录包含了这两个提交记录的变更，如图。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803003.png"></p>
<p>在提交树中，可以看到两个提交记录合并为一个记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041806469.png"></p>
<h3 id="变基git-rebase">变基（git rebase）</h3>
<p>当前分支和目标分支执行变基操作时，Git会将目标分支的最新提交记录依次应用到当前分支的每个新的提交记录中。</p>
<h4 id="示例1-1">示例1</h4>
<p>当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041817890.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041818586.png"></p>
<p>执行变基操作，dev中的两条记录添加到了dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041818966.png"></p>
<h4 id="示例2-1">示例2</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041819420.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041820315.png"></p>
<p>执行变基操作，没有发生变化。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041821704.png"></p>
<h4 id="示例3-1">示例3</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录<code>添加测试类</code>，目标分子dev中有新提交记录<code>添加新文件</code>（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突）</p>
<p>dev1中添加了一个JavaTest文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041800046.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803802.png"></p>
<p>dev分支中添加了一个test.lua文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801717.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801057.png"></p>
<p>执行变基操作，dev分支的提交记录添加到了dev1分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041815763.png"></p>
<h3 id="总结">总结</h3>
<p>可以发现，无论是对于合并还是变基操作的示例1和示例2，最终执行操作后的结果都是一样的。对于合并操作，git将两个分支进行合并，最后生成一个新的提交记录，提交树存在交叉。对于变基操作，git将目标分支的提交记录应用到当前分支，提交树仍然是线性的。如图所示。</p>
<p>至于在实际开发中选择合并还是变基，还是看个人喜好了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041857723.png"></p>
<h2 id="代码冲突示例">代码冲突示例</h2>
<p>注意：本文为方便理解，所有示例均简单的修改项目中的md文件，实际开发中可能存在对多个文件的冲突，但万变不离其宗，只要你具备了解决单个文件代码冲突的能力，那么多个文件的冲突也能轻松应对。</p>
<h3 id="合并变基分支1">合并/变基分支1</h3>
<blockquote>
<p>分支情况，当前dev1的两个提交记录<code>博文1</code>和<code>博文2</code>都在dev的提交记录<code>博文3</code>之前，其余分支一样</p>
<p>时间顺序：博文1-&gt;博文2-&gt;博文3</p>
</blockquote>
<h4 id="合并">合并</h4>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171650606.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171651771.png"></p>
<p>此时合并<strong>有代码冲突</strong>，解决这个冲突。</p>
<p>发现该冲突只针对博文2，也就是最后一个提交记录</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171656401.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171653568.png"></p>
<h4 id="变基">变基</h4>
<p>该冲突为<code>博文1</code>和<code>博文3</code>的冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171659732.png"></p>
<p>该冲突为变基后的<code>博文1</code>和<code>博文2</code>的冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171704664.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171705189.png"></p>
<h3 id="合并变基分支2">合并/变基分支2</h3>
<blockquote>
<p>分支情况：</p>
<p>dev中的<code>博文3</code>在dev1中的<code>博文1</code>和<code>博文2</code>之间</p>
<p>时间顺序：博文1-&gt;博文3-&gt;博文2</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221625858.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221625313.png"></p>
<h4 id="合并-1">合并</h4>
<p>基于上述情况，合并分支存在代码冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171852617.png"></p>
<p>在代码冲突中，存在<strong>博文2和博文3</strong>的冲突，</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221626751.png"></p>
<p>冲突解决后如图所示。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221626357.png"></p>
<p>这里紫色因为<code>博文3</code>是属于别的分支过来的，其父提交是<code>add README.md.</code>。所以从<code>add README.md.</code>出发，与dev1原本的提交记录<code>博文2</code>结合形成一个新的提交记录<code>Merge branch 'dev' into dev1</code></p>
<p>结论：分支以时间顺序进行排序，合并分支永远是两个分支的最后一个提交历史进行合并。</p>
<h4 id="变基-1">变基</h4>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221627898.png"></p>
<p><code>博文1</code>和<code>博文3</code>存在冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221627499.png"></p>
<p>冲突解决后，选择提交消息不变</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221628613.png"></p>
<p>依然存在冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221629350.png"></p>
<p>可以发现该冲突来自于已经变基的提交<code>博文1</code>和之后的<code>博文2</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221637405.png"></p>
<p>得到变基后的提交树</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221637539.png"></p>
<h3 id="合并变基分支3">合并/变基分支3</h3>
<blockquote>
<p>分支情况：</p>
<p>dev1中的两个提交记录<code>博文1</code>和<code>博文2</code>在dev中的<code>博文3</code>提交之后</p>
<p>时间顺序：博文3-&gt;博文1-&gt;博文2</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221647989.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221647856.png"></p>
<h4 id="合并-2">合并</h4>
<p><code>博文2</code>和<code>博文3</code>存在代码冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041446569.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221648662.png"></p>
<h4 id="变基-2">变基</h4>
<p>冲突来自于<code>博文3</code>和<code>博文1</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221730553.png"></p>
<p>冲突来自变基后的<code>博文1</code>和<code>博文2</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221730592.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221651338.png"></p>
<h3 id="总结-1">总结</h3>
<p>通过这三个代码冲突的示例，看到区别了吗？</p>
<p>在合并操作时，冲突通常发生在<strong>两个分支的最新提交记录</strong>上。这是因为合并是将两个不同的分支合并为一个，而最新的提交记录是两个分支的端点。如果两个分支都对同一文件进行了修改，Git
无法确定应该选择哪个更改，因此会产生冲突。</p>
<p>在变基操作时，冲突可能发生在<strong>当前分支的提交记录和目标分支的提交记录之间的每个提交记录</strong>上。这是因为变基是将一系列提交应用到另一个分支上，而不仅仅是最新的提交。如果两个分支都修改了相同的文件，冲突可能会在每个提交记录上发生，而不仅仅是最新的提交。</p>
<p>总的来说，冲突是由于两个分支都对同一文件进行了修改，而 Git
无法自动解决冲突的情况下发生的。在合并操作中，冲突通常发生在最新的提交记录上；在变基操作中，冲突可能发生在多个提交记录上。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的设计模式</title>
    <url>/2024/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式">单例模式</h2>
<h3 id="懒汉式">懒汉式</h3>
<p>通常使用<strong>双重校验+锁</strong>的方式实现</p>
<p><strong>volatile</strong>关键字可防止指令重排，比如创建一个对象，JVM会分为三步：</p>
<blockquote>
<ol type="1">
<li><p>为singleton分配内存空间</p></li>
<li><p>初始化singleton对象</p></li>
<li><p>将singleton指向分配好的内存空间</p></li>
</ol>
</blockquote>
<p>指令重排：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p>
<p>而<strong>volatile</strong>关键字会防止指令重排，从而保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式">饿汉式</h3>
<p>饿汉式在类加载时就创建好了对象，程序调用时可直接返回对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式">工厂模式</h2>
<p>对于接口存在多个实现类时，如果使用if-else语句进行实例化接口的操作，不利于代码扩展，如果换用其他实现类很麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">executeCode</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 接口实例化</span></span><br><span class="line">       <span class="type">CodeSandbox</span> <span class="variable">codeSandbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteCodeSandbox</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>使用静态工厂模式可以灵活切换实现类，提高通用性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码沙箱工厂（根据字符串参数创建指定的代码沙箱实例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeSandboxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代码沙箱示例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 沙箱类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CodeSandbox <span class="title function_">newInstance</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;example&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExampleCodeSandbox</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;remote&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteCodeSandbox</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;thirdParty&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyCodeSandbox</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExampleCodeSandbox</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只需调用工厂类的静态方法，传入指定参数即可实例化对象。</p>
<h2 id="代理模式">代理模式</h2>
<p>实现原理：</p>
<ol type="1">
<li>实现被代理的接口</li>
<li>通过构造函数接收一个被代理的接口实现类</li>
<li>调用被代理的接口实现类，在调用前后增加对应的操作</li>
</ol>
<p>比如，我们需要在调用代码沙箱前，输出请求参数日志；在代码沙箱调用后，输出响应结果日志，便于管理员去分析数据。</p>
<p>可以使用代理模式，提供一个<strong>Proxy</strong>，来增强代码沙箱的能力（代理模式的作用就是增强能力）</p>
<p>原本：需要用户自己去调用多次</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202402181536763.png"></p>
<p>使用代理后：不仅不用改变原本的代码沙箱实现类，而且对调用者来说，调用方式几乎没有改变，也不需要在每个调用沙箱的地方去写统计代码。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202402181538503.png"></p>
<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeSandboxProxy</span> <span class="keyword">implements</span> <span class="title class_">CodeSandbox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CodeSandbox codeSandbox;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeSandboxProxy</span><span class="params">(CodeSandbox codeSandbox)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.codeSandbox = codeSandbox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExecuteCodeResponse <span class="title function_">executeCode</span><span class="params">(ExecuteCodeRequest executeCodeRequest)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;代码沙箱请求信息：&quot;</span> + executeCodeRequest.toString());</span><br><span class="line">        <span class="type">ExecuteCodeResponse</span> <span class="variable">executeCodeResponse</span> <span class="operator">=</span> codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        log.info(<span class="string">&quot;代码沙箱响应信息：&quot;</span> + executeCodeResponse.toString());</span><br><span class="line">        <span class="keyword">return</span> executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CodeSandbox</span> <span class="variable">codeSandbox</span> <span class="operator">=</span> CodeSandboxFactory.newInstance(type);</span><br><span class="line">codeSandbox = <span class="keyword">new</span> <span class="title class_">CodeSandboxProxy</span>(codeSandbox);</span><br></pre></td></tr></table></figure>
<h2 id="策略模式">策略模式</h2>
<p>我们的判题策略可能会有很多种，比如:
我们的代码沙箱本身执行程序需要消耗时间，这个时间可能不同的编程语
言是不同的，比如沙箱执行 Java 要额外花 10 秒。</p>
<p>我们可以采用策略模式，针对不同的情况，定义独立的策略，便于分别修改策略和维护。而不是把所有的判题逻
辑、if ... else ...代码全部混在一起写.</p>
<ol type="1">
<li>定义一个策略接口，让代码更通用化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JudgeStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行判题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> judgeContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JudgeInfo <span class="title function_">doJudge</span><span class="params">(JudgeContext judgeContext)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>定义判题上下文对象，用于定义在策略中传递的参数 (可以理解为一种
DTO)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上下文（用于定义在策略中传递的参数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgeContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JudgeInfo judgeInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; inputList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; outputList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JudgeCase&gt; judgeCaseList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Question question;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QuestionSubmit questionSubmit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>实现接口，实现各种判题策略</li>
</ol>
<blockquote>
<p>但是，如果选择某种判题策略的过程比较复杂，如果都写在调用判题服务的代码中，代码会越来越复杂，会有大量
if ... else ...，所以建议单独编写一个判断策略的类。</p>
</blockquote>
<ol start="4" type="1">
<li>定义JudgeManager，目的是尽量简化对判题功能的调用，让调用方写最少的代码、调用最简单。对于判题
策略的选取，也是在JudgeManager 里处理的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgeManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行判题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> judgeContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JudgeInfo <span class="title function_">doJudge</span><span class="params">(JudgeContext judgeContext)</span> &#123;</span><br><span class="line">        <span class="type">QuestionSubmit</span> <span class="variable">questionSubmit</span> <span class="operator">=</span> judgeContext.getQuestionSubmit();</span><br><span class="line">        <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> questionSubmit.getLanguage();</span><br><span class="line">        <span class="type">JudgeStrategy</span> <span class="variable">judgeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultJudgeStrategy</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;java&quot;</span>.equals(language)) &#123;</span><br><span class="line">            judgeStrategy = <span class="keyword">new</span> <span class="title class_">JavaLanguageJudgeStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judgeStrategy.doJudge(judgeContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板方法模式">模板方法模式</h2>
<p>定义一个模板方法抽象类。</p>
<p>先复制具体的实现类，把代码从完整的方法抽离成一个个子方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 代码沙箱模板方法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JavaCodeSandboxTemplate</span> <span class="keyword">implements</span> <span class="title class_">CodeSandbox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GLOBAL_CODE_DIR_NAME</span> <span class="operator">=</span> <span class="string">&quot;tmpCode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GLOBAL_JAVA_CLASS_NAME</span> <span class="operator">=</span> <span class="string">&quot;Main.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIME_OUT</span> <span class="operator">=</span> <span class="number">5000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExecuteCodeResponse <span class="title function_">executeCode</span><span class="params">(ExecuteCodeRequest executeCodeRequest)</span> &#123;</span><br><span class="line">        List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> executeCodeRequest.getCode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. 把用户的代码保存为文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">userCodeFile</span> <span class="operator">=</span> saveCodeToFile(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2. 编译代码，得到 class 文件</span></span><br><span class="line">        <span class="type">ExecuteMessage</span> <span class="variable">compileFileExecuteMessage</span> <span class="operator">=</span> compileFile(userCodeFile);</span><br><span class="line">        System.out.println(compileFileExecuteMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行代码，得到输出结果</span></span><br><span class="line">        List&lt;ExecuteMessage&gt; executeMessageList = runFile(userCodeFile, inputList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        4. 收集整理输出结果</span></span><br><span class="line">        <span class="type">ExecuteCodeResponse</span> <span class="variable">outputResponse</span> <span class="operator">=</span> getOutputResponse(executeMessageList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        5. 文件清理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> deleteFile(userCodeFile);</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;deleteFile error, userCodeFilePath = &#123;&#125;&quot;</span>, userCodeFile.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 把用户的代码保存为文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 用户代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> File <span class="title function_">saveCodeToFile</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">globalCodePathName</span> <span class="operator">=</span> userDir + File.separator + GLOBAL_CODE_DIR_NAME;</span><br><span class="line">        <span class="comment">// 判断全局代码目录是否存在，没有则新建</span></span><br><span class="line">        <span class="keyword">if</span> (!FileUtil.exist(globalCodePathName)) &#123;</span><br><span class="line">            FileUtil.mkdir(globalCodePathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把用户的代码隔离存放</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userCodeParentPath</span> <span class="operator">=</span> globalCodePathName + File.separator + UUID.randomUUID();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userCodePath</span> <span class="operator">=</span> userCodeParentPath + File.separator + GLOBAL_JAVA_CLASS_NAME;</span><br><span class="line">        <span class="type">File</span> <span class="variable">userCodeFile</span> <span class="operator">=</span> FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> userCodeFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、编译代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userCodeFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ExecuteMessage <span class="title function_">compileFile</span><span class="params">(File userCodeFile)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">compileCmd</span> <span class="operator">=</span> String.format(<span class="string">&quot;javac -encoding utf-8 %s&quot;</span>, userCodeFile.getAbsolutePath());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">compileProcess</span> <span class="operator">=</span> Runtime.getRuntime().exec(compileCmd);</span><br><span class="line">            <span class="type">ExecuteMessage</span> <span class="variable">executeMessage</span> <span class="operator">=</span> ProcessUtils.runProcessAndGetMessage(compileProcess, <span class="string">&quot;编译&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (executeMessage.getExitValue() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;编译错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> executeMessage;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//            return getErrorResponse(e);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、执行文件，获得执行结果列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userCodeFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ExecuteMessage&gt; <span class="title function_">runFile</span><span class="params">(File userCodeFile, List&lt;String&gt; inputList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userCodeParentPath</span> <span class="operator">=</span> userCodeFile.getParentFile().getAbsolutePath();</span><br><span class="line"></span><br><span class="line">        List&lt;ExecuteMessage&gt; executeMessageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String inputArgs : inputList) &#123;</span><br><span class="line"><span class="comment">//            String runCmd = String.format(&quot;java -Xmx256m -Dfile.encoding=UTF-8 -cp %s Main %s&quot;, userCodeParentPath, inputArgs);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">runCmd</span> <span class="operator">=</span> String.format(<span class="string">&quot;java -Xmx256m -Dfile.encoding=UTF-8 -cp %s Main %s&quot;</span>, userCodeParentPath, inputArgs);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Process</span> <span class="variable">runProcess</span> <span class="operator">=</span> Runtime.getRuntime().exec(runCmd);</span><br><span class="line">                <span class="comment">// 超时控制</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(TIME_OUT);</span><br><span class="line">                        System.out.println(<span class="string">&quot;超时了，中断&quot;</span>);</span><br><span class="line">                        runProcess.destroy();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                <span class="type">ExecuteMessage</span> <span class="variable">executeMessage</span> <span class="operator">=</span> ProcessUtils.runProcessAndGetMessage(runProcess, <span class="string">&quot;运行&quot;</span>);</span><br><span class="line">                System.out.println(executeMessage);</span><br><span class="line">                executeMessageList.add(executeMessage);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;执行错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executeMessageList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、获取输出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executeMessageList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ExecuteCodeResponse <span class="title function_">getOutputResponse</span><span class="params">(List&lt;ExecuteMessage&gt; executeMessageList)</span> &#123;</span><br><span class="line">        <span class="type">ExecuteCodeResponse</span> <span class="variable">executeCodeResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecuteCodeResponse</span>();</span><br><span class="line">        List&lt;String&gt; outputList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 取用时最大值，便于判断是否超时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ExecuteMessage executeMessage : executeMessageList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> executeMessage.getErrorMessage();</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(errorMessage)) &#123;</span><br><span class="line">                executeCodeResponse.setMessage(errorMessage);</span><br><span class="line">                <span class="comment">// 用户提交的代码执行中存在错误</span></span><br><span class="line">                executeCodeResponse.setStatus(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outputList.add(executeMessage.getMessage());</span><br><span class="line">            <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> executeMessage.getTime();</span><br><span class="line">            <span class="keyword">if</span> (time != <span class="literal">null</span>) &#123;</span><br><span class="line">                maxTime = Math.max(maxTime, time);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常运行完成</span></span><br><span class="line">        <span class="keyword">if</span> (outputList.size() == executeMessageList.size()) &#123;</span><br><span class="line">            executeCodeResponse.setStatus(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executeCodeResponse.setOutputList(outputList);</span><br><span class="line">        <span class="type">JudgeInfo</span> <span class="variable">judgeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JudgeInfo</span>();</span><br><span class="line">        judgeInfo.setTime(maxTime);</span><br><span class="line">        <span class="comment">// 要借助第三方库来获取内存占用，非常麻烦，此处不做实现</span></span><br><span class="line"><span class="comment">//        judgeInfo.setMemory();</span></span><br><span class="line">        executeCodeResponse.setJudgeInfo(judgeInfo);</span><br><span class="line">        <span class="keyword">return</span> executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5、删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userCodeFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFile</span><span class="params">(File userCodeFile)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (userCodeFile.getParentFile() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userCodeParentPath</span> <span class="operator">=</span> userCodeFile.getParentFile().getAbsolutePath();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">del</span> <span class="operator">=</span> FileUtil.del(userCodeParentPath);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除&quot;</span> + (del ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6、获取错误响应</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecuteCodeResponse <span class="title function_">getErrorResponse</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">ExecuteCodeResponse</span> <span class="variable">executeCodeResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecuteCodeResponse</span>();</span><br><span class="line">        executeCodeResponse.setOutputList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        executeCodeResponse.setMessage(e.getMessage());</span><br><span class="line">        <span class="comment">// 表示代码沙箱错误</span></span><br><span class="line">        executeCodeResponse.setStatus(<span class="number">2</span>);</span><br><span class="line">        executeCodeResponse.setJudgeInfo(<span class="keyword">new</span> <span class="title class_">JudgeInfo</span>());</span><br><span class="line">        <span class="keyword">return</span> executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着子类可以继承模板方法</p>
<p>java原生代码沙箱实现，可以直接复用模板方法定义好的方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 原生代码沙箱实现（直接复用模板方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaNativeCodeSandbox</span> <span class="keyword">extends</span> <span class="title class_">JavaCodeSandboxTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExecuteCodeResponse <span class="title function_">executeCode</span><span class="params">(ExecuteCodeRequest executeCodeRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.executeCode(executeCodeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>docker代码沙箱实现，根据需求重写模板方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaDockerCodeSandbox</span> <span class="keyword">extends</span> <span class="title class_">JavaCodeSandboxTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIME_OUT</span> <span class="operator">=</span> <span class="number">5000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FIRST_INIT</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JavaDockerCodeSandbox</span> <span class="variable">javaNativeCodeSandbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaDockerCodeSandbox</span>();</span><br><span class="line">        <span class="type">ExecuteCodeRequest</span> <span class="variable">executeCodeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecuteCodeRequest</span>();</span><br><span class="line">        executeCodeRequest.setInputList(Arrays.asList(<span class="string">&quot;1 2&quot;</span>, <span class="string">&quot;1 3&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> ResourceUtil.readStr(<span class="string">&quot;testCode/simpleComputeArgs/Main.java&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//        String code = ResourceUtil.readStr(&quot;testCode/unsafeCode/RunFileError.java&quot;, StandardCharsets.UTF_8);</span></span><br><span class="line"><span class="comment">//        String code = ResourceUtil.readStr(&quot;testCode/simpleCompute/Main.java&quot;, StandardCharsets.UTF_8);</span></span><br><span class="line">        executeCodeRequest.setCode(code);</span><br><span class="line">        executeCodeRequest.setLanguage(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="type">ExecuteCodeResponse</span> <span class="variable">executeCodeResponse</span> <span class="operator">=</span> javaNativeCodeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        System.out.println(executeCodeResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、创建容器，把文件复制到容器内</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userCodeFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ExecuteMessage&gt; <span class="title function_">runFile</span><span class="params">(File userCodeFile, List&lt;String&gt; inputList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userCodeParentPath</span> <span class="operator">=</span> userCodeFile.getParentFile().getAbsolutePath();</span><br><span class="line">        <span class="comment">// 获取默认的 Docker Client</span></span><br><span class="line">        <span class="type">DockerClient</span> <span class="variable">dockerClient</span> <span class="operator">=</span> DockerClientBuilder.getInstance().build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉取镜像</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;openjdk:8-alpine&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (FIRST_INIT) &#123;</span><br><span class="line">            <span class="type">PullImageCmd</span> <span class="variable">pullImageCmd</span> <span class="operator">=</span> dockerClient.pullImageCmd(image);</span><br><span class="line">            <span class="type">PullImageResultCallback</span> <span class="variable">pullImageResultCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PullImageResultCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(PullResponseItem item)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;下载镜像：&quot;</span> + item.getStatus());</span><br><span class="line">                    <span class="built_in">super</span>.onNext(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pullImageCmd</span><br><span class="line">                        .exec(pullImageResultCallback)</span><br><span class="line">                        .awaitCompletion();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;拉取镜像异常&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建容器</span></span><br><span class="line"></span><br><span class="line">        <span class="type">CreateContainerCmd</span> <span class="variable">containerCmd</span> <span class="operator">=</span> dockerClient.createContainerCmd(image);</span><br><span class="line">        <span class="type">HostConfig</span> <span class="variable">hostConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostConfig</span>();</span><br><span class="line">        hostConfig.withMemory(<span class="number">100</span> * <span class="number">1000</span> * <span class="number">1000L</span>);</span><br><span class="line">        hostConfig.withMemorySwap(<span class="number">0L</span>);</span><br><span class="line">        hostConfig.withCpuCount(<span class="number">1L</span>);</span><br><span class="line">        hostConfig.withSecurityOpts(Arrays.asList(<span class="string">&quot;seccomp=安全管理配置字符串&quot;</span>));</span><br><span class="line">        hostConfig.setBinds(<span class="keyword">new</span> <span class="title class_">Bind</span>(userCodeParentPath, <span class="keyword">new</span> <span class="title class_">Volume</span>(<span class="string">&quot;/app&quot;</span>)));</span><br><span class="line">        <span class="type">CreateContainerResponse</span> <span class="variable">createContainerResponse</span> <span class="operator">=</span> containerCmd</span><br><span class="line">                .withHostConfig(hostConfig)</span><br><span class="line">                .withNetworkDisabled(<span class="literal">true</span>)</span><br><span class="line">                .withReadonlyRootfs(<span class="literal">true</span>)</span><br><span class="line">                .withAttachStdin(<span class="literal">true</span>)</span><br><span class="line">                .withAttachStderr(<span class="literal">true</span>)</span><br><span class="line">                .withAttachStdout(<span class="literal">true</span>)</span><br><span class="line">                .withTty(<span class="literal">true</span>)</span><br><span class="line">                .exec();</span><br><span class="line">        System.out.println(createContainerResponse);</span><br><span class="line">        <span class="type">String</span> <span class="variable">containerId</span> <span class="operator">=</span> createContainerResponse.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动容器</span></span><br><span class="line">        dockerClient.startContainerCmd(containerId).exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// docker exec keen_blackwell java -cp /app Main 1 3</span></span><br><span class="line">        <span class="comment">// 执行命令并获取结果</span></span><br><span class="line">        List&lt;ExecuteMessage&gt; executeMessageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String inputArgs : inputList) &#123;</span><br><span class="line">            <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">            String[] inputArgsArray = inputArgs.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            String[] cmdArray = ArrayUtil.append(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-cp&quot;</span>, <span class="string">&quot;/app&quot;</span>, <span class="string">&quot;Main&quot;</span>&#125;, inputArgsArray);</span><br><span class="line">            <span class="type">ExecCreateCmdResponse</span> <span class="variable">execCreateCmdResponse</span> <span class="operator">=</span> dockerClient.execCreateCmd(containerId)</span><br><span class="line">                    .withCmd(cmdArray)</span><br><span class="line">                    .withAttachStderr(<span class="literal">true</span>)</span><br><span class="line">                    .withAttachStdin(<span class="literal">true</span>)</span><br><span class="line">                    .withAttachStdout(<span class="literal">true</span>)</span><br><span class="line">                    .exec();</span><br><span class="line">            System.out.println(<span class="string">&quot;创建执行命令：&quot;</span> + execCreateCmdResponse);</span><br><span class="line"></span><br><span class="line">            <span class="type">ExecuteMessage</span> <span class="variable">executeMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecuteMessage</span>();</span><br><span class="line">            <span class="keyword">final</span> String[] message = &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">            <span class="keyword">final</span> String[] errorMessage = &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">// 判断是否超时</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span>[] timeout = &#123;<span class="literal">true</span>&#125;;</span><br><span class="line">            <span class="type">String</span> <span class="variable">execId</span> <span class="operator">=</span> execCreateCmdResponse.getId();</span><br><span class="line">            <span class="type">ExecStartResultCallback</span> <span class="variable">execStartResultCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecStartResultCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果执行完成，则表示没超时</span></span><br><span class="line">                    timeout[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">super</span>.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Frame frame)</span> &#123;</span><br><span class="line">                    <span class="type">StreamType</span> <span class="variable">streamType</span> <span class="operator">=</span> frame.getStreamType();</span><br><span class="line">                    <span class="keyword">if</span> (StreamType.STDERR.equals(streamType)) &#123;</span><br><span class="line">                        errorMessage[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(frame.getPayload());</span><br><span class="line">                        System.out.println(<span class="string">&quot;输出错误结果：&quot;</span> + errorMessage[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        message[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(frame.getPayload());</span><br><span class="line">                        System.out.println(<span class="string">&quot;输出结果：&quot;</span> + message[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">super</span>.onNext(frame);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span>[] maxMemory = &#123;<span class="number">0L</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取占用的内存</span></span><br><span class="line">            <span class="type">StatsCmd</span> <span class="variable">statsCmd</span> <span class="operator">=</span> dockerClient.statsCmd(containerId);</span><br><span class="line">            ResultCallback&lt;Statistics&gt; statisticsResultCallback = statsCmd.exec(<span class="keyword">new</span> <span class="title class_">ResultCallback</span>&lt;Statistics&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Statistics statistics)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;内存占用：&quot;</span> + statistics.getMemoryStats().getUsage());</span><br><span class="line">                    maxMemory[<span class="number">0</span>] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Closeable closeable)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            statsCmd.exec(statisticsResultCallback);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stopWatch.start();</span><br><span class="line">                dockerClient.execStartCmd(execId)</span><br><span class="line">                        .exec(execStartResultCallback)</span><br><span class="line">                        .awaitCompletion(TIME_OUT, TimeUnit.MICROSECONDS);</span><br><span class="line">                stopWatch.stop();</span><br><span class="line">                time = stopWatch.getLastTaskTimeMillis();</span><br><span class="line">                statsCmd.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序执行异常&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            executeMessage.setMessage(message[<span class="number">0</span>]);</span><br><span class="line">            executeMessage.setErrorMessage(errorMessage[<span class="number">0</span>]);</span><br><span class="line">            executeMessage.setTime(time);</span><br><span class="line">            executeMessage.setMemory(maxMemory[<span class="number">0</span>]);</span><br><span class="line">            executeMessageList.add(executeMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executeMessageList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中国大学生服务外包创新创业大赛赛题分析</title>
    <url>/2024/01/08/%E8%B5%9B%E9%A2%98/</url>
    <content><![CDATA[<h2 id="a01-基于文心大模型的智能阅卷平台设计与开发">【A01】
基于文心大模型的智能阅卷平台设计与开发</h2>
<h3 id="技术栈">技术栈</h3>
<ul>
<li>算法部分：PaddleOCR+NLP+文心大模型</li>
<li>后端部分：SpringBoot+Mybatis-Plus+Mysql+Redis+SpringSecurity</li>
<li>前端部分：Nginx+Vue</li>
<li>其他：Git</li>
</ul>
<h3 id="问题及解决方案">问题及解决方案</h3>
<h4 id="评阅效率与成本">评阅效率与成本</h4>
<p><strong>问题描述：</strong>传统评阅面临评阅速度较慢、人力需求大的问题，特别是在<strong>大量试卷</strong>需要评阅时，<strong>评阅及反馈时效性</strong>能否被满足，将是一个巨大的挑战；</p>
<p><strong>关键点：</strong>大量试卷、评阅及反馈时效性</p>
<p><strong>解决方案</strong>：</p>
<ol type="1">
<li>批量评阅，选择、填空、判断题等机器评阅，计算题、简答题等主观题需人工阅卷。主观题可尝试利用自然语言处理（NLP）技术，<em>让机器能够更准确地理解和评价学生的文字表达，将题干和答案输入给<strong>文心大模型</strong></em>，由大模型给阅卷老师提出建议辅助阅卷。</li>
<li>分配任务，将试卷任务划分为多个子任务，由多个评阅者同时处理，以提高评阅速度；将试卷任务分配给多个评阅者，多个评阅者负责不同数量的试卷。</li>
<li>实时反馈，设计评阅者和学生两个角色，让评阅者或学生能够迅速获取评阅结果并及时进行反馈，如老师评阅完后生成时间等数据、试卷评阅完后发送信息给学生，除分数外还可以包括评语和建议。学生端可以设计往期的数据统计、教师端可以设计往期评阅趋势等。</li>
</ol>
<h4 id="有阅无评">有阅无评</h4>
<p><strong>问题描述：</strong>在实际评阅场景中。往往需要更具有<strong>针对性和个性化的评价和建议</strong>，而不仅仅是分数反馈。在这过程中，评阅者需要将关键概念，<strong>结合学生自身特点进行充分关联</strong>，提供更贴近学生需求的知识延展和学科建议；</p>
<p><strong>关键点：</strong>针对性和个性化的评价和建议、关联学生特点、提供知识延展和学科建议</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>反馈设计，评阅者可以输入关键概念给文心大模型，基于文心大模型给出专业评价和建议，或者评阅者自行写出评价和建议。学生端收到反馈后，可以使用文心大模型提取反馈中的知识，并给出学习建议。</li>
<li><em>增加多样性，包括提供更多的学科相关资源链接、在线学习平台等。这可以帮助学生更全面地理解和拓展相关知识。</em></li>
</ol>
<h4 id="学情信息跟踪实际">学情信息跟踪实际</h4>
<p><strong>问题描述：</strong>评阅者在实际操作中难以<strong>全面、数字化地记录学生的评价和进步情况</strong>，进而影响评估的针对性和指导性作用；</p>
<p><strong>关键点：</strong>全面、数字化记录学生的评价和进步情况</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>学情数据可视化，评阅者可以看到该学生历届考试的试卷、评阅建议或成绩趋势图等。</li>
</ol>
<h4 id="实际评阅风格的单一">实际评阅风格的单一</h4>
<p><strong>问题描述：</strong>在实际评阅过程中，评语描述表达方式相对统一，难以通过<strong>多样化的评语风格</strong>来更好地引导学生理解知识点和提高学业水平；</p>
<p><strong>关键点：</strong>多样化的评语风格</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>通用评语库，
构建一个通用的评语库，包含常见的评价和建议，评阅者可以从中选择或修改，以提高评价的一致性和效率。还可以提供评阅者多样化的评语模板，包括鼓励性的、建议性的、肯定的、挑战性的等不同类型。评阅者可以根据学生的表现灵活选择合适的模板，使评语更富有变化。</li>
</ol>
<h4 id="学科限制与切换">学科限制与切换</h4>
<p><strong>问题描述：</strong>由于不同学科具有独特的评价标准和要求，传统评阅工具难以在不同学科间切换，需要更多的学科专业性和差异化的评阅方式。</p>
<p><strong>关键点：</strong>更多的学科专业性和差异化的评阅方式</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>学科试卷分配给对应的学科老师</li>
<li>学科专业化的大模型支持，
集成不同学科领域的专业化大模型，使其能够理解和应用特定学科的术语、概念和评价标准。这有助于提高评阅的准确性和专业性？？？</li>
</ol>
<h3 id="任务清单">任务清单</h3>
<p>（1）试卷图像快速采集与存储；</p>
<p>（2）字符识别与提取；</p>
<p>（3）内容理解与评阅内容生成；</p>
<p>（4）评阅内容的二次编辑；</p>
<p>（5）评阅结果的可视化、整理与导出；</p>
<p>（6）学情数据可视化；</p>
<p>（7）跨平台支持；</p>
<p>（8）实时采集与分析（可选）；</p>
<p>（9）其它拓展功能和创新方向，如软硬一体解决方案。</p>
<h3 id="功能模块">功能模块</h3>
<ul>
<li>试卷导入模块</li>
<li>评阅分配模块</li>
<li>智能评阅模块</li>
<li>学情分析模块</li>
<li>个人信息模块</li>
</ul>
<h2 id="a15基于知识图谱的大学生就业能力评价和职位推荐系统">【A15】基于知识图谱的大学生就业能力评价和职位推荐系统</h2>
<h3 id="技术栈-1">技术栈</h3>
<ul>
<li>算法部分：知识图谱、NLP、推荐和预测模型、文心大模型</li>
<li>后端部分：SpringBoot+Mybatis-Plus+Mysql+Redis+SpringSecurity</li>
<li>前端部分：Nginx+Vue</li>
<li>其他：Git</li>
</ul>
<h3 id="参考网站">参考网站</h3>
<blockquote>
<p>老鱼简历：https://www.laoyujianli.com/</p>
<p>牛客：https://www.nowcoder.com/</p>
</blockquote>
<h3 id="数据集">数据集</h3>
<blockquote>
<p>链接：https://pan.baidu.com/s/1BsrKlVRbWe6i9DTUcOcGtg?pwd=vmeh
提取码：vmeh</p>
</blockquote>
<h3 id="技术要求与指标">技术要求与指标</h3>
<ul>
<li><p>推荐有效性达到80%
以上（用户调查：电子或计算机类相关专业毕业生简历与岗位样例库进行匹配）；</p></li>
<li><p>系统数据库中个人隐私信息（姓名、手机、邮箱、通讯地址等至少4项）进行加密，只能被授权人员解密；</p></li>
<li><p>架构设计上可并发支持1000人以上同时在线使用，推荐响应时间在5s以内；</p></li>
<li><p>技术不限，开发工具不限，可采用开源技术。</p></li>
</ul>
<h3 id="业务背景">业务背景</h3>
<h4 id="知识图谱构建">知识图谱构建</h4>
<p>职位推荐系统需要构建一个包含相关职位、技能要求、行业信息等多个领域知识的知识图谱。</p>
<h4 id="聚合和分析用户信息">聚合和分析用户信息</h4>
<p>与知识库相结合，对用户的个人简历、求职意向、工作经验等信息进行聚合和分析处理。根据用户提供的信息学习用户的兴趣和特征，并利用这些特征在知识图谱上匹配职位需求和其他相关信息。</p>
<h4 id="建立推荐模型">建立推荐模型</h4>
<p>根据用户信息设计推荐算法和预测模型。通常来说，推荐算法有协同过滤、关键因素模型、深度学习模型等，具体选择应该根据实际情况来确定。</p>
<h4 id="推荐结果展示">推荐结果展示</h4>
<p>将推荐结果呈现给用户，并支持用户进行选择和反馈。需要注意的是推荐结果的呈现方式也应该根据不同用户群体的需求和喜好来定制化。</p>
<h3 id="问题及解决方案-1">问题及解决方案</h3>
<p>实现一套大学生就业能力评价和智能岗位推荐系统，根据提供的岗位信息样例库，设计一套含智能算法的软件系统方案：基于知识图谱的岗位信息，利用职位和用户信息，结合推荐算法和相关技术，为用户提供符合其需求和兴趣的职位推荐结果和能力评价结果。</p>
<h4 id="能力评价">能力评价</h4>
<p><strong>问题描述：</strong>用户上传个人简历，并明确自己期望的职位，系统自动<strong>判断用户与期望职位间的契合度</strong>，差异性，给出提升建议，让其知晓对于意向岗位自身知识和技能上的缺陷，找到短板，有针对性提升自我能力。</p>
<p><strong>关键点：</strong>判断用户与期望职位间的契合度、给出提升建议</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>信息提取，利用自然语言处理（NLP）技术提取用户简历和期望职位中的关键词和技能。设计算法计算技能匹配度分数，考虑关键技能的重要性和权重。</li>
<li>构建知识图谱，基于构建的知识图谱，将用户的技能与职位要求进行匹配。利用图谱中的关系和节点信息，评估用户对于职位所需知识的覆盖程度。</li>
<li>差异性分析，分析用户的简历和期望职位之间的差异，包括技能、工作经验、项目经历等方面。</li>
<li>提升建议生成，基于差异性分析和匹配度评估，生成个性化的提升建议。针对用户的短板提供培训建议、学习资源链接、实践项目建议等，以提高其在期望职位上的竞争力。</li>
<li>用户反馈机制，提供用户反馈功能，让用户对系统的匹配度评估和提升建议进行确认。</li>
</ol>
<h4 id="岗位推荐">岗位推荐</h4>
<p><strong>问题描述：</strong>用户上传个人简历，系统自动分析简历内容，生成推荐职位，用户可以给出推荐是否有效的反馈。如果不满意，可修订简历部分内容，重新进行推荐。</p>
<p><strong>关键点：</strong>推荐职位</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>简历内容分析，利用自然语言处理（NLP）技术对用户上传的简历进行内容分析。</li>
<li>用户兴趣，基于用户上传的历史简历数据，建立用户的兴趣和偏好模型。考虑用户之前的工作经验、求职意向、职业发展方向等信息。</li>
<li>职位推荐算法设计，选择合适的推荐算法，如协同过滤、基于内容的推荐、深度学习模型等。结合用户的兴趣模型和简历特征向量，计算与不同职位的匹配度。</li>
<li>修订简历，如果用户不满意推荐结果，系统应提供修订简历的功能。用户可以编辑、添加或删除简历中的信息，系统重新分析并生成更新后的推荐职位。</li>
<li>用户历史记录查看，用户可以查看自己历史上传的简历和推荐结果，了解职业发展轨迹。</li>
</ol>
<h4 id="招聘推荐">招聘推荐</h4>
<p><strong>问题描述：</strong>企业招聘人员输入或上传职位要求，系统自动分析匹配求职人员简历，筛选出符合期望的人员列表。</p>
<p><strong>关键点：</strong>招聘推荐</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>职位要求解析，利用自然语言处理技术，对企业输入或上传的职位要求进行解析。提取关键技能、经验要求、学历等信息，构建职位要求的特征向量。</li>
<li>求职人员匹配度计算，基于已有的用户简历数据，计算每个求职人员与职位要求的匹配度。利用算法综合考虑关键技能匹配、工作经验匹配等因素。</li>
<li>候选人员筛选，根据匹配度计算结果，筛选出符合职位要求的候选人员列表。设置合适的匹配度阈值，确保选出的人员满足企业的期望。可以设计系统推荐排名，推荐排名靠前的人员供企业参考。考虑推荐结果的多样性，确保涵盖不同技能和经验背景的候选人。</li>
<li>候选人员详细信息展示，提供候选人员的详细信息，包括简历、技能、工作经历等。支持企业预览候选人员的综合素质，以便更好地做出招聘决策。</li>
</ol>
<h3 id="用户期望">用户期望</h3>
<p>对开发的产品方案期望如下：</p>
<p>（1）算法优化合理，求职与招聘推荐结果与用户期望一致性高；</p>
<p>（2）胜任度能力评价结果合理，给出的提升建议符合用户短板；</p>
<p>（3）保护简历中个人数据的安全，不侵犯用户隐私；</p>
<p>（4）扩展功能：可以对注册用户的数据和操作行为进行统计分析，给出热门职位、热门技能、热门专业等的一些趋势图等。</p>
<h3 id="功能模块-1">功能模块</h3>
<ul>
<li>简历上传模块</li>
<li>能力评价模块</li>
<li>岗位推荐模块</li>
<li>招聘推荐模块</li>
<li>热门推荐模块</li>
<li>个人信息模块</li>
</ul>
<h2 id="队伍分配">队伍分配</h2>
<blockquote>
<p>A01：周锦辉+罗骏岚+李鑫+杨康庆+禹乐</p>
</blockquote>
<blockquote>
<p>A15：李翔+李慧聪+周亚+朱豪尔+郑国盛</p>
</blockquote>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>赛题分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【消息队列】RabbitMQ基本概念</title>
    <url>/2024/06/30/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91RabbitMQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="rabbitmq的架构">1.RabbitMQ的架构</h2>
<p><strong>Producer(生产者)：</strong>生产者是消息的发送方，负责将消息发布到RabbitMQ的交换器
(Exchange)。</p>
<p><strong>Consumer(消费者)：</strong>消费者是消息的接收方，负责从队列中获取消息，并进行处理和消费。</p>
<p><strong>Exchange(交换器)：</strong>交换器是消息的接收和路由中心，它接收来自生产者的消息，并将消息路由到一个或多个与之绑定的队列(Queue)中。</p>
<p><strong>Queue(队列)：</strong>队列是消息的存储和消费地，它保存着未被消费的消息，等待消费者(Consumer)
从队列中获取并处理消息。</p>
<p><strong>Binding(绑定)：</strong>绑定是交换器和队列之间的关联关系，它定义了交换器将消息路由到哪些队列中。</p>
<p><strong>VHost(虚拟主机)：</strong>它类似于操作系统中的命名空间，用于将RabbitMQ的资源<strong>进行隔离和分组</strong>。每个VHost拥有自己的交换器、队列、绑定和权限设置，不同VHost之间的资源相互独立，互不干扰。VHost可以用于将不同的应用或服务进行隔离，以防止彼此之间的消息冲突和资源竞争。</p>
<h2 id="rabbitmq的工作模式">2.RabbitMQ的工作模式</h2>
<ol type="1">
<li><strong>简单模式（Simple
Mode）</strong>：在这种模式下，有一个生产者和一个消费者。生产者发送消息，消费者接收并处理这些消息。这种模式是最简单的RabbitMQ使用方式。</li>
<li><strong>Work模式（Work
Queues）</strong>：在这种模式下，有一个生产者和多个消费者。生产者发送消息到队列中，消费者从队列中取出消息进行处理。RabbitMQ通过轮询的方式将消息平均发送给消费者，确保一条消息只被一个消费者接收和处理。</li>
<li><strong>发布/订阅模式（Publish/Subscribe）</strong>：在这种模式下，生产者发送消息到交换机，交换机将消息广播到所有与之绑定的队列中，然后消费者从队列中取出消息进行消费。这种模式允许消费者有选择性地接收消息。</li>
<li><strong>路由模式（Routing）</strong>：路由模式与发布/订阅模式类似，但是生产者发送消息时需要指定一个路由键（routing
key），交换机根据路由键将消息发送到匹配的队列中。消费者需要将其队列绑定到交换机，并指定路由键以便接收消息。</li>
<li><strong>Topic模式</strong>：这种模式是路由模式的扩展，它使用更灵活的匹配规则。生产者发送消息时指定一个路由键，消费者可以将其队列绑定到交换机上，并指定一个模式（topic），该模式可以包含通配符，用于匹配路由键。这样，消费者可以接收符合特定模式的所有消息。</li>
<li><strong>RPC模式</strong>：支持生产者和消费者不在同一个系统中，即允许远程调用的情况。通常，消费者作为服务端，放置在远程的系统中，提供接口，生产者调用接口，并发送消息。</li>
</ol>
<h2 id="rabbitmq的作用">3.RabbitMQ的作用</h2>
<ol type="1">
<li><strong>应用解耦</strong>：在生产者和消费者之间建立了一个缓冲区，使得两者之间的处理速度可以异步进行，不需要严格匹配。这大大增加了系统的灵活性和可扩展性。</li>
<li><strong>削峰填谷</strong>：在高并发场景下，大量请求可能瞬间涌入系统，导致系统压力过大。RabbitMQ可以作为一个缓冲存储，将一部分请求暂时存入队列中，起到“削峰”的作用，保证系统平稳运行，在高峰期过去后，继续从队列中取出消息进行处理，直到积压的消息被完全消费。</li>
<li><strong>异步通信</strong>：RabbitMQ支持异步通信，生产者将消息发送到队列后，不必等待消费者处理完消息再返回结果，而是可以继续执行其他任务。这大大提高了系统的并发处理能力和响应速度。</li>
<li><strong>流量整形</strong>：RabbitMQ可以对消息进行优先级排序、延迟处理等，使得消息的处理更加有序和高效。</li>
</ol>
<h2 id="如何处理rabbitmq的消息积压问题">4.如何处理RabbitMQ的消息积压问题？</h2>
<ol type="1">
<li><strong>增加消费者数量</strong>：当消息队列中的消息数量超出当前消费者的处理能力时，可以动态地增加消费者的数量。这样，更多的消费者可以并行地处理消息，从而加快消息的消费速度。</li>
<li><strong>提高消费者的处理能力</strong>：优化消费者的代码逻辑，提升消费者的性能，例如通过<strong>多线程</strong>或其他并行处理技术，可以提高单个消费者的处理速度。</li>
<li><strong>设置消息的过期时间</strong>：为了避免消息无限期地积压在队列中，可以为消息设置一个合理的过期时间。当消息在队列中等待时间过长且未被消费时，RabbitMQ可以自动将其丢弃或进行其他处理。</li>
</ol>
<h2 id="rabbitmq的死信队列">5.RabbitMQ的死信队列</h2>
<h3 id="死信队列介绍">死信队列介绍</h3>
<p>RabbitMQ的死信队列(Dead Letter
Queue，简称DLQ)是一种用于处理<strong>消息处理失败</strong>或<strong>无法路由的消息</strong>的机制。它允许将无法被正常消费的消息重新路由到另一个队列，以便稍后进行进一步的处理、分析或排查问题。</p>
<p>当消息队列里面的消息出现以下几种情况时，就可能会被称为”死信”:</p>
<ol type="1">
<li><strong>消息处理失败：</strong>当消费者由于代码错误、消息格式不正确、业务规则冲突等原因无法成功处理一条消息时，这条消息可以被标记为死信。</li>
<li><strong>消息过期：</strong>在RabbitMQ中，消息可以设置过期时间。如果消息在规定的时间内没有被消费，它可以被认为是死信并被发送到死信队列。</li>
<li><strong>消息被拒绝：</strong>当消费者明确拒绝一条消息时，它可以被标记为死信并发送到死信队列。拒绝消息的原因可能是消息无法处理，或者消费者认为消息不符合处理条件。</li>
<li><strong>消息无法路由：</strong>当消息不能被路由到任何队列时，例如，没有匹配的绑定关系或路由键时，消息可以被发送到死信队列。</li>
</ol>
<p>当消息变成”死信”之后，如果配置了死信队列，它将被发送到死信交换机，死信交换机将死信投递到一个队列上，这个队列就是死信队列。但是如果没有配置死信队列，那么这个消息将被丢弃。</p>
<h3 id="配置死信队列">配置死信队列</h3>
<p>在RabbitMQ中，死信队列通常与交换机(Exchange) 和队列(Queue)
之间的绑定关系一起使用。要设置死信队列，通常需要以下步骤:</p>
<ol type="1">
<li><strong>创建死信队列：</strong>定义一个用于存储死信消息的队列。</li>
<li><strong>创建死信交换机：</strong>为死信队列定义一个交换机，通常是一个direct类型的交换机。</li>
<li><strong>将队列与死信交换机绑定：</strong>将主要队列和死信交换机绑定，以便无法处理的消息能够被转发到死信队列。</li>
<li><strong>在主要队列上设置死信属性：</strong>通过设置队列的<strong><code>x-dead-letter-exchange</code></strong>和<strong><code>x-dead-letter-routing-key</code></strong>属性，来指定死信消息应该被发送到哪个交换机和路由键。</li>
</ol>
<p>当消息被标记为死信时，它将被发送到死信队列，并可以由应用程序进一步处理、审查或记录。这种机制有助于增加消息处理的可靠性和容错性，确保不丢失重要的消息，并提供了一种处理失败消息的方式。</p>
<h2 id="rabbitmq如何实现延迟队列">6.RabbitMQ如何实现延迟队列</h2>
<h3 id="死信队列">死信队列</h3>
<p>当RabbitMQ中的一条正常的消息，因为过了存活时间(TTL过期)、队列长度超限、被消费者拒绝等原因无法被
消费时，就会变成Dead Message，即<strong>死信</strong>。</p>
<blockquote>
<p><strong>实现方法</strong></p>
</blockquote>
<p>当一个消息变成死信之后，他就能被重新发送到死信队列中(其实是交换机-exchange)。基于这样的机制，就可以实现延迟消息了。那就是我们给一个消息设定TTL，但是并不消费这个消息，等他过期，过期后就会进入到死信队列，然后我们再监听死信队列的消息消费就行了。</p>
<p>而且，RabbitMQ中的这个TTL是可以设置任意时长的，这相比于RocketMQ只支持一些固定的时长而显得更加灵活一些。</p>
<blockquote>
<p><strong>死信队列实现延迟队列的缺点</strong></p>
</blockquote>
<p>但是，死信队列的实现方式存在一个问题，那就是可能造成队头阻塞，因为队列是先进先出的，而目每次只会判断队头的消息是否过期，那么，如果队头的消息时间很长，一直都不过期，那么就会阻塞整个队列，这时候即使排在他后面的消息过期了，那么也会被一直阻塞。</p>
<p>基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性可以实现高可用，以及处理大并发量。他的缺点一是可能存在消息阻塞的问题；二是方案比较复杂，不仅要依赖RabbitMQ，而且还需要声明很多队列出来，增加系统的复杂度。</p>
<h3 id="rabbitmq插件">RabbitMQ插件</h3>
<blockquote>
<p><strong>实现方法</strong></p>
</blockquote>
<p>基于插件的方式，消息并不会立即进入队列，而是先把他们保存在一个基于Erlang开发的Mnesia数据库中，然后通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message交换机中。</p>
<p>基于RabbitMQ插件的方式可以实现延迟消息，并且不存在消息阳塞的问题，但是因为是基于插件的，而这个插件
支持的最大延长时间是(232)-1
毫秒，大约49天，超过这个时就会被立即消费。</p>
<blockquote>
<p><strong>RabbitMQ插件实现延迟队列的缺点</strong></p>
</blockquote>
<p>不过这个方案也有一定的限制，它将延迟消息存在于 Mnesia
表中，并且在当前节点上具有单个磁盘副本，存在丢失的可能。</p>
<p>目前该插件的当前设计并不真正适合包合大量延迟消息(例如数十万或数百万)的场景，另外该插件的一个可变性来源是依赖于
Erlang
计时器，在系统中使用了一定数量的长时间计时器之后，它们开始争用调度程序资源，并且时间漂移不断累积。</p>
<h2 id="保证rabbitmq的消息可靠性">7.保证RabbitMQ的消息可靠性</h2>
<p>为了确保消息不丢失，可以采取以下措施：</p>
<ol type="1">
<li><strong>持久化消息：</strong>
将消息持久化到磁盘中，这样即使系统崩溃，消息也不会丢失。常见的MQ如RabbitMQ、Kafka、ActiveMQ都支持消息持久化。</li>
<li><strong>确认机制（Acknowledgment）：</strong>
发送方和接收方都需要确认消息的接收。发送方在发送消息后等待接收方的确认，接收方处理消息后需要确认已成功处理。</li>
<li><strong>重复发送：</strong>
如果在设定时间内没有收到确认，发送方可以重试发送消息。这需要消息处理具备幂等性，即多次处理同一条消息不会造成副作用。</li>
<li><strong>死信队列（Dead Letter Queue, DLQ）：</strong>
当消息无法被成功处理或无法被确认时，将其转移到死信队列中进行后续处理。</li>
<li><strong>高可用集群：</strong>
通过MQ集群来实现高可用性，防止单点故障导致消息丢失。</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】随机盐值+双重SHA256加密实战</title>
    <url>/2024/07/08/%E3%80%90SpringBoot%E3%80%91%E9%9A%8F%E6%9C%BA%E7%9B%90%E5%80%BC+%E5%8F%8C%E9%87%8DSHA256%E5%8A%A0%E5%AF%86%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="目录"><strong>目录：</strong></h3>
<p><a href="#why">1.SHA-256和随机盐值</a></p>
<p><a href="#front">2.前端实现</a></p>
<p><a href="#how">3.后端实现</a></p>
<h2 id="sha-256和salt">1.SHA-256和Salt<a id="why"></a></h2>
<h3 id="什么是sha-256">1.1.什么是SHA-256</h3>
<blockquote>
<p><strong>SHA-256</strong>是一种信息摘要算法，也是一种密码散列函数。对于任意长度的消息，SHA256都会产生一个256bit长的散列值（哈希值），用于确保信息传输完整一致，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的<strong>十六进制字符串</strong>来表示。</p>
</blockquote>
<p><strong>SHA-256的具备以下几个关键特点：</strong></p>
<ol type="1">
<li><strong>固定长度输出</strong>：无论输入数据的大小，SHA-256都会产生一个256位（32字节）的固定长度散列值。</li>
<li><strong>不可逆性</strong>：SHA-256的设计使得从生成的散列值无法还原原始输入数据。这种不可逆性在安全性上是非常重要的。</li>
<li><strong>抗碰撞性</strong>：找到两个不同的输入数据具有相同的散列值（碰撞）是极其困难的。虽然理论上碰撞可能发生，但SHA-256被设计得非常抗碰撞。</li>
</ol>
<p>除了SHA-256之外，还有一个密码散列函数<strong>MD5</strong>，过去也常被用于密码加密，但MD5在安全性上低于SHA-256，现在已经很少用于密码加密了，本文不做考虑。</p>
<p><strong>SHA-256 和 MD5 的比较：</strong></p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 53%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>SHA-256</th>
<th>MD5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输出长度</td>
<td>256 位（64 个十六进制字符）</td>
<td>128 位（32 个十六进制字符）</td>
</tr>
<tr class="even">
<td>安全性</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="odd">
<td>计算速度</td>
<td>较慢</td>
<td>快</td>
</tr>
<tr class="even">
<td>抗碰撞能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr class="odd">
<td>应用场景</td>
<td>数据完整性校验、数字签名、密码存储、区块链</td>
<td>曾用于文件校验、密码存储</td>
</tr>
<tr class="even">
<td>推荐使用</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="什么是随机盐值">1.2.什么是随机盐值</h3>
<blockquote>
<p><strong>盐值（salt）</strong>是一种在密码学和安全计算中常用的随机数据，用于增强密码散列的安全性。</p>
<p><strong>随机盐值（random
salt）</strong>是一种用于增强密码散列安全性的技术。它是一个随机生成的数据块，在将密码输入散列函数之前，将<strong>盐值与密码组合</strong>。通过引入随机盐值，可以有效地防止<strong>彩虹表攻击</strong>和相同密码<strong>散列值重复</strong>的问题。</p>
</blockquote>
<p><strong>盐值的作用：</strong></p>
<ol type="1">
<li><strong>防止彩虹表攻击</strong>：
彩虹表是一个预计算的哈希值数据库，用于快速查找常见密码的哈希值。通过在密码哈希之前加入随机盐值，即使密码相同，其最终的哈希值也会不同，从而使彩虹表无效。</li>
<li><strong>避免散列值重复</strong>：
如果两个用户使用相同的密码，在没有盐值的情况下，他们的哈希值会相同。加入盐值后，即使密码相同，生成的哈希值也会不同，这有助于防止攻击者通过观察哈希值来推测用户是否使用了相同的密码。</li>
<li><strong>增加攻击难度</strong>：
盐值增加了密码哈希的复杂性。即使攻击者获取了存储的哈希值和盐值，他们仍需对每个盐值进行单独的暴力破解，显著增加了破解的时间和计算成本。</li>
</ol>
<h2 id="如何进行加密操作">1.3.如何进行加密操作</h2>
<p>本文采用的加密方式是在前端采用md加密防止<strong>明文传输</strong>，后端对密码<strong>二次加密</strong>后再进行<strong>随机盐值</strong>的混入。</p>
<h2 id="前端实现">2.前端实现<a id="front"></a></h2>
<blockquote>
<p>引入md5.min.js</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jquery --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/jquery.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/bootstrap/css/bootstrap.min.css&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/bootstrap/js/bootstrap.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jquery-validator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-validation/jquery.validate.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-validation/localization/messages_zh.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- md5.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/md5.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- common.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/common.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">id</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:50%; margin:0 auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center; margin-bottom: 20px&quot;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-label col-md-4&quot;</span>&gt;</span>请输入手机号码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">minlength</span>=<span class="string">&quot;11&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;11&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;手机号码&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-label col-md-4&quot;</span>&gt;</span>请输入密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;reset()&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#loginForm&quot;</span>).<span class="title function_">validate</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">submitHandler</span>: <span class="keyword">function</span> (<span class="params">form</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">doLogin</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">doLogin</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inputPass = $(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> salt = <span class="string">&quot;1a2b3c4d&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> str = <span class="string">&quot;&quot;</span> + salt.<span class="title function_">charAt</span>(<span class="number">0</span>) + salt.<span class="title function_">charAt</span>(<span class="number">2</span>) + inputPass + salt.<span class="title function_">charAt</span>(<span class="number">5</span>) + salt.<span class="title function_">charAt</span>(<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> password = <span class="title function_">md5</span>(str);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login/doLogin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">mobile</span>: $(<span class="string">&quot;#mobile&quot;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">password</span>: password</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                layer.<span class="title function_">closeAll</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    layer.<span class="title function_">msg</span>(<span class="string">&quot;成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;userTicket=&quot;</span> + data.<span class="property">object</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;/goods/toList&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    layer.<span class="title function_">msg</span>(data.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                layer.<span class="title function_">closeAll</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后端实现">3.后端实现<a id="how"></a></h2>
<h3 id="导入maven依赖">3.1.导入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="密码加密">3.2.密码加密</h3>
<h4 id="密码加盐">3.2.1.密码加盐</h4>
<p>首先使用Apache的<code>RandomStringUtils</code>工具类，生成16位的盐值。然后将盐拼接到明文后面，进行SHA256加密。</p>
<p>这个加密后的SHA256是个固定64长度的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个16位的随机数，也就是盐</span></span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将盐拼接到明文后，并生成新的sha256码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> DigestUtils.sha256Hex(password + salt);</span><br></pre></td></tr></table></figure>
<h4 id="随机盐值混合">3.2.2.随机盐值混合</h4>
<p>加盐后的SHA256码长度为80位，这里我们采用的<strong>盐值混合规则：将SHA-256散列值的每四个字符中间插入一个盐值字符，依次交替排列。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将盐混到新生成的SHA-256码中，之所以这样做是为了后期解密，校验密码</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>); <span class="comment">// SHA-256是64个字符，加16个字符的盐，总共80个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span>));</span><br><span class="line">    sb.append(salt.charAt(i));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">2</span>));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>这样就完成了加密的操作：<strong>密码加盐 + 盐值混合</strong>。</p>
<h3 id="密码解密">3.3.密码解密</h3>
<h4 id="提取盐值和加盐密码">3.3.1.提取盐值和加盐密码</h4>
<p>按照加密时采用的规则：<strong>将SHA-256散列值的每四个字符中间插入一个盐值字符，依次交替排列。</strong></p>
<p>我们可以将盐值和加盐后的SHA-256码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取盐值和加盐后的SHA-256码</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">64</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">2</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">4</span>));</span><br><span class="line">    sb2.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> sb1.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> sb2.toString();</span><br></pre></td></tr></table></figure>
<h4 id="比较密码">3.3.2.比较密码</h4>
<p>最后，将取出的盐值与原始密码再次加盐，再次得到加盐密码，与sha256Hex比较即可判断密码是否相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较二者是否相同</span></span><br><span class="line"><span class="keyword">return</span>  DigestUtils.sha256Hex(password + salt).equals(sha256Hex);</span><br></pre></td></tr></table></figure>
<h3 id="完整工具类">3.4.完整工具类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SHA256Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * 生成盐和加盐后的SHA-256码，并将盐混入到SHA-256码中,对SHA-256密码进行加强</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个16位的随机数，也就是盐</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将盐拼接到明文后，并生成新的sha256码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> DigestUtils.sha256Hex(password + salt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将盐混到新生成的SHA-256码中，之所以这样做是为了后期解密，校验密码</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>); <span class="comment">// SHA-256是64个字符，加16个字符的盐，总共80个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span>));</span><br><span class="line">            sb.append(salt.charAt(i));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">2</span>));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * 从混入盐的SHA-256码中提取盐值和加盐后的SHA-256码</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verifyPassword</span><span class="params">(String password, String encrypted)</span> &#123;</span><br><span class="line">        <span class="comment">// 提取盐值和加盐后的SHA-256码</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">64</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">2</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">4</span>));</span><br><span class="line">            sb2.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> sb1.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较二者是否相同</span></span><br><span class="line">        <span class="keyword">return</span>  DigestUtils.sha256Hex(password + salt).equals(sha256Hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>密码加密</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringSecurity】认证授权全流程实战</title>
    <url>/2024/01/18/%E3%80%90SpringSecurity%E3%80%91%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>Spring
Security是一个强大且灵活的身份验证和访问控制框架，用于Java应用程序。它是基于Spring框架的一个子项目，旨在为应用程序提供安全性。</p>
<p>Spring
Security致力于为Java应用程序提供<strong>认证</strong>和<strong>授权</strong>功能。开发者可以轻松地为应用程序添加强大的安全性，以满足各种复杂的安全需求。</p>
<h2 id="springsecurity完整流程">SpringSecurity完整流程</h2>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401181741086.png"></p>
<p><strong>JwtAuthenticationTokenFilter：</strong>这里是我们自己定义的过滤器，主要负责放行不携带token的请求（如注册或登录请求），并对携带token的请求设置授权信息</p>
<p><strong>UsernamePasswordAuthenticationFilter：</strong>负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要由它负责</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<h2 id="一般认证工作流程">一般认证工作流程</h2>
<blockquote>
<p><strong>Authentication接口：</strong>它的实现类表示当前访问系统的用户，封装了用户相关信息。</p>
<p><strong>AuthenticationManager接口：</strong>定义了认证Authentication的方法</p>
<p><strong>UserDetailsService接口：</strong>加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p><strong>UserDetails接口：</strong>提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401181713332.png"></p>
<h2 id="数据库">数据库</h2>
<p>数据库的采用<strong>RBAC权限模型（基于角色的权限控制）</strong>进行设计。</p>
<p>RBAC至少需要三张表：用户表–角色表–权限表（多对多的关系比较合理）</p>
<ul>
<li>用户表（user）：存储用户名、密码等基础信息，进行登录校验</li>
<li>角色表（role）：对用户的角色进行分配</li>
<li>权限表（menu）：存储使用不同功能所需的权限</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182039664.png"></p>
<h2 id="注册流程">注册流程</h2>
<h3 id="配置匿名访问">配置匿名访问</h3>
<p>在配置类中允许注册请求可以匿名访问</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182109765.png"></p>
<h3 id="编写实现类">编写实现类</h3>
<p>registerDTO中存在字符串roleId和实体类user，先取出user判断是否存在相同手机号。若该手机号没有注册过用户，对密码进行加密后即可将用户存入数据库。</p>
<p>创建register方法映射，保存用户的同时也要将roleId一并存入关系表中，使用户获得对应角色。如下图。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182203732.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取Map中的数据</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> registerDTO.getUser();</span><br><span class="line">       <span class="type">String</span> <span class="variable">roleId</span> <span class="operator">=</span> registerDTO.getRoleId();</span><br><span class="line">       <span class="comment">// 判断是否存在相同手机号</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">dataUser</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">               .eq(User::getUserPhone, user.getUserPhone()).one();</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(dataUser)) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;该手机号已注册过用户，请勿重复注册&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 密码加密</span></span><br><span class="line">       user.setUserPassword(passwordEncoder</span><br><span class="line">               .encode(user.getUserPassword()));</span><br><span class="line">       <span class="comment">// 将用户及对应角色存入数据库</span></span><br><span class="line">       save(user);</span><br><span class="line">       userMapper.register(user.getUserPhone(), roleId);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Result.ok(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="登录流程">登录流程</h2>
<h3 id="配置匿名访问-1">配置匿名访问</h3>
<p>在配置类中允许登录请求可以匿名访问</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182109765.png"></p>
<h3 id="调用userdetailsserviceimpl">调用UserDetailsServiceImpl</h3>
<p>登录流程一般对应<code>认证工作流程</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       <span class="comment">//AuthenticationManager 进行用户认证，校验手机号和密码是否正确</span></span><br><span class="line">       <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserPhone(), user.getUserPassword());</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">       <span class="comment">//认证失败给出提示</span></span><br><span class="line">       <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//认证通过，生成jwt并返回</span></span><br><span class="line">       <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">       <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JwtUtil.createToken(userId);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       stringRedisTemplate.opsForValue()</span><br><span class="line">               .set(LOGIN_CODE_KEY + userId, JSONUtil.toJsonStr(loginUser));</span><br><span class="line">       map.put(<span class="string">&quot;token&quot;</span>, jwtToken);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Result.ok(map);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>先看这段代码：<code>UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserPhone(), user.getUserPassword());</code>这里先用用户手机号和密码生成UsernamePasswordAuthenticationToken</p>
<p>再看这段代码：<code>Authentication authenticate = authenticationManager.authenticate(authenticationToken);</code>利用authenticate<strong>调用自定义实现类UserDetailsServiceImpl</strong>，根据用户名判断用户是否存在（对应认证流程的1、2、3、4）</p>
<h3 id="实现userdetailsserviceimpl">实现UserDetailsServiceImpl</h3>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182207049.png"></p>
<p>由于试下的是UserDetailsService接口，所以必须实现其方法loadUserByUsername（根据用户名查询数据库是否存在）这里我传入的是手机号。数据库中若存在用户，则返回UserDetails对象（这里的权限信息暂且不看，对应认证流程的5、5.1、5.2、6）</p>
<p>UserDetails对象返回后，authenticate方法会默认通过PasswordEncoder比对UserDetails与Authentication的密码是否相同。因为UserDetails是通过自定义实现类<strong>从数据库中查询出的user对象</strong>，而Authentication相当于是<strong>用户输入的用户名和密码</strong>，也就可以理解为通过前面自定义实现类利用用户名查询到用户后，再看这个用户的密码是否正确。如果用户名或密码不正确，authenticate将会为空，则抛出异常信息。（对应认证流程的7）</p>
<p>由于这里的登录流程不涉及8，9，10，所以不再叙述。</p>
<p>在剩下的代码中我们利用用userId生成了jwt的令牌token，将其存入Redis中并返回token给前端。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182230778.png"></p>
<h2 id="登出流程">登出流程</h2>
<h3 id="编写过滤器">编写过滤器</h3>
<p>除login、register请求外的所有请求都需要携带token才能访问，因此需要设计token拦截器代码，如下。</p>
<p>对于不携带token的请求（如登录/注册）直接放行；对于携带token的请求先判断该用户是否登录，即redis中是否存在相关信息，若存在，将用户授权信息存入SecurityContextHolder，方便用户授权，最后直接放行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">// 没有token，放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = JwtUtil.parseJwt(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;token非法：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue().get(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> JSONUtil.toBean(userJson, LoginUser.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还需将token拦截器设置在过滤器UsernamePasswordAuthenticationFilter的前面。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401192329419.png"></p>
<h3 id="编写实现类-1">编写实现类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取SecurityContextHolder中的用户id</span></span><br><span class="line">       <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">               (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">       <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">       <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 删除redis中的值</span></span><br><span class="line">       stringRedisTemplate</span><br><span class="line">               .delete(LOGIN_CODE_KEY + userId);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>获取SecurityContextHolder中的用户id后，删除redis中存储的值，即登出成功。</p>
<h2 id="授权流程">授权流程</h2>
<p>确保实现类正确编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorities != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把permissions中String类型的权限信息封装成SimpleGrantedAuthority对象</span></span><br><span class="line">        authorities = permissions.stream()</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在token拦截器中，我们添加了这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure>
<p>这样非登录/注册请求都会被设置授权信息。</p>
<p>为对应接口添加注解@PreAuthorize，就会检验该请求是否存在相关请求。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401192332398.png"></p>
<h2 id="完整代码">完整代码</h2>
<h3 id="config类">config类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandlerImpl accessDeniedHandler;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointImpl authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化PasswordEncoder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/user/register&quot;</span>).anonymous()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">        <span class="comment">// 添加过滤器</span></span><br><span class="line">        http</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 配置异常处理器</span></span><br><span class="line">        http</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">        <span class="comment">// 允许跨域</span></span><br><span class="line">        http.cors();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration authenticationConfiguration)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置身份验证管理器</span></span><br><span class="line">        <span class="keyword">return</span> authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller类">controller类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.logout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.register(registerDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dto类">dto类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> String roleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023年6月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 封装结果后返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SUCCESS_CODE</span> <span class="operator">=</span> <span class="number">200</span>;     <span class="comment">// 访问成功状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">TOKEN_ERROR</span> <span class="operator">=</span> <span class="number">400</span>;      <span class="comment">// Token错误状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ERROR_CODE</span> <span class="operator">=</span> <span class="number">500</span>;       <span class="comment">// 访问失败状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;                               <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg;                                 <span class="comment">// 提示消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer status, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Integer status,String msg,Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(status,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(String msg,Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,<span class="string">&quot;操作成功&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,<span class="string">&quot;操作成功&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(Integer status,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(status,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ERROR_CODE,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ERROR_CODE,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title function_">ok</span><span class="params">(Map&lt;String,Object&gt; map)</span>&#123;</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,SUCCESS_CODE);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title function_">ok</span><span class="params">(PageInfo pageInfo)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,SUCCESS_CODE);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;count&quot;</span>,pageInfo.getTotal());</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>,pageInfo.getList());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="entity类">entity类</h3>
<p>UserDetails的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorities != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把permissions中String类型的权限信息封装成SimpleGrantedAuthority对象</span></span><br><span class="line">        authorities = permissions.stream()</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;grd_menu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String menuId;</span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line">    <span class="keyword">private</span> String menuPerms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;grd_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userSex;</span><br><span class="line">    <span class="keyword">private</span> String userPhone;</span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line">    <span class="keyword">private</span> String userSchool;</span><br><span class="line">    <span class="keyword">private</span> Byte[] userImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter类">filter类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">// 没有token，放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = JwtUtil.parseJwt(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;token非法：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue().get(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> JSONUtil.toBean(userJson, LoginUser.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handler类">handler类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;您的权限不足&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(result);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        WebUtils.renderString(response, json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;用户认证失败&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(result);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        WebUtils.renderString(response, json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service实现类">service实现类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;  <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String userPhone)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;user_phone&quot;</span>, userPhone);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(wrapper);</span><br><span class="line">        <span class="comment">//若数据库中不存在用户</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该手机号未注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        List&lt;String&gt; list = menuMapper.selectPermsByUserPhone(user.getUserPhone());</span><br><span class="line">        <span class="comment">// 封装成UserDetails对象返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//AuthenticationManager 进行用户认证，校验手机号和密码是否正确</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserPhone(), user.getUserPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="comment">//认证失败给出提示</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//认证通过，生成jwt并返回</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JwtUtil.createToken(userId);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue()</span><br><span class="line">                .set(LOGIN_CODE_KEY + userId, JSONUtil.toJsonStr(loginUser));</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>, jwtToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取SecurityContextHolder中的用户id</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除redis中的值</span></span><br><span class="line">        stringRedisTemplate</span><br><span class="line">                .delete(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Map中的数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> registerDTO.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">roleId</span> <span class="operator">=</span> registerDTO.getRoleId();</span><br><span class="line">        <span class="comment">// 判断是否存在相同手机号</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">dataUser</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">                .eq(User::getUserPhone, user.getUserPhone()).one();</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(dataUser)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;该手机号已注册过用户，请勿重复注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 密码加密</span></span><br><span class="line">        user.setUserPassword(passwordEncoder</span><br><span class="line">                .encode(user.getUserPassword()));</span><br><span class="line">        <span class="comment">// 将用户及对应角色存入数据库</span></span><br><span class="line">        save(user);</span><br><span class="line">        userMapper.register(user.getUserPhone(), roleId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="utils类">utils类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">// token失效：24小时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;token&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIPE</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_SECRET</span> <span class="operator">=</span> <span class="string">&quot;modox@ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的用户Id生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT规则生成的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">                .setSubject(<span class="string">&quot;grd_user&quot;</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIPE))</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, APP_SECRET)</span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token是否有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果token有效返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(jwtToken))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据token获取User信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析token获得的user对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseJwt</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line">        <span class="comment">//验证token</span></span><br><span class="line">        <span class="keyword">if</span> (checkToken(jwtToken)) &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken).getBody();</span><br><span class="line">            <span class="keyword">return</span> claims.get(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;超时或不合法token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:code:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_CODE_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:token:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_USER_TTL</span> <span class="operator">=</span> <span class="number">36000L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>身份校验</tag>
      </tags>
  </entry>
  <entry>
    <title>【RabbitMQ】一文详解消息可靠性</title>
    <url>/2024/07/13/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    <content><![CDATA[<h2 id="前言">1.前言<a id="front"></a></h2>
<p>RabbitMQ
是一款高性能、高可靠性的消息中间件，广泛应用于分布式系统中。它允许系统中的各个模块进行异步通信，提供了高度的灵活性和可伸缩性。然而，这种通信模式也带来了一些挑战，其中最重要的之一是<strong>确保消息的可靠性</strong>。</p>
<p>影响消息可靠性的因素主要有以下几点：</p>
<ul>
<li>发送消息时连接RabbitMQ失败</li>
<li>发送时丢失：
<ul>
<li>生产者发送的消息未送达交换机；</li>
<li>消息到达交换机后未到达队列；</li>
</ul></li>
<li>MQ 宕机，队列中的消息会丢失；</li>
<li>消费者接收到消息后未消费就宕机了。</li>
</ul>
<h2 id="生产者">2.生产者<a id="producter"></a></h2>
<h3 id="生产者重连机制">2.1.生产者重连机制</h3>
<p>生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，RabbitMQ提供的消息发送时的重连机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p>
<p><strong>在生产者yml文件添加配置开启重连机制</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure>
<p>当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。但是RabbitMQ提供的重试机制是<strong>阻塞式的重试</strong>。
如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，就需要合理配置等待时长和重试次数，或者使用<strong>异步线程</strong>来执行发送消息的代码</p>
<h3 id="生产者确认机制">2.2.生产者确认机制</h3>
<p>RabbitMQ的生产者确认机制（Publisher
Confirm）是一种确保消息从生产者发送到MQ过程中不丢失的机制。当消息发送到
RabbitMQ
后，系统会返回一个结果给消息的发送者，表明消息的处理状态。这个结果有两种可能的值：</p>
<p>返回结果有两种方式：</p>
<ul>
<li><strong>publisher-confirm(发送者确认)</strong>
<ul>
<li>消息成功投递到交换机，返回ACK。</li>
<li>消息未投递到交换机，返回NACK。（可能是由于网络波动未能连接到RabbitMQ，可利用生产者重连机制解决）</li>
</ul></li>
<li><strong>publisher-return(发送者回执)</strong>
<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK和路由失败原因。（这种问题一般是因为路由键设置错误，可以人为规避）</li>
</ul></li>
</ul>
<p>通过这种机制，生产者在发送消息后获取返回的回执结果，从而采取对应的策略，如消息重发或记录失败信息。</p>
<h2 id="数据持久化">3.数据持久化<a id="queue"></a></h2>
<h3 id="配置持久化">3.1.配置持久化</h3>
<p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题</p>
<ol type="1">
<li>RabbitMQ宕机，存在内存中的消息会丢失。</li>
<li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞。</li>
</ol>
<p>为了提升性能，默认情况下MQ的数据都是在内存存储的<strong>临时数据</strong>，重启后就会消失。RabbitMQ可以通过配置数据持久化，从而将消息保存在磁盘，包括：</p>
<ul>
<li>交换机持久化（确保RabbitMQ重启后交换机仍然存在）</li>
<li>队列持久化（确保RabbitMQ重启后队列仍然存在）</li>
<li>消息持久化（确保RabbitMQ重启后队列中的消息仍然存在）</li>
</ul>
<p>由于Spring会在创建队列时默认将交换机和队列设置为持久化，发送消息时也默认指定消息为持久化消息，因此不需要额外配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将消息指定为持久化消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;hello&quot;</span>.getBytes(standardcharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();</span><br><span class="line"><span class="comment">// 给队列发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, message);</span><br></pre></td></tr></table></figure>
<h3 id="惰性队列">3.2.惰性队列</h3>
<p>从RabbitMQ的3.6.0版本开始，就增加了<code>Lazy Queue</code>的概念，也就是<strong>惰性队列</strong>。</p>
<p><strong>在3.12版本后，所有队列都是Lazy
Queue模式，无法更改。</strong></p>
<p>惰性队列的特点如下：</p>
<ul>
<li><p>接收到消息后直接存入磁盘而非内存(内存中只保留最近的消息，默认2048条)</p></li>
<li><p>消费者要消费消息时才会从磁盘中读取并加载到内存</p></li>
<li><p>支持数百万条的消息存储</p></li>
</ul>
<p>对于低于3.12版本的情况，可以使用注解的arguments来指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;grade.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;intel.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;intel.grade&quot;,</span></span><br><span class="line"><span class="meta">            arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么需要数据持久化">3.3.为什么需要数据持久化？</h3>
<p>数据持久化在 RabbitMQ 中有以下重要作用：</p>
<p><strong>队列和交换机的持久化：</strong></p>
<ul>
<li><strong>防止重启后丢失</strong>：将队列和交换机设置为持久化，可以防止
RabbitMQ
服务器重启后丢失这些队列和交换机，确保它们的存在和绑定关系保持不变。</li>
</ul>
<p><strong>消息的持久化：</strong></p>
<ol type="1">
<li><strong>安全性</strong>：
<ul>
<li><strong>防止数据丢失</strong>：消息持久化后，可以防止 RabbitMQ
服务器重启或宕机时数据丢失，方便数据恢复，保证消息的可靠性和耐久性。</li>
</ul></li>
<li><strong>性能</strong>：
<ul>
<li><strong>内存管理</strong>：未持久化的临时消息默认存储在内存中。内存空间有限，大量消息涌入时会导致内存占满，系统需要进行
<code>page out</code> 操作将消息写入磁盘。频繁的 <code>page out</code>
操作会严重影响性能。</li>
<li><strong>预防内存溢出</strong>：通过持久化消息，可以缓解内存压力，防止因内存溢出导致的系统性能问题和崩溃。</li>
</ul></li>
</ol>
<h2 id="消费者">4.消费者<a id="consumer"></a></h2>
<h3 id="消费者确认机制">4.1.消费者确认机制</h3>
<p>为了确认消费者是否正确处理了消息，RabbitMQ提供了消费者确认机制。当消费者处理消息后，会返回回执信息给RabbitMQ。回执有三种值：</p>
<ul>
<li>ack：消息处理成功，RabbitMQ从队列中删除消息。</li>
<li>nack：消息处理失败，RabbitMQ需要再次投递消息。</li>
<li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除消息。</li>
</ul>
<p>在SpringBoot项目中，我们可以通过配置文件选择回执信息的处理方式，一共有三种处理方式：</p>
<ul>
<li><p><strong>none</strong>：不处理。RabbitMQ
假定消费者获取消息后会一定会成功处理，因此消息投递后立即返回<code>ack</code>，将消息从队列中删除。</p></li>
<li><p><strong>manual</strong>：手动模式。需要在业务代码结束后，调用SpringAMQP提供的API发送<code>ack</code>或<code>reject</code>，存在代码侵入问题，但比较灵活。</p></li>
<li><p><strong>auto</strong>：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑进行了环绕增强，返回结果如下：</p>
<ul>
<li><p>如果消费者正常处理消息，自动返回<code>ack</code>并删除队列的消息。</p></li>
<li><p>如果消费者消息处理失败，自动返回<code>nack</code>并重新向消费者投递消息。</p></li>
<li><p>如果消息校验异常，自动返回<code>reject</code>并删除队列中的消息。</p></li>
</ul></li>
</ul>
<blockquote>
<p><strong>注意：</strong>手动模式返回回执消息时通常需要显式指定<code>requeue</code>参数，当<code>requeue=true</code>时，表明消息需要重新入队；当<code>requeue=false</code>时，RabbitMQ将从队列删除消息。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># none，关闭ack；manual，手动ack；auto，自动 ack</span></span><br></pre></td></tr></table></figure>
<h3 id="消息失败重试机制">4.2.消息失败重试机制</h3>
<p>当消费者出现异常后，消息会<strong>不断requeue</strong>（重新入队）到队列，再重新发送给消费者，然后再次异常，再次requeue无限循环，导致mq的消息处理飙升，带来不必要的压力。</p>
<p>可以通过设置yml文件开启失败重试机制，在消息异常时利用本地重试，而不是无限制的进行requeue操作。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false 有状态。如果业务中包含事务，这里改为 false</span></span><br></pre></td></tr></table></figure>
<h3 id="消息失败处理策略">4.3.消息失败处理策略</h3>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有
MessageRecoverer 接口来处理，它包含三种不同的实现：</p>
<ul>
<li><strong>RejectAndDontRequeueRecoverer</strong>：重试次数耗尽后，直接<code>reject</code>，丢弃消息，这是默认采取的方式；</li>
<li><strong>ImmediateRequeueMessageRecoverer</strong>：重试次数耗尽后，返回<code>nack</code>，消息重新入队；</li>
<li><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机。</li>
</ul>
<h2 id="死信队列">5.死信队列<a id="deadletter"></a></h2>
<p>尽管通过以上设置可以确保消息在生产者、消息队列和消费者之间的传递过程中不会丢失，但在某些情况下，消费者仍可能无法成功处理消息（如消息重试次数耗尽后仍无法被消费）。这时候，我们需要一个机制来妥善处理这些无法被正常消费的消息。死信队列便是用于解决这一问题的兜底机制。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407122312671.svg"></p>
<h3 id="死信">5.1.死信</h3>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead
letter）：</p>
<ul>
<li><strong>消息被拒绝：</strong>
当消费者明确拒绝一个消息并且设置不再重新入队（requeue=false）时，这个消息会被标记为死信。</li>
<li><strong>消息过期：</strong>
每个消息或队列可以设置一个TTL（Time-To-Live），即消息的存活时间。如果消息在队列中停留的时间超过了这个TTL，消息会被认为过期，并被转移到死信队列。</li>
<li><strong>队列达到最大长度：</strong>
如果队列设置了最大长度并且达到了这个限制，那么新进入的消息会被转移到死信队列中。</li>
</ul>
<h3 id="创建死信队列">5.2.创建死信队列</h3>
<h4 id="创建死信交换机和死信队列">5.2.1.创建死信交换机和死信队列</h4>
<p>正常使用注解，创建交换机和队列即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dead.queue&quot;, durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                   arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dead.exchange&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;dead.key&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deadLetterQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的消息已经死亡：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绑定死信交换机">5.2.2.绑定死信交换机</h4>
<p>如果队列通过<code>dead-letter-exchange</code>属性指定了一个交换机，那么<strong>该队列中的死信就会投递到这个交换机中</strong>。这个交换机称为死信交换机（Dead
Letter Exchange，简称DLX）</p>
<p>可以通过<code>@Argument</code>注解指定死信交互机和路由键，如下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">@RabbitListener(bindings</span> <span class="string">=</span> <span class="string">@QueueBinding(</span></span><br><span class="line">            <span class="string">value</span> <span class="string">=</span> <span class="string">@Queue(name</span> <span class="string">=</span> <span class="string">&quot;simple.queue&quot;</span><span class="string">,</span> <span class="string">durable</span> <span class="string">=</span> <span class="string">&quot;true&quot;</span><span class="string">,</span></span><br><span class="line">                    <span class="string">arguments</span> <span class="string">=</span> &#123;</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;lazy&quot;</span><span class="string">)</span>,</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;dead.exchange&quot;</span><span class="string">)</span>,</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;dead.key&quot;</span><span class="string">)</span></span><br><span class="line">                    &#125;<span class="string">),</span></span><br><span class="line">            <span class="string">exchange</span> <span class="string">=</span> <span class="string">@Exchange(name</span> <span class="string">=</span> <span class="string">&quot;simple.topic&quot;</span><span class="string">,</span></span><br><span class="line">                    <span class="string">type</span> <span class="string">=</span> <span class="string">ExchangeTypes.TOPIC),</span></span><br><span class="line">            <span class="string">key</span> <span class="string">=</span> <span class="string">&quot;simple.key&quot;</span></span><br><span class="line">    <span class="string">))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息可靠性</tag>
      </tags>
  </entry>
</search>
