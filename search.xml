<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis持久化问题排查</title>
    <url>/2022/10/29/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="redis持久化问题排查">Redis持久化问题排查</h2>
<blockquote>
<p>前言：在学习黑马的Redis持久化课程时因为老师用的MobaXterm软件与我使用的VMware存在差异，同时，老师上传的视频的redis配置与我大为不同而导致了一系列的问题，在进行了一天的排查（死杠）后终于解决了问题，感慨良多。在遇到问题解决不了的时候还是要多回头看，没准在出发点就能找到问题了。
下面就将展示问题的描述和解决方案</p>
</blockquote>
<h3 id="问题描述">问题描述</h3>
<blockquote>
<p>老师在使用MobaXterm软件时使用<code>redis-server redis.conf</code>命令指定配置文件在<strong>前台</strong>启动Redis</p>
<p>然而我在使用redis-server命令却出现了下面的两种情况：</p>
</blockquote>
<p>第一种：不指定配置文件启动Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291124212.png"></p>
<p>发现监听6379端口失败</p>
<p>第二种：指定配置文件启动Redis</p>
<p>这里要先cd到自己的Redis安装路径下，然后使用命令<code>redis-server redis.conf</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291126030.png"></p>
<p>发现没有产生日志，这里使用<code>ps -ef | grep redis</code>查看后端端口占用情况</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291127803.png"></p>
<p>显然，后台端口已经被占用了，这里是因为Redis配置了开机自启动和后台启动，导致端口占用而无法使用redis-server命令</p>
<h3 id="问题解决">问题解决</h3>
<p>在执行以下操作前建议使用VMware创建一个快照，防止后续操作不当导致虚拟机设置出现问题<br></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282129924.png"></p>
<p>先使用以下命令关闭后台端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭Redis后台启动，xxx是自己设置的密码</span></span><br><span class="line">redis-cli -p 6379 -a xxxx shutdown</span><br></pre></td></tr></table></figure>
<p>此时cd到Redis的安装目录下，使用命令<code>ps -ef | grep redis</code>查看后台端口占用情况，发现后台端口关闭</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291139316.png"></p>
<p>然后在当前路径下使用<code>vi redis.conf</code>关闭Redis后台启动</p>
<p>将 daemonize 修改为 no</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291141606.png"></p>
<p>这样Redis就不会在后台启动了！</p>
<p>接着可以开心的使用<code>redis-server redis.conf</code>指定配置文件启动redis了！</p>
<p>然而，如果你使用该命令后又出现了如下情况</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291145134.png"></p>
<p>发现当前窗口确实是像前台启动一样阻塞的，但是却没有任何日志信息输出，这时我们打开RESP等图形化界面看一下连接是否成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291146893.png"></p>
<p>嗯，确实成功了，说明Redis服务确实启动了，但还是没有日志文件，那么这是怎么回事呢？</p>
<p>哈哈，不用着急，我们先使用<code>ctrl + c</code>停止当前端口，然后再回到RESP上发现连接终止，这就说明我们之前做的操作没有问题！现在我们回到终端，使用<code>vi redis.conf</code>命令进入到配置文件中</p>
<p>找到<strong>logfile</strong>，发现logfile后面的引号内为一个日志文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291150818.png"></p>
<p>这个时候一切都真相大白了，因为在一开始配置Redis时，我们将在logfile的引号内<strong>写入了一个日志文件名称</strong>（一开始的logfile内的引号默认是空的），这就导致了我们使用redis-server命令输出的日志都进入到这个日志文件中，所以启动时当然看不到任何信息了！现在我们将引号内的文件命删除，保存并退出</p>
<p>再次使用<code>redis-server redis.conf</code>命令启动Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291153693.png"></p>
<p>启动成功，大功告成！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>VMWare演示Redis持久化</title>
    <url>/2022/10/28/VMWare%E6%BC%94%E7%A4%BARedis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="vmware演示redis持久化">VMware演示Redis持久化</h2>
<h3 id="redis持久化的作用">Redis持久化的作用</h3>
<p>Redis是内存存储，如果出现服务器宕机、服务重启等情况可能会丢失数据，利用Redis持久化可以将数据写入磁盘中，这样Redis就可以利用持久化的文件进行数据恢复，数据安全性得以大大提升。<br></p>
<h3 id="rdb">RDB</h3>
<blockquote>
<p>RDB全称为Redis Database Backup
file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存重的所有数据都记录道磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
</blockquote>
<p>RDB实现数据持久化有两种命令：<code>save</code>和<code>bgsave</code></p>
<p>save命令适合用于准备将Redis停机的情况。</p>
<p>在执行save命令时会占用Redis的主进程，阻塞所有命令，因此不适用于Redis正在运行的情况。</p>
<p>而bgsave命令会执行fork操作开启一个子进程，避免主进程收到影响。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282119328.png"></p>
<p>此外，当Redis停机时会执行一次RDB操作进行数据备份。</p>
<p>下面将对该情况进行验证</p>
<h4 id="rdb演示">RDB演示</h4>
<p>使用<code>redis-server redis.conf</code>指令在任意路径下运行Redis</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291303145.png"></p>
<p>接下来创建一个新的终端创建连接，存入键值对</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301657349.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301708367.png"></p>
<p>接着回到上一个终端使用<code>ctrl + c</code>关闭Redis，可以看到<code>DB saved on disk</code>表示文件正常保存</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282139525.png"></p>
<p>在当前路径下使用ll查看所有文件，看到dump.rdb快照文件已经生成<img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282141216.png"></p>
<p>接着再次在当前终端使用<code>redis-server redis.conf</code>启动Redis，此时数据会自动恢复，回到另一个终端窗口</p>
<p>此时将使用<code>ctrl + c</code>关闭当前命令行客户端，重新使用<code>redis-cli</code>开启一个新的命令行</p>
<p>这时使用get num命令发现数据返回为789，（如果get
num返回错误<strong>Error：Server closed the
connection</strong>要将redis.conf的<strong>protected-mode</strong>设置为No关闭保护模式）表明数据备份成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301704159.png"></p>
<p><strong>Redis停机自动执行RDB证明完毕！</strong></p>
<h4 id="rdb相关配置">RDB相关配置</h4>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282152250.png"></p>
<p>这里需要 cd 到redis的安装目录下，我的安装目录在
/usr/local/src/redis-6.2.6下</p>
<p>这里老师用的MobaXterm可以直接使用第三方文件打开配置文件进行修改，因为我用的是VMware所以只能使用Linux命令进行修改配置</p>
<p>使用 <code>vi redis.conf</code>修改配置文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282159322.png"></p>
<p>这里有一些小技巧：</p>
<ul>
<li>按下INSERT键进入修改状态，此时才可以对文件进行修改</li>
<li>按下ESC键可以使用一些命令：<code>/xxx</code>可以查找跳跃到当前文件中的xxx名称，<code>:wq</code>保存当前文件并退出，<code>:q</code>不保存并退出当前文件，<code>:q!</code>不保存并强制退出当前文件</li>
</ul>
<p>下面就可以对配置文件进行修改了！</p>
<p>修改为五秒内执行一次操作就出发RDB备份</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282209053.png"></p>
<p>接着</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282211172.png"></p>
<p>再查找rdbcompression后修改为yes即可</p>
<p>使用:wq保存并退出</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282214630.png"></p>
<p>rdb文件名修改后使用终端再次运行Redis，发现此时没有DB文件录入消息，之前的dump.rdb文件已不能被读取</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291316731.png"></p>
<p>到另一个终端重新使用redis-cli开启命令行，使用get
num命令发现结果为空，再set
一个新的键值，回到Redis窗口发现出现<code>Background saving started</code>字段即表示成功！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210282221596.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210291318662.png"></p>
<h3 id="aof">AOF</h3>
<blockquote>
<p>AOF全称为Append Only File
(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
</blockquote>
<p>开启AOF需要在Redis的配置文件中修改配置，AOF记录命令的频率有三种:<code>always</code>
、<code>everysec</code>和<code>no</code></p>
<p>always配置胜在能记录每一次Redis执行的写命令，几乎不会丢失数据，但对性能会有很大的影响</p>
<p>everysec配置每隔一秒将缓冲区里的数据写入到AOF文件，避免直接对AOF文件操作而性能上有了提升，但是在数据间隔的一秒内如果出现服务宕机的情况会丢失最多一秒的数据</p>
<p>no配置执行频率最低，性能最好，但是可靠性很低，不推荐使用</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301559763.png"></p>
<h4 id="aof演示">AOF演示</h4>
<p>先使用 cd 命令进入到Redis的安装路径下</p>
<p>使用<code>vi redis.conf</code>命令修改redis配置文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301615021.png"></p>
<p>将之前的save 5 1注释掉，写入save ""，表示禁用RDB</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301617321.png"></p>
<p>将appendonly修改为yes，开启AOF</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301618239.png"></p>
<p>AOF执行频率的命令配置默认为<code>appendfsync everysec</code>，不需要修改</p>
<p>修改完毕后回到终端，使用<code>rm -rf *.rdb</code>删除之前的RDB文件</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301622298.png"></p>
<p>可以看到当前目录下rdb文件已删除</p>
<p>使用<code>redis-server redis.conf</code>命令重启Redis</p>
<p>发现日志中出现没有对RDB的读取，修改成功</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301626879.png"></p>
<p>在另一终端打开命令行，输入如下指令</p>
<p>返回空集合，说明所有数据已被清除</p>
<figure>
<img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301703747.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>set一个键值对</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301630032.png"></p>
<p>这时我们打开文件夹进入本机的Redis的安装路径下，发现AOF文件已经被创建成功，打开AOF文件，set命令已经被写入成功，说明<strong>AOF已经生效了</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301633106.png"></p>
<p>接下来验证AOF的重启恢复，先重启Redis服务，红框内的日志表示数据已经从AOF文件加载完毕</p>
<p><img src="/2022/10/28/VMWare%E6%BC%94%E7%A4%BARedis%E6%8C%81%E4%B9%85%E5%8C%96/Users\86130\AppData\Roaming\Tencent\Users\2484792357\QQ\WinTemp\RichOle\LBDM52Q%5BBMBTK%7DPKDK~HB2V.png"></p>
<p>这时候我们回到命令行使用<code>keys *</code>命令，返回num，依然有数据，说明AOF重启能保证数据的恢复，证明完毕</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301640485.png"></p>
<h3 id="rdb和aof的比较">RDB和AOF的比较</h3>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202210301647804.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware软件安装及问题解决</title>
    <url>/2022/10/08/VMware%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="vmware软件安装">VMware软件安装</h2>
<blockquote>
<p>前言：最近学习Redis时需要使用Linux系统，导致不得不去安装一个虚拟机了，在准备安装VMware软件时遇到了一些问题，这里给出记录和解决方案，以做参考学习使用</p>
</blockquote>
<h3 id="准备工作">准备工作</h3>
<blockquote>
<p>本文将在Windows系统下使用VMware软件配置Linux虚拟机，下文将会详解VMware软件的安装步骤</p>
</blockquote>
<p>VMware软件下载地址：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a><br>
Linux CentOS 7版本下载映像文件地址：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a><br></p>
<p>按图片所示下载即可</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262109879.png"></p>
<p>这里我选择的是CentOS-7.0-x86_64-DVD-2009.iso 版本</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262106973.png"></p>
<p>在下载路径下右键以管理员身份运行</p>
<p><strong>在这里要敲重点！！！如果你没有以管理员身份运行这个选项，那么就看接下来的问题解决部分，如果你有这个选项请点击<a href="#1">跳转</a>自行无视。</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262117313.png"></p>
<h3 id="问题解决">问题解决</h3>
<blockquote>
<p>按住快捷键Win+R打开运行窗口，输入“regedit”，</p>
<p>这样就打开了注册表编辑器</p>
<p>在编辑器左侧依次找到HKEY_CURRENT_USER</p>
<p>然后将RestrictToPermittedSnapins的值设置为0</p>
</blockquote>
<p>上面的方法如果输入路径后发现MMC不存在，那么下面这个方法就派上用场了！</p>
<p>按下Win +
R键打开运行，输入gpedit.msc打开组策略编辑器，这里可能你又会惊讶的发现，gpedit.msc打不开了！别着急，下面还有解决方案。当然，如果你能打开组策略编辑器的话可以点击<a href="#2">这里</a>继续往下看</p>
<p>对于无法打开组策略编辑器的情况，win + r
键打开运行后，输入notepad打开记事本，复制粘贴以下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . List.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">&quot;C:\Windows\servicing\Packages\%%i&quot;</span></span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>记事本左上角文件另存为到任意路径下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262129654.png"></p>
<p>文件名写为gpedit.cmd，保存类型选择所有文件，编码选择ANSI</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262131529.png"></p>
<p>点击保存后在你保存的路径下右键以管理员身份运行</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262132085.png"></p>
<p>等待运行结束后发现win + R键打开的gpedit.msc可以正常打开了<br></p>
<p><span id="2"></span></p>
<p>接下来进入组策略编辑器，双击计算机配置 --&gt; Windows设置 --&gt;
安全设置<br></p>
<p>双击本地策略</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262139507.png"></p>
<p>进入安全选项找到下面两项选择已启用</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262141895.png"></p>
<p><strong>大功告成！！！</strong></p>
<p><span id="1"></span></p>
<h3 id="安装vmware">安装VMware</h3>
<p>当解决上述问题后开始准备下载VM软件了，右键以管理员身份运行后等待片刻来到安装界面</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262147272.png"></p>
<p>一路下一步来到这个界面，安装路径自己选择，我选择安装在D盘下的目录里</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262148344.png"></p>
<p>勾选取消“启动时检查产品更新”</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262149952.png"></p>
<p>一路下一步，点击安装</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262151352.png"></p>
<p>点击许可证</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262153587.png"></p>
<p>这里要输入许可证密钥（这里大家自行网络上获取），然后点击输入，安装结束，注意不要误点到跳过了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202209262155195.png"></p>
<p>输入密钥确认安装后就可以使用VMware了！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】MapStruct实现优雅的数据复制</title>
    <url>/2024/05/05/%E3%80%90SpringBoot%E3%80%91MapStruct%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>做项目时你是否遇到过以下情况：</p>
<ol type="1">
<li><strong>DTO（数据传输对象）与Entity之间的转换</strong>：在Java的Web应用中，通常不会直接将数据库中的Entity实体对象返回给前端。而是会创建一个DTO对象，这个DTO对象只包含需要返回给前端的字段。此时，就需要将Entity转换为DTO。</li>
<li><strong>复杂对象的映射</strong>：当需要映射的对象包含大量的字段，或者字段之间存在复杂的依赖关系时，手动编写映射代码不仅繁琐，而且容易出错。</li>
</ol>
</blockquote>
<h2 id="为什么选择mapstruct">1.为什么选择MapStruct<a id="why"></a></h2>
<h3 id="常见的属性映射方法">1.1.常见的属性映射方法</h3>
<p>一般来说，不使用MapStruct框架进行属性映射，常有的方法以下两种：</p>
<ol type="1">
<li>Getter/Setter方法手动映射</li>
</ol>
<p>这种方法最朴素，手动编写代码将<strong>源对象</strong>的属性存入<strong>目标对象</strong>，需要注意实体类中嵌套属性的判空操作以防止空指针异常。</p>
<ol start="2" type="1">
<li>BeanUtils.copyProperties()方法进行映射</li>
</ol>
<p><code>BeanUtils</code>底层使用的是<strong>反射机制</strong>实现属性的映射。反射是一种在<strong>运行时</strong>动态获取类信息、调用方法或访问字段的机制，无法利用JVM的优化机制，因此通常比直接方法调用慢得多。</p>
<p>此外，<code>BeanUtils</code>
只能同属性映射，或者在属性相同的情况下，允许被映射的对象属性少；但当遇到被映射的属性数据类型被修改或者被映射的字段名被修改，则会导致映射失败。</p>
<h3 id="mapstruct的优势">1.2.MapStruct的优势</h3>
<blockquote>
<p>MapStruct是一个基于注解的Java代码生成器，它通过分析带有@Mapper注解的接口，在编译时自动生成实现该接口的映射器类。这个映射器类包含了用于执行对象之间映射的具体代码。</p>
</blockquote>
<p><strong>与常规方法相比，MapStruct具备的优势有：</strong></p>
<ol type="1">
<li><p><strong>简化代码</strong>。对于对象内属性较多的情况，使用MapStruct框架无须手动对每个属性进行get/set和属性判空操作。MapStruct可以通过注解和映射接口来定义映射规则，自动生成映射代码，从而大大简化了这种复杂对象的映射过程。</p></li>
<li><p><strong>性能优越</strong>。相较于反射这种映射方法，MapStruct在<strong>编译期</strong>生成映射的<strong>静态代码</strong>，可以充分利用JVM的优化机制，对于企业级的项目应用来说，这种方式能大大提高数据复制的性能。</p></li>
<li><p><strong>类型安全</strong>。由于MapStruct在编译期生成映射代码，这意味着如果源对象和目标对象的映射存在错误，那么可以在<strong>编译时</strong>就发现错误。相比之下，BeanUtils在运行时使用反射来执行属性复制，这可能会导致类型不匹配的问题在<strong>运行时</strong>才发现。</p></li>
<li><p><strong>灵活映射</strong>。MapStruct可以轻松处理嵌套对象和集合的映射。对于嵌套对象，MapStruct可以递归地应用映射规则；对于集合，MapStruct可以自动迭代集合中的每个元素并应用相应的映射规则。</p></li>
</ol>
<p>有开发者对比过两者的性能差距，如下表。这充分体现了MapStruct性能的强大。</p>
<table>
<thead>
<tr class="header">
<th>对象转换次数</th>
<th>属性个数</th>
<th>BeanUtils耗时</th>
<th>MapStruct耗时</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5千万次</td>
<td>6</td>
<td>14秒</td>
<td>1秒</td>
</tr>
<tr class="even">
<td>5千万次</td>
<td>15</td>
<td>36秒</td>
<td>1秒</td>
</tr>
<tr class="odd">
<td>5千万次</td>
<td>25</td>
<td>55秒</td>
<td>1秒</td>
</tr>
</tbody>
</table>
<h2 id="mapstruct快速入门">2.MapStruct快速入门<a id="how"></a></h2>
<p>在快速入门中，我们的任务是将dto的数据复制到实体类中。</p>
<h3 id="导入maven依赖">2.1.导入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建相关对象">2.2.创建相关对象</h3>
<p>注意，实体类要具有get/set方法，这里我使用了lombok的@Data注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String hotelCity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String hotelPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dto类我使用了@Builder注解，可以快速为对象赋初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建转换器converter">2.3.创建转换器Converter</h3>
<p>使用抽象类来定义转换器，只需中@Mapping注解中填写<code>target</code>和<code>source</code>的字段名，即可实现属性复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestConverter</span> &#123;</span><br><span class="line">    <span class="comment">//酒店详情</span></span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;hotelCity&quot;, source = &quot;city&quot;),</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">2.4.测试</h3>
<p>在SpringBoot的测试类中测试，这里我使用DTO类的@Builder注解提供的方法为dto赋初值模拟实际开发，通过调用converter的方法实现属性映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">HotelDTO</span> <span class="variable">build</span> <span class="operator">=</span> HotelDTO.builder()</span><br><span class="line">              .name(<span class="string">&quot;五星级酒店&quot;</span>)</span><br><span class="line">              .address(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">              .city(<span class="string">&quot;北京&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">      <span class="type">TestConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestConverterImpl</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> converter.dto2Hotel(build);</span><br><span class="line"></span><br><span class="line">      System.out.println(hotel);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505204126389.png"></p>
<p>最后，我们可以发现在target包的converter的相同目录下，生成了TestConverter的实现类</p>
<p>里面为我们编写好了映射的代码。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505211703891.png"></p>
<h2 id="mapstruct进阶操作">3.MapStruct进阶操作<a id="rank"></a></h2>
<p>如果仅是这种简单层级的对象映射，还不足以体现MapStruct的灵活性。下面将介绍MapStruct的进阶技巧。</p>
<h3 id="嵌套映射">3.1.嵌套映射</h3>
<p>假设我们的Hotel实体类中嵌套了另外一个实体类Master</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String hotelCity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String hotelPhone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Master master;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dto对象为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所在城市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer personAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要把<code>personName</code>和<code>personAge</code>映射到Hotel实体类的Master中，怎么做？</p>
<p>很简单，只需要在target属性中加上Hotel实体类<strong>嵌套实体类的字段名</strong>，加字符<code>.</code>，再跟上嵌套类的字段名即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelCity&quot;, source = &quot;city&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;master.personName&quot;, source = &quot;personName&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;master.personAge&quot;, source = &quot;personAge&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505210546756.png"></p>
<h3 id="集合映射">3.2.集合映射</h3>
<p>如果源对象和目标对象的集合的元素类型都是基本数据类型，直接在target和source中填写字段名即可。</p>
<p>若源对象和目标对象的集合元素类型不同，怎么做？</p>
<p>这个案例我们需要把DTO的personList映射到masterList中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDTO.Person&gt; personList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Master&gt; masters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写converter，这次需要进行两层映射。</p>
<p>第一层将person集合映射到master集合上。</p>
<p>第二层将person对象的属性映射到master对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;masters&quot;, source = &quot;personList&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;name&quot;, source = &quot;personName&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;age&quot;, source = &quot;personAge&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel.Master <span class="title function_">toList</span><span class="params">(HotelDTO.Person person)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505215457158.png"></p>
<p>查看target包下的代码，可以发现MapStruct除了两层映射外，还帮你自动生成了迭代集合添加元素的代码，从而实现集合元素的复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConverterImpl</span> <span class="keyword">extends</span> <span class="title class_">TestConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestConverterImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 第一层映射</span></span><br><span class="line">    <span class="keyword">public</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hotelDTO == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">            hotel.setMasters(<span class="built_in">this</span>.personListToMasterList(hotelDTO.getPersonList()));</span><br><span class="line">            hotel.setHotelAddress(hotelDTO.getAddress());</span><br><span class="line">            hotel.setHotelName(hotelDTO.getName());</span><br><span class="line">            <span class="keyword">return</span> hotel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 第二层映射</span></span><br><span class="line">    <span class="keyword">public</span> Hotel.Master <span class="title function_">toList</span><span class="params">(HotelDTO.Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Hotel.<span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>.Master();</span><br><span class="line">            master.setName(person.getPersonName());</span><br><span class="line">            master.setAge(person.getPersonAge());</span><br><span class="line">            <span class="keyword">return</span> master;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 调用第二层映射，将person集合的元素添加到master中</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Hotel.Master&gt; personListToMasterList(List&lt;HotelDTO.Person&gt; list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Hotel.Master&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list.size());</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                HotelDTO.<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (HotelDTO.Person)var3.next();</span><br><span class="line">                list1.add(<span class="built_in">this</span>.toList(person));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字段的逻辑处理">4.字段的逻辑处理<a id="logister"></a></h2>
<h3 id="复杂逻辑处理qualifiedbyname和named">4.1.复杂逻辑处理（qualifiedByName和@Named）</h3>
<p>这次我们需要把dto中的personName和personAge的list集合映射到实体类的masters集合中。常规的集合映射无法处理这种情况，这时需要使用到qualifiedByName和@Named进行特殊处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; personName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; personAge;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主人</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Master&gt; masters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer personAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就需要拿到两个list的数据，进行手动处理了。在@Mapping注解的qualifiedByName属性指定方法名定位处理逻辑的方法，<span class="citation" data-cites="Named">@Named</span>("dtoToMasters")。</p>
<p>利用stream流进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;masters&quot;, source = &quot;hotelDTO&quot;, qualifiedByName = &quot;dtoToMasters&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named(&quot;dtoToMasters&quot;)</span></span><br><span class="line">List&lt;Hotel.Master&gt; dtoToMasters(HotelDTO hotelDTO) &#123;</span><br><span class="line">    List&lt;String&gt; personNames = hotelDTO.getPersonName();</span><br><span class="line">    List&lt;Integer&gt; personAges = hotelDTO.getPersonAge();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (personNames != <span class="literal">null</span> &amp;&amp; personAges != <span class="literal">null</span> &amp;&amp; personNames.size() == personAges.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, personNames.size())</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Hotel</span>.Master(personNames.get(i), personAges.get(i)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果列表长度不匹配或其他错误情况，可以返回空列表或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505214305462.png"></p>
<h3 id="额外逻辑处理ignore和aftermapping">4.2.额外逻辑处理（ignore和@AfterMapping）</h3>
<p><span class="citation" data-cites="Mappings的ignore属性">@Mappings的ignore属性</span>，也可以对一个字段（不能是集合）进行额外逻辑处理。通常搭配@AfterMapping注解使用。</p>
<p>这个案例中，我们需要根据DTO的mount属性判断是否大于15，如果大于，则判断hotel实体类的isSuccess为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店生意是否兴隆</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer mount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写converter，注意@AfterMapping注解下的方法的参数列表，需要使用@MappingTarget注解指明<strong>目标对象</strong>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;isSuccess&quot;, ignore = true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterMapping</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">isSuccess</span><span class="params">(HotelDTO hotelDTO, <span class="meta">@MappingTarget</span> Hotel hotel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hotelDTO.getMount() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hotelDTO.getMount() &gt; <span class="number">15</span>;</span><br><span class="line">    hotel.setIsSuccess(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HotelDTO</span> <span class="variable">build</span> <span class="operator">=</span> HotelDTO.builder()</span><br><span class="line">            .name(<span class="string">&quot;五星级酒店&quot;</span>)</span><br><span class="line">            .address(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">            .mount(<span class="number">18</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="type">TestConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestConverterImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> converter.dto2Hotel(build);</span><br><span class="line"></span><br><span class="line">    System.out.println(hotel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505221140556.png"></p>
<h3 id="简单逻辑处理expression">4.3.简单逻辑处理（expression）</h3>
<p>expression可以在注解中编写简单的处理逻辑</p>
<p>在这个案例中我需要在实体类的nowTime字段获取当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="comment">// 酒店名称</span></span><br><span class="line">    <span class="keyword">private</span> String hotelName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 酒店地址</span></span><br><span class="line">    <span class="keyword">private</span> String hotelAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime nowTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在expression属性中使用方法获取当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店详情</span></span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelName&quot;, source = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;hotelAddress&quot;, source = &quot;address&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(expression = &quot;java(java.time.LocalDateTime.now())&quot;, target = &quot;nowTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Hotel <span class="title function_">dto2Hotel</span><span class="params">(HotelDTO hotelDTO)</span>;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/image-20240505221724742.png"></p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>数据复制</tag>
        <tag>MapStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程】线程池参数及创建方法</title>
    <url>/2024/05/27/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是线程池">1.什么是线程池<a id="why"></a></h2>
<p><strong>线程池就是管理一系列线程的资源池</strong>。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<blockquote>
<p><strong>为什么要使用线程池？</strong></p>
</blockquote>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h2 id="线程池七大参数">2.线程池七大参数<a id="param"></a></h2>
<h3 id="核心线程数">2.1.核心线程数</h3>
<p><strong><code>corePoolSize</code></strong>：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。当提交一个新任务时，如果线程池中的线程数小于<code>corePoolSize</code>，那么就会创建一个新线程来执行任务。</p>
<h3 id="最大线程数">2.2.最大线程数</h3>
<p><strong><code>maximumPoolSize</code></strong>：线程池中允许的最大线程数。在当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务存放到工作队列中。如果队列也已满，则会去创建一个新线程处理任务。</p>
<h3 id="空闲线程存活时间">2.3.空闲线程存活时间</h3>
<p><strong><code>keepAliveTime</code></strong>：非核心线程的空闲存活时间。当线程数大于<code>corePoolSize</code>时，空闲时间超过<code>keepAliveTime</code>的线程将被终止。</p>
<p>这个参数在设置了<code>allowCoreThreadTimeOut=true</code>时对核心线程同样有效。</p>
<h3 id="空闲线程存活时间单位">2.4.空闲线程存活时间单位</h3>
<p><strong><code>unit</code></strong>：keepAliveTime的计量单位。例如，<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</p>
<h3 id="工作队列">2.5.工作队列</h3>
<p><strong><code>workQueue</code></strong>：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>
<p>①ArrayBlockingQueue</p>
<p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
<p>②LinkedBlockingQuene</p>
<p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
<p>③SynchronousQuene</p>
<p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
<p>④PriorityBlockingQueue</p>
<p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>
<h3 id="线程工厂">2.6.线程工厂</h3>
<p><strong><code>threadFactory</code></strong>：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
<h3 id="拒绝策略">2.7.拒绝策略</h3>
<p><strong><code>handler</code></strong>：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，线程池会执行拒绝策略。JDK中提供了4中拒绝策略：</p>
<p>①CallerRunsPolicy</p>
<p>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</p>
<p>②AbortPolicy</p>
<p>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</p>
<p>③DiscardPolicy</p>
<p>该策略下，直接丢弃任务，什么都不做。</p>
<p>④DiscardOldestPolicy</p>
<p>该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p>
<h2 id="如何设定线程池大小">3.如何设定线程池大小<a id="set"></a></h2>
<p>一般来说，有两种类型的线程：<strong>CPU 密集型</strong>和 <strong>IO
密集型</strong>。</p>
<ul>
<li>CPU
密集型的线程<strong>主要进行计算和逻辑处理</strong>，需要占用大量的 CPU
资源。</li>
<li>IO
密集型的线程<strong>主要进行输入输出操作</strong>，如读写文件、网络通信等，需要等待
IO 设备的响应，而不占用太多的 CPU 资源。</li>
</ul>
<p>常见且简单的公式：</p>
<ul>
<li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU
资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU
核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU
就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU
的空闲时间。</p></li>
<li><p><strong>I/O 密集型任务(2N)：</strong>
这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O
的时间段内不会占用 CPU 来处理，这时就可以将 CPU
交出给其它线程使用。因此在 I/O
密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是
2N。</p></li>
</ul>
<h2 id="如何创建线程池">4.如何创建线程池<a id="create"></a></h2>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p>通过这种方式可以根据服务器硬件配置，灵活设定线程池参数。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f057153326a8f01a3a3caeaad3a8ad2c.png"></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类
<code>Executors</code> 来创建（不推荐）。</strong></p>
<ul>
<li><strong><code>FixedThreadPool</code></strong>：该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong>
该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong>
该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。初始大小为
0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为
60
秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li><strong><code>ScheduledThreadPool</code></strong>：该方法返回一个<strong>用来在给定的延迟后运行任务或者定期执行任务的线程池</strong>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/37586365930865f8219693dce9c35e87.png"></p>
<blockquote>
<p><strong><code>Executors</code> 返回线程池对象的弊端</strong></p>
</blockquote>
<ul>
<li><strong><code>FixedThreadPool</code> 和
<code>SingleThreadExecutor</code></strong>：使用的是无界的
<code>LinkedBlockingQueue</code>，<strong>任务队列最大长度</strong>为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong>：使用的是同步队列
<code>SynchronousQueue</code>, 允许<strong>创建的线程数量</strong>为
<code>Integer.MAX_VALUE</code>
，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致
OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和
<code>SingleThreadScheduledExecutor</code></strong> :
使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，<strong>任务队列最大长度</strong>为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】一、配置篇</title>
    <url>/2023/12/07/%E4%B8%80%E3%80%81IDEA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>配置篇</strong>，将介绍如何<strong>使用IDEA整合git</strong>，从而实现项目管理。</p>
<p>本文将使用<strong>Gitee</strong>作为项目管理工具。</p>
<p>注意：本文假定你已经拥有了一个Gitee账号并已经配置了密钥。</p>
<h2 id="下载插件">下载插件</h2>
<p>打开设置</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101052093.png"></p>
<p>在插件中搜索<strong>Gitee</strong>并下载安装，安装完毕后IDEA会提醒重启IDE，重启后插件才会生效！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101052329.png"></p>
<h2 id="添加账号">添加账号</h2>
<p>IDEA重启后，再次打开设置，在版本控制中可以看到Gitee这一栏，点击加号添加账号</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101055207.png"></p>
<p>点击加号后我们选择<strong>Log in via Gitee</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101056039.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101057087.png"></p>
<p>授权完毕后点击应用。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101058578.png"></p>
<h2 id="项目管理">项目管理</h2>
<p>最后一个步骤就是正式的实现项目的版本控制了，实现这一步骤有两种操作。</p>
<p>第一种是<strong>将IDEA本地的项目上传到gitee中</strong></p>
<p>第二种是<strong>从远程clone一个仓库到IDEA本地中</strong></p>
<p>下面我们来逐个介绍这两种操作，并简述这两者之间的区别和使用场景。</p>
<h3 id="将idea本地的项目上传到gitee中">1.将IDEA本地的项目上传到Gitee中</h3>
<p>现在我们打开你想要托管给Gitee的项目，打开工具栏的VCS，点击<strong>Share
Project on Gitee</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101106369.png"></p>
<p>这里我们可以设置仓库名（Repository
name），Remote是远程分支名，可以不用修改，Description是这个仓库的描述，这里自己填写即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101108667.png"></p>
<p>填写完毕后点击share，弹出这个窗口。</p>
<p>我们需要在本窗口中添加需要进行版本管理的文件以进行初始化，可以看到，本项目的所有文件都是<strong>理论篇</strong>提到的红色文件名的文件，这是因为这个项目还没有上传到远程仓库，也就不存在被Git跟踪的文件，所以都是红色文件名。</p>
<p>这里我们填写下提交信息并点击添加按钮，就可以上传成功了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101111093.png"></p>
<p>上传完毕后，我们可以观察到IDEA中出现了这三个功能块，至于这些功能块有何具体作用，我们将在基础篇详细介绍，这里不过多解释了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101114291.png"></p>
<p>这时候我们可以打开gitee的网站，点击顶部工具栏的头像，选择我的仓库，就可以看到刚刚创建的仓库了!</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101117539.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101118688.png"></p>
<h3 id="从远程clone一个仓库到idea本地中">2.从远程clone一个仓库到IDEA本地中</h3>
<p>这一步我们将从远程仓库中clone一个项目到本地中。</p>
<p>我们在gitee中选择一个想要clone的远程仓库，这里我使用的是我自己的远程仓库：</p>
<p><a href="https://gitee.com/moduokesi_admin/work-space">https://gitee.com/moduokesi_admin/work-space</a></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101122842.png"></p>
<p>点击VCS，选择从版本控制中获取。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101127137.png"></p>
<p>在仓库URL中，在URL中粘贴我们刚才复制的HTTPS地址，在目录中选择我们想要放置远程仓库代码的本地地址，填写完毕后点击克隆。</p>
<p>注意：目录必须是一个空目录</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312101128513.png"></p>
<p>等待克隆完成后项目会自动跳转到你选择的目录。</p>
<h2 id="总结">总结</h2>
<p>通过以上的介绍，我们了解到实现版本控制有两种操作：</p>
<p>第一种操作适用于以下场景：</p>
<ul>
<li>本地你已经开发好了项目，需要将项目托管给远程仓库。</li>
</ul>
<p>第二种操作适用于以下场景：</p>
<ul>
<li>团队已经有了远程仓库（有人已经将远程仓库创建好了），这时候我们直接clone即可。</li>
<li>在gitee或github中看到了优质项目，我们clone本地进行学习</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】三、实战篇</title>
    <url>/2023/12/15/%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>实战篇</strong>，将正式介绍如何使用IDEA结合Git进行项目管理。</p>
<p>注意：本文假设你已经成功在IDEA中配置了git</p>
<p>在配置篇中，当我们已经在本地推送/克隆了一个项目后，我们能看到如下两个功能块。</p>
<p>在本文中，我们称红色箭头所指为<strong>git日志</strong>，蓝色箭头所指为<strong>git工具栏</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102051273.png"></p>
<h2 id="设置默认添加文件">设置默认添加文件</h2>
<p>还记得<strong>基础篇</strong>我们提到的四个工作区域吗？如果我们想要将变更的文件推送到远程仓库，我们首先需要<strong>先保证变更的文件在暂存区中</strong>。</p>
<p>在<strong>基础篇</strong>中，我们提到每当创建一个文件时，idea都会询问我们是否将文件添加到git，即是否添加到暂存区中。为了避免这种麻烦，我们打开设置，按以下流程选择<strong>无提示添加</strong>，这样idea就会默认将我们创建的文件自动添加到git了。</p>
<p>配置完该设置后，相当于每次创建文件都会默认执行git命令<code>git add</code>，作用是将文件添加到暂存区中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102106887.png"></p>
<h2 id="推送更改的文件到本地库">推送更改的文件到本地库</h2>
<blockquote>
<p>当我们在本地完成了我们的工作后，我们可以先将变更的文件提交到本地库中保存。</p>
</blockquote>
<p>这里我们点击蓝色箭头所指git工具栏的第二个按钮，即提交按钮。</p>
<p>该按钮对应git命令<code>git commit</code>，作用是将文件提交到本地库中。</p>
<p>这里我简单的修改了下我自己的更改，填写完提交信息后点击提交。</p>
<blockquote>
<p>如果点击提交并推送的话，就可以直接将变更推送到远程仓库，省去了一个步骤。</p>
<p>提交并推送按钮对应git命令<code>git commit &amp; git push</code>，作用是将暂存区的变更直接推送到远程仓库</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102104592.png"></p>
<p>提交完毕后，我们打开git日志，能在当前的本地分支中看到我们刚才提交记录：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102115556.png"></p>
<h2 id="将本地库的提交记录推送到远程库中">将本地库的提交记录推送到远程库中</h2>
<blockquote>
<p>当我们已经确定本地库的工作已经结束后，我们就可以将本地库的记录推送到远程库中。</p>
</blockquote>
<p>我们点击git工具栏的第三个按钮，即推送按钮。</p>
<p>该按钮对应git命令<code>git push</code>，作用是将本地的提交记录推送到远程库中。</p>
<p>这里我准备了两个提交记录，按<code>ctrl + 鼠标左键</code>可以多选提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102123171.png"></p>
<p>点击推送按钮后，我们可以在git日志中看到远程仓库中出现了我们刚才推送的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102124929.png"></p>
<p>此时我们打开gitee，可以发现提交记录同样生效于gitee中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102126723.png"></p>
<h2 id="拉取远程分支的变更">拉取远程分支的变更</h2>
<blockquote>
<p>当你的远程仓库发生改变时（你的队友推送了提交记录到远程仓库中），而你自己的远程分支不会自动拉取别人的提交记录，也就是说你的远程分支不具备别人的提交历史。</p>
</blockquote>
<p>此时我们需要点击提取所有远程按钮，这时候就可以把远程仓库的所有本更拉取到自己的远程分支中。</p>
<p>提取所有远程按钮对应git命令<code>git fetch</code>，作用是将远程仓库的变更拉取到远程分支中。</p>
<p>这里我在gitee中手动添加了一个README.md文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102135718.png"></p>
<p>点击按钮后，可以看到远程分支中增加了这条记录，同时，我们可以注意到本地分支名后出现了向下的蓝色箭头，这代表着当前远程分支已经更新了，本地分支也应该进行更新。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102138603.png"></p>
<p>我们选中对应的本地分支，点击更新所选内容按钮，就可以把远程分支的提交记录添加到我们的本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102152552.png"></p>
<p>这里我们也可以选择git工具栏的第一个按钮，这样就可以指定方式传入变更。</p>
<p>该按钮对应git命令<code>git merge</code>或<code>git rebase</code>，作用是传入变更到当前分支</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102154586.png"></p>
<p>结果如下</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312102152982.png"></p>
<h2 id="新建分支">新建分支</h2>
<blockquote>
<p>正常来说我们开发项目肯定不可能只用一个本地分支，一般会在其他分支中开发完毕后再推送到主分支中，这时候就需要新建分支的操作了。</p>
</blockquote>
<p>分支可以简单的理解为<strong>我想基于这个提交以及它所有的父提交进行新的工作</strong>。当我们新建分支时，Git就会将<strong>HEAD指向的提交记录以及该提交记录之前的所有提交记录</strong>保存到新分支中。</p>
<p>如果我们要新建分支，可以点击左侧工具栏的加号按钮，这样就得到了一个新的分支。</p>
<p>该按钮对应git命令<code>git branch</code>，作用是基于当前提交历史创建新的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131915710.png"></p>
<p>新建后我们得到了一个全新的分支dev，他包含了master的全部提交历史。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131916579.png"></p>
<p>当然，由于HEAD当前指向的是最后一个提交记录，所以新分支dev就包含了master的全部提交记录。如果我们要基于<code>测试1</code>这个提交历史创建分支的话，需要右键该提交历史，点击新建分支后再输入分支名并创建即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132014188.png"></p>
<p>这样我们就得到了一个包含测试1之前所有提交记录的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132015309.png"></p>
<h2 id="回到指定的提交历史">回到指定的提交历史</h2>
<blockquote>
<p>假设你当前开发的代码出现了问题，如何找回之前的代码？这时候就可以通过<strong>签出</strong>这一git提供功能回到之前的提交历史。当你签出到一个提交历史时，你就获取到了这个提交历史的所有代码。</p>
<p>注意：在签出前确保你当前的代码已经提交到了本地或者远程分支中，签出到其他提交记录时IDEA不会帮你自动保存当前的代码。</p>
</blockquote>
<p>在签出的操作中，我们必须要明白<code>HEAD</code>这一概念，<code>HEAD</code>
是一个<strong>指向当前所在分支的指针</strong>，或者是<strong>指向当前所在提交记录的指针</strong>。在IDEA中，HEAD的位置可以通过黄色便签来看到，比如在下图master的提交历史中，HEAD指向的分支就是master，同时指向提交消息为<code>add README.md.</code>的提交记录。这里我们将下图称为图1。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131935531.png"></p>
<p>如果我们要切换到<code>测试1</code>的提交历史上，右键<code>测试1</code>，点击签出修订。</p>
<p>签出修订按钮对应git命令<code>git checkout</code>，作用是将HEAD指针转移到当前分支/提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131925168.png"></p>
<p>可以看到黄色便签转移到了测试1上，证明我们当前在测试1的提交历史上，这时我们就可以基于测试1的代码进行修改了。这里我们将下图称为图2。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312131945582.png"></p>
<p>但是这里有个问题，为什么图2在master分支上的黄色便签消失了？而在图1中黄色便签既指向了master又指向了最后一个提交记录<code>add README.md.</code></p>
<p>这里要明白一个原理，那就是分支本身也能看作是一个指针，这个指针<strong>恒指向该分支的最后一个提交记录</strong>。</p>
<p>那么在图1中，HEAD其实是通过指向分支<strong>进而</strong>指向了该分支的最后一个提交记录，即<code>HEAD-&gt;master-&gt;add README.md.</code>。而在图2中，HEAD被称作<code>游离的HEAD</code>，是因为它指向的并不是分支而是该分支的一个提交历史，自然就不会指向master分支了，即<code>HEAD-&gt;测试1</code>。</p>
<h2 id="基于指定提交历史修改代码">基于指定提交历史修改代码</h2>
<blockquote>
<p>在上一个<code>回到指定的提交历史</code>的操作中，我们通过签出的操作获取到了指定的提交历史的代码，这时我们就能够基于这个提交历史的代码进行开发。</p>
</blockquote>
<p>举个例子，假设我们要回到之前刚添加md文件的提交历史上进行代码开发，给md文件进行修改。我们当前分支的最新提交为<code>博文3</code>，如何回到提交历史<code>add README.md.</code>上？</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262003659.png"></p>
<p>第一步我们肯定要签出到<code>add README.md.</code>上，签出后可以发现项目文件回到了刚开始提交md文件的时候。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262003012.png"></p>
<p>这时我们对md文件进行修改，这里我删除了一些段落。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262007614.png"></p>
<p>然后点击提交按钮，将这个修改历史<code>666</code>提交到本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262007485.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262008726.png"></p>
<p>此时Git给出了警告。如果我们无视警告，仍然点击提交按钮，就会发现原本存在于<code>add README.md.</code>提交记录的指针消失了，而且我们修改后的提交记录<code>666</code>也并没有被提交到本地分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262012288.png"></p>
<p>还记得之前我们提到的<strong>游离的HEAD</strong>吗？如果直接在特定提交上修改代码并运行
<code>git commit</code>，这实际上会在游离的 HEAD
状态下创建一个新的提交，而不会创建分支。这样的操作可能会导致出现一个<strong>游离的提交</strong>，Git
的垃圾回收机制可能会删除这些提交。</p>
<h3 id="解决方法1">解决方法1</h3>
<p>一种方法是：我们在<strong>指定提交历史上创建一个分支</strong>，然后<strong>在新分支上开发完毕后进行提交</strong>。这两步操作前文已经详细介绍了，不再赘述，如图所示。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262020744.png"></p>
<h3 id="解决方法2">解决方法2</h3>
<p>第二种方法则是：对指定提交记录执行<code>git revert</code>命令，该命令会基于指定提交记录创建一个新的提交历史</p>
<p>我们可以右键一个提交记录，选择还原提交选项。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262038451.png"></p>
<p>如果当前分支的提交记录和还原的提交记录的文件存在差异的话会出现代码冲突。这里因为我当前分支的第一个提交记录<code>博文3</code>和<code>add README.md.</code>在md文件上存在差异，所以出现了冲突。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262041894.png"></p>
<p>由于我们当前的目标是回到<code>add README.md.</code>这个提交记录的代码中，所以我们选择忽略来自其他提交的变更，保留<code>add README.md.</code>提交记录的原本代码即可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262042823.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262044196.png"></p>
<p>写好提交消息后点击提交</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262045900.png"></p>
<p>可以发现我们这样就创建了一个和<code>add README.md.</code>一模一样的提交记录了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262046939.png"></p>
<p>接着我们可以基于这个提交记录的代码进行开发，这里前文已经详细介绍了，不再赘述。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262053876.png"></p>
<h2 id="将远程分支拉取到本地">将远程分支拉取到本地</h2>
<blockquote>
<p>设想这样一个场景：你的同事创建了一个新的远程分支并做了一个新的功能，而这个分支是你本地没有的，你现在的工作要基于这个新的功能才能进行下去，那么我们就需要把这个远程分支拉取到本地来。</p>
</blockquote>
<p>在这个例子中，你的同事创建了远程分支<code>origin/dev</code>，而我们本地并没有与其对应的分支。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132128177.png"></p>
<p>我们只需要右键该分支，点击签出，即可将该远程分支拉取到本地。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132131971.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132131639.png"></p>
<h2 id="代码整合">代码整合</h2>
<blockquote>
<p>在项目合作中，将其他人的代码整合到自己的代码中是经常用到的操作，这时就需要利用到Git的合并或变基功能。</p>
</blockquote>
<p>一般来说代码整合会遇到以下几种情况：</p>
<ol type="1">
<li>当前分支正好比其他分支少了几条记录</li>
</ol>
<p>如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，当前dev1中没有dev中的<code>add README.md.</code>的修改记录。首先确保我们当前分支在dev1分支上。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132149480.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132150655.png"></p>
<p>我们右键dev分支，选择变基或合并均可。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132152900.png"></p>
<p>可以看到dev的提交记录整合到了dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132154892.png"></p>
<ol start="2" type="1">
<li>当前分支和其他分支都修改了几条记录</li>
</ol>
<p>如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，dev1中我写的md文件的内容较少。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132200024.png"></p>
<p>在dev中我的队友写的md文件的内容较多。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132201457.png"></p>
<p>现在一样要确保当前分支在dev1中，并且右键dev分支选择合并/变基来整合代码。这个时候就出现了<code>冲突</code>，大家应该很容易就想明白了，因为我当前分支和我队友的分支都同时存在文件名相同、内容不同的文件，这个问题不解决的话自然无法整合。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132206002.png"></p>
<p>解决冲突的话就需要你和队友进行协商。比如这里我的分支dev1就比较少，队友的分支dev写的比我详细，所以我可以进行"妥协"，直接用队友的md文件即可，点击<code>接受他们的</code>这个按钮就可以使用队友的md文件了。</p>
<p>当然，我们也可以不进行妥协，IDEA提供了强大的修订功能，通过点击<code>合并</code>按钮，我们可以选择整合该文件的特定部分。具体如何操作，大家自行练习吧~</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312132211620.png"></p>
<h2 id="删除提交">删除提交</h2>
<blockquote>
<p>我们在实际开发中难免会提交一些无用的提交记录，这时需要利用删除提交的操作。</p>
</blockquote>
<p>右键一个提交记录，选择删除提交选项，即可删除。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262055354.png"></p>
<p>很简单吧？但要注意已经推送到远程分支的提交是<strong>不可删除</strong>的。</p>
<p>这里的绿色提交记录代表还<strong>未推送到远程分支的提交记录</strong>，棕色代表<strong>已经推送到远程分支的提交记录</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312262057344.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目开发】Java调用Python方法一文详解</title>
    <url>/2024/04/26/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E3%80%91Java%E8%B0%83%E7%94%A8Python%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在这个人工智能技术迅速发展的时代，对于我们学生而言，参加软件竞赛已不再是单纯的技术比拼。传统的纯Java编写项目，虽然有其稳定与高效的优势，但在面对日益复杂的算法需求时，其竞争力已逐渐减弱。因此，将Java与Python这两种编程语言的优势相结合，实现<strong>算法与软件</strong>的完美融合，已成为提升项目竞争力的关键。</p>
<p>本文将详细讲解使用Java调用Python的三大方法，并分析各个方法的优势。</p>
<h2 id="jython库不推荐">1.jython库（不推荐）</h2>
<p>首先在pom.xml中导入jython对应依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.python<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jython-standalone<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定Python的版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="手动编写python语句">1.1.手动编写Python语句</h3>
<p>这里我们编写一个简单的a + b函数的实现样例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Python解释器</span></span><br><span class="line">    <span class="type">PythonInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PythonInterpreter</span>();</span><br><span class="line">    <span class="comment">// 编写函数</span></span><br><span class="line">    interpreter.exec(<span class="string">&quot;def add(a, b):\n    return a + b\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Python 函数</span></span><br><span class="line">    <span class="type">PyObject</span> <span class="variable">eval</span> <span class="operator">=</span> interpreter.eval(<span class="string">&quot;add(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果并打印</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Py.tojava(eval, <span class="type">int</span>.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以得到返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result: <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3 id="读取python文件进行调用">1.2.读取Python文件进行调用</h3>
<p>编写一个jythonTest.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>使用PythonInterpreter.execfile方法调用py文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PythonInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PythonInterpreter</span>();</span><br><span class="line">    interpreter.execfile(<span class="string">&quot;D:\\Workspaces\\Project\\intelpython\\jythonTest.py&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用jythonTest.py中的add方法</span></span><br><span class="line">    <span class="type">PyFunction</span> <span class="variable">func</span> <span class="operator">=</span> interpreter.get(<span class="string">&quot;add&quot;</span>,PyFunction.class);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">PyObject</span> <span class="variable">pyobj</span> <span class="operator">=</span> func.__call__(<span class="keyword">new</span> <span class="title class_">PyInteger</span>(a), <span class="keyword">new</span> <span class="title class_">PyInteger</span>(b));</span><br><span class="line">    System.out.println(<span class="string">&quot;获得方法的返回值 = &quot;</span> + pyobj.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<p>上述两个方法的优点是其集成性，Jython允许你在Java中直接执行Python代码，使得Java和Python代码可以直接进行交互。</p>
<p>缺点也是明显的，首先，Jython说到底是Java的库，可能无法完全支持Python的所有库和功能，其次，Python工程师的工作高度耦合在Java代码中，如果你和你的Python同事不能够忍受这种开发方式，那么就不要用这种方法。</p>
<h2 id="java调用命令行推荐">2.Java调用命令行（推荐）</h2>
<p>这种方法的原理是通过Java代码调用操作系统的命令行接口，然后在命令行中执行Python脚本。</p>
<p>Java程序可以通过<code>Runtime.getRuntime().exec()</code>方法或者更高级的<code>ProcessBuilder</code>类来实现这一功能。执行Python脚本后，Java程序可以通过<code>InputStream</code>流来捕获并处理Python脚本的输出结果。</p>
<h3 id="runtime.getruntime.exec方法调用">2.1.Runtime.getRuntime().exec()方法调用</h3>
<ol type="1">
<li>首先需要编写执行Python脚本的命令行语句</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写要执行的命令，注意路径中的转义字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;python D:\\demo1.py agrs1&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用Runtime.getRuntime().exec()方法执行命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令  </span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用process.getInputStream()捕获InputStream流，从而获取执行结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取标准输出  </span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭读取器  </span></span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用process.getErrorStream()捕获标准错误流（可选），如果Python语句报错会打印报错信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 读取标准错误输出（可选）  </span><br><span class="line">BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));</span><br><span class="line">while ((line = errorReader.readLine()) != null) &#123;</span><br><span class="line">	System.err.println(line);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭错误读取器  </span><br><span class="line">errorReader.close();</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>等待进程结束 ，使用process.waitFor()方法获取返回码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 等待进程结束  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">System.out.println(<span class="string">&quot;返回码: &quot;</span> + exitCode);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>完整代码为：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 编写要执行的命令，注意路径中的转义字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;python D:\\demo1.py agrs1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行命令  </span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取标准输出  </span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭读取器  </span></span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取标准错误输出（可选）  </span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">errorReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()));</span><br><span class="line">        <span class="keyword">while</span> ((line = errorReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭错误读取器  </span></span><br><span class="line">        errorReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待进程结束  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">        System.out.println(<span class="string">&quot;Python script exited with code: &quot;</span> + exitCode);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processbuilder类调用最推荐">2.2.ProcessBuilder类调用（最推荐）</h3>
<ol type="1">
<li>编写命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置Python脚本的路径和要传递的参数  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">pythonScriptPath</span> <span class="operator">=</span> <span class="string">&quot;/path/to/your/python/script.py&quot;</span>;  </span><br><span class="line">String[] command = &#123;<span class="string">&quot;python&quot;</span>, pythonScriptPath, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>&#125;; <span class="comment">// 根据需要调整命令和参数  </span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用ProcessBuilder启动进程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ProcessBuilder启动进程  </span></span><br><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(command);  </span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>完整代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaCallPython</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 配置Python脚本的路径和要传递的参数  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pythonScriptPath</span> <span class="operator">=</span> <span class="string">&quot;/path/to/your/python/script.py&quot;</span>;  </span><br><span class="line">            String[] command = &#123;<span class="string">&quot;python&quot;</span>, pythonScriptPath, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>&#125;; <span class="comment">// 根据需要调整命令和参数  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 使用ProcessBuilder启动进程  </span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(command);  </span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 读取标准输出  </span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));  </span><br><span class="line">            String line;  </span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                System.out.println(line);  </span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取标准错误输出（可选）  </span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">errorReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((line = errorReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.err.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭读取器  </span></span><br><span class="line">            reader.close();</span><br><span class="line">            errorReader.close();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 等待进程结束并获取退出值  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();  </span><br><span class="line">            System.out.println(<span class="string">&quot;\nExited with error code : &quot;</span> + exitCode);  </span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<p>两种方法都是通过创建一个Process进程调用命令行获取Python脚本的执行结果。主要区别为第二种方法需要额外创建一个ProcessBuilder类，ProcessBuilder类接收的是String数组，相较于Runtime只接收一个String字符串，ProcessBuilder类编写命令更加灵活。</p>
<h2 id="调用云端模型最推荐">3.调用云端模型（最推荐）</h2>
<p>这种方法需要Python工程师在百度云、腾讯云等云平台上开启接口，然后通过Hutool的工具类发送HTTP请求调用云端接口。</p>
<p>首先需要导入Hutool库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>填写接口地址，使用Map作为表单数据（一般使用表单，比较灵活，文件和文本都可以传输）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://xxx.com/&quot;</span>;</span><br><span class="line">HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;student&quot;</span>, student);</span><br><span class="line">paramMap.put(<span class="string">&quot;answer&quot;</span>, answer);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用HttpRequest发送请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">    .header(AUTH_REQUEST_HEADER, AUTH_REQUEST_SECRET)</span><br><span class="line">    .form(paramMap)</span><br><span class="line">    .execute();</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>判断返回结果合法性，进行相关处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断返回结果是否为空</span></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(execute)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用结果为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接口是否调用成功</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> execute.getStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;执行失败，错误码：&quot;</span> + status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>获取返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印响应结果</span></span><br><span class="line">System.out.println(execute.body());</span><br></pre></td></tr></table></figure>
<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用hutool工具的HttpRequest类发送请求调用python接口</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;student&quot;</span>, student);</span><br><span class="line">paramMap.put(<span class="string">&quot;answer&quot;</span>, answer);</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">execute</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">    .header(AUTH_REQUEST_HEADER, AUTH_REQUEST_SECRET)</span><br><span class="line">    .form(paramMap)</span><br><span class="line">    .execute();</span><br><span class="line"><span class="comment">// 判断返回结果是否为空</span></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(execute)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用结果为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接口是否调用成功</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> execute.getStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;执行失败，错误码：&quot;</span> + status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印响应结果</span></span><br><span class="line">System.out.println(execute.body());</span><br></pre></td></tr></table></figure>
<h2 id="总结">4.总结</h2>
<h3 id="jython库">jython库</h3>
<p>优点：</p>
<ul>
<li>直接在Java程序中执行，可以直接利用Java虚拟机（JVM）的性能优势，减少进程间通信的开销。</li>
</ul>
<p>缺点：</p>
<ul>
<li>Jython可能无法完全支持Python的所有库和功能。</li>
</ul>
<h3 id="java调用命令行">Java调用命令行</h3>
<p>优点：</p>
<ul>
<li>Java和Python进程是独立的，这使得它们可以更容易地并行运行，而不会影响彼此的性能。</li>
<li>对于对硬件要求比较高的Python模型， 本地部署可能存在一定的困难。</li>
<li>对于开发人员比较友好，两者的开发工作分离。</li>
</ul>
<p>缺点：</p>
<ul>
<li>进程间通讯可能会引入额外的开销和复杂性。</li>
</ul>
<h3 id="调用云端模型">调用云端模型</h3>
<p>优点：</p>
<ul>
<li>对于开发人员比较友好，两者的开发工作分离。</li>
<li>利于构建大型算法模型，如百度云等云端平台对于Python模型支持度很高，比起本地更容易部署。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要Java和Python工程师对HTTP请求有一定了解。</li>
<li>云端接口需要支付一定的费用。</li>
</ul>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>调用python</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】二、基础篇</title>
    <url>/2023/12/10/%E4%BA%8C%E3%80%81Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>本文作为该系列的<strong>基础篇</strong>，将简要介绍使用Git所应该知道的<strong>最基本</strong>的知识，因此不算深究原理，哈哈。</p>
<p>注意：本文假设你已经成功在IDEA中配置了git</p>
<h2 id="git的四个工作区域">Git的四个工作区域</h2>
<h3 id="基本概念">基本概念</h3>
<p>Git本地有三个工作区域，分别是<strong>工作区</strong>、<strong>暂存区</strong>、<strong>本地仓库</strong></p>
<p>Git远程有一个工作区域，叫做<strong>远程仓库</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072037674.png"></p>
<ul>
<li><p>工作区：开发者当前工作的目录，主要包含项目的实际文件，其中可能包括<strong>未进行版本管理</strong>的新文件和<strong>已修改</strong>的文件。</p></li>
<li><p>暂存区：作为一个临时存储区域，用于存放工作区中已经修改的文件的<strong>快照</strong>，以便将它们作为一个逻辑单元提交到本地仓库。</p></li>
<li><p>本地库：包含了项目的<strong>提交历史</strong>，开发者可以对其进行各种操作，如分支合并、变基、签出等。本地库是在开发者本地计算机上的存储库。</p></li>
<li><p>远程库：
存放在<strong>代码托管平台</strong>（如Gitee、GitHub）上的仓库，包含了已推送的代码版本、分支、标签等信息。开发者可以通过推送和拉取操作与远程库进行交互，以保持代码同步。</p></li>
</ul>
<h3 id="概念解释">概念解释</h3>
<h4 id="工作区">工作区</h4>
<p>一下子引入了这么多概念，可能大家会有点接受不了，那么这里对以上概念进行详细解释。</p>
<p>具体来说，工作区可以看做你在IDEA中打开的项目目录，如下图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072100334.png"></p>
<p>这里的项目目录就可以看作是工作区，但是在这个工作区中，既存在正常颜色（白色）的文件名，也存在红色、绿色和蓝色的文件名，那么这些文件分别代表什么含义？这里的文件的颜色，其实也就对应着上文所谓<strong>未进行版本管理</strong>的新文件和<strong>已修改</strong>的文件。如下表：</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>颜色</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>白色</td>
<td>在当前提交历史未改动或者已经提交到本地库的文件</td>
</tr>
<tr class="even">
<td>红色</td>
<td>未进行版本管理的新文件，也被称为未跟踪的文件</td>
</tr>
<tr class="odd">
<td>绿色</td>
<td>已经进行版本管理的新文件，该文件已被添加到暂存区中</td>
</tr>
<tr class="even">
<td>蓝色</td>
<td>当前工作区中被修改的文件，该文件已被添加到暂存区中，与绿色相似</td>
</tr>
</tbody>
</table>
<blockquote>
<p>红色文件名、绿色文件名实例</p>
</blockquote>
<p>大家可以自行测试下，如果你直接在项目目录中创建一个文件的话，IDEA会做出提醒：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072113939.png"></p>
<p>这时如果你选择添加的话，该文件就会变成绿色文件从而<strong>被Git进行版本管理</strong>，如果选择取消的话，说明你不希望该文件被Git管理，那么该文件就是红色文件而<strong>不能被提交到暂存区</strong>。</p>
<p>总结：</p>
<ol type="1">
<li><p>当你创建一个新文件时，它就是红色的，表示这是一个未跟踪的文件。通过运行
<code>git add</code>
命令，将文件添加到暂存区，此时文件变为绿色，表示它已经被 Git
管理并准备提交。</p></li>
<li><p>如果你不想将一个未跟踪的文件或已修改的文件纳入版本管理，你可以选择不使用
<code>git add</code> 命令，或者使用 <code>git reset</code>
命令来取消已经添加到暂存区的文件。取消后，文件会回到红色状态，表示它未被跟踪或未被修改。</p></li>
<li><p>但是对于我们日常开发来说，我们创建一个文件肯定是有用意的，一般都希望该文件被提交上去，所以我们一般都选择添加文件，这样才能通过添加到暂存区，再到本地库最终推送到远程仓库中。</p></li>
</ol>
<blockquote>
<p>白色、蓝色文件名实例</p>
</blockquote>
<p>比如这里我删除了md文件中的其中一行，md文件的文件名由白色转为了蓝色</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072130777.png"></p>
<p>该文件一般在该项目已经<strong>提交到本地库</strong>中后，我们准备开发新的功能时才会出现，也就是我们修改了当前已经存在于本地库中的文件，该文件就会被转化成蓝色文件。因为该文件已经被<strong>Git版本管理过了</strong>，所以可以直接提交到本地库。</p>
<p>总结：</p>
<ol type="1">
<li>蓝色文件可以直接提交到本地库中，因为其已经被Git版本管理了</li>
<li>蓝色文件可以简单认为就是白色文件被修改后的文件</li>
</ol>
<h4 id="暂存区">暂存区</h4>
<p>经过前面的内容，大家多少应该可以感觉到，暂存区其实是我们看不见、摸不着的存在，在暂存区中存在的文件一般是绿色和蓝色文件，也就是我们已经使用<code>git add</code>命令添加的文件。</p>
<p>当我们开发完毕一个新的功能后，我们就会准备将这次修改记录提交到<strong>本地仓库</strong>，这时候使用<code>git commit</code>命令就可以将暂存区中的文件提交到本地仓库中。</p>
<blockquote>
<p>提交实例</p>
</blockquote>
<p>在该实例中，我们删除了md文件的其中一行（可以看到changes一栏中是蓝色文件，如果你把一个新的文件也添加到暂存区的话就是前文提到的绿色文件），这里我们要在下方框中填写相关介绍，以便帮助其他团队成员或日后的自己知道这次的提交做了什么。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072141103.png"></p>
<h4 id="本地库">本地库</h4>
<p>具体来说，本地库包含了开发者本地完整的提交历史和所有的本地分支，本地库中的提交记录是暂存区通过执行<code>git commit</code>后得来的。</p>
<p>这里要注意<strong>本地分支</strong>和<strong>本地库</strong>的区别，<strong>本地分支</strong>只是本地库众多分支的<strong>其中一个分支</strong>，当然本地库也可以只包含一个本地分支（但是一般来说开发者不会这么做）。</p>
<blockquote>
<p>本地分支实例</p>
</blockquote>
<p>这里展示了本地库中的master分支，在这个分支中存在着该分支的提交历史和各种信息。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072150426.png"></p>
<h4 id="远程库">远程库</h4>
<p>远程库是存放在<strong>代码托管平台</strong>（如Gitee、GitHub）上的仓库，本地库执行<code>git push</code>命令可将本地的提交记录推送到远程仓库中。</p>
<p><strong>远程分支</strong>和<strong>远程库</strong>的区别同<strong>本地分支</strong>与<strong>本地库</strong>的区别一样</p>
<blockquote>
<p>远程分支实例</p>
</blockquote>
<p>同上本地分支实例。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312072201594.png"></p>
<p>需要注意的是，由于我们在团队开发中涉及到多人的共同协作，因此每个人都可以向远程仓库中推送自己的代码，也就意味在当你在开发新的代码时，远程仓库可能已经发生了变动，那么远程分支也就不能实时和远程仓库的提交记录保持同步了，这时我们需要使用<code>git fetch</code>命令，将远程仓库的提交记录拉取到的远程分支中。</p>
<h2 id="总结">总结</h2>
<p>通过对于工作区域的认识，大家想必已经了解了一个文件如何从工作区一步步提交到远程仓库中，当然这里存在着很多操作中的细节，如切换分支，合并来自其他分支的结果等，而我们是使用IDEA结合Git实现版本管理，同样存在着如何具体使用的问题。由于本篇只讲理论，就不过多介绍了，本系列将会继续更新下去，大家敬请期待~</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【IDEA结合Git实现项目管理实战】四、git冲突篇</title>
    <url>/2024/01/04/%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。</p>
<p>本系列主讲如何具体操作，因此对于Git内部的原理将<strong>不会过多深究</strong>。</p>
<p>本文严禁任何形式的转载、搬运！</p>
</blockquote>
<p>在使用Git进行项目管理时，代码合并是一项常见而重要的操作。本文将重点探讨两种常用的代码合并操作：合并（merge）和变基（rebase）。在进行代码合并时，我们难免会遇到Git冲突的情况。本文也将通过举例详细介绍如何通过IDEA使用Git进行合并或变基操作时可能遇到的代码冲突情况，并提供解决方法。</p>
<h2 id="什么是git冲突">什么是git冲突</h2>
<p>在多分支并行处理时，每个分支可能基于不同版本的主干分支创建。如果每个分支都独立开发而没有进行代码合并，自然不会出现代码冲突。但是，当两个分支同时修改同一文件时，在代码合并时就会出现冲突。</p>
<p>下图为两个分支分别使用合并/变基操作解决冲突后的提交树。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041548373.png"></p>
<h2 id="解决git冲突">解决git冲突</h2>
<p>介绍完冲突出现的原因，那么如何解决冲突呢？在解决git冲突时，我们需要确定以哪个分支的文件版本为准，或者取两个分支的文件的部分片段进行整合。</p>
<p>IDEA提供了强大的冲突解决功能，供用户处理git冲突。下面将进行详细介绍。</p>
<p>当前分支dev1的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印hello world</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印你好 世界</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你好 世界&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>目标分支dev的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">access</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//打印Red Dead:redemption2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Red Dead:redemption2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">access2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//打印荒野大镖客：救赎2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;荒野大镖客：救赎2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们现在的目标是<strong>让两个分支合并后的代码中同时出现method1、method2、access和acess2这四个方法</strong>。</p>
<p>执行合并后，出现界面：</p>
<p>左侧为<strong>当前分支</strong>dev1的提交记录，中间为合并前的<strong>预览结果</strong>，右侧为<strong>目标分支</strong>dev的提交记录。</p>
<p>其中红色区域为代码存在差异的部分。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041920979.png"></p>
<p>先来看第一块红色区域的中间部分的代码。大家一定会疑惑预览结果中出现这段代码是什么意思？为什么会出现报错呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>
<p>这里其实是git对于左右侧存在差异的代码的标记。符号&lt;&lt;&lt;&lt;&lt;&lt;&lt;
xxx的下方是左侧存在差异的代码，符号&gt;&gt;&gt;&gt;&gt;&gt;
xxx的上方是右侧存在差异的代码，比如&lt;&lt;&lt;&lt;&lt;&lt;&lt;
HEAD箭头所指方向也就是我们当前分支的方向（在左侧），在该箭头下面的部分是当前分支的与目标分支的差异代码，这里因为左侧比右侧少了一段代码，因此下面啥东西没有；=======代表分割符号，该分割符号的下面就是目标分支的代码，即import
java.util.concurrent.TimeUnit；&gt;&gt;&gt;&gt;&gt;&gt;&gt;
dev也就代表目标分支的方向（在右侧）</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041931339.png"></p>
<p>那么如何解决冲突呢？对于我们的目标来说，我们的输出语句自然不需要导入这个包，因此把语句<code>import java.util.concurrent.TimeUnit;</code>给删除即可。</p>
<p>点击左侧的箭头符号，可以把<strong>中间区域被替换成左侧的红色区域</strong>（那根细线，也就是没有代码）。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041939164.png"></p>
<p>点击后中间区域消失。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041940548.png"></p>
<p>再来看第二个红色区域，根据我们的目标，我们要将这四个方法都添加进入中间区域。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041941892.png"></p>
<p>先点击左侧的箭头。可以发现<strong>中间区域被替换为左侧代码</strong>，右侧向左箭头变成了向左下箭头。</p>
<p>这个向左下的箭头代表<strong>将右侧的代码添加到中间代码的下方</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041942329.png"></p>
<p>点击后如图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041945639.png"></p>
<p>那么一切就大功告成了，冲突解决成功，点击应用按钮。</p>
<p>git提示还有冲突未处理，这是为什么？</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041946034.png"></p>
<p>把界面翻到上面，发现这个红色区域还没有处理，我们点击那个查号，作用是<strong>将冲突标记为已解决</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041947522.png"></p>
<p>这时IDEA提示所有变更已被处理，那么我们就可以放心大胆的合并了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041948825.png"></p>
<p>合并成功！</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041949361.png"></p>
<h2 id="合并变基详解">合并/变基详解</h2>
<h3 id="合并git-merge">合并（git merge）</h3>
<p>当前分支和目标分支执行合并操作时，Git会将当前分支的<strong>最新提交记录</strong>与目标分支的<strong>最新提交记录</strong>合并，并在当前分支<strong>形成一个新的提交记录</strong>。</p>
<h4 id="示例1">示例1</h4>
<p>当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041725999.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041724559.png"></p>
<p>执行合并操作，dev中的提交记录添加到了分支dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041724739.png"></p>
<h4 id="示例2">示例2</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730233.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730182.png"></p>
<p>执行合并操作，git给出提示（已是最新
删除dev），当前分支dev1没有变动。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041730921.png"></p>
<h4 id="示例3">示例3</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录<code>添加测试类</code>，目标分子dev中有新提交记录<code>添加新文件</code>（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突）</p>
<p>dev1中添加了一个JavaTest文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041800046.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803802.png"></p>
<p>dev分支中添加了一个test.lua文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801717.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801057.png"></p>
<p>执行合并操作，在目标分支dev1中生成一个新的提交记录<code>Merge branch 'dev' into dev1</code>，该提交记录包含了这两个提交记录的变更，如图。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803003.png"></p>
<p>在提交树中，可以看到两个提交记录合并为一个记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041806469.png"></p>
<h3 id="变基git-rebase">变基（git rebase）</h3>
<p>当前分支和目标分支执行变基操作时，Git会将目标分支的最新提交记录依次应用到当前分支的每个新的提交记录中。</p>
<h4 id="示例1-1">示例1</h4>
<p>当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041817890.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041818586.png"></p>
<p>执行变基操作，dev中的两条记录添加到了dev1中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041818966.png"></p>
<h4 id="示例2-1">示例2</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041819420.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041820315.png"></p>
<p>执行变基操作，没有发生变化。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041821704.png"></p>
<h4 id="示例3-1">示例3</h4>
<p>当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录<code>添加测试类</code>，目标分子dev中有新提交记录<code>添加新文件</code>（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突）</p>
<p>dev1中添加了一个JavaTest文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041800046.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041803802.png"></p>
<p>dev分支中添加了一个test.lua文件。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801717.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041801057.png"></p>
<p>执行变基操作，dev分支的提交记录添加到了dev1分支中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041815763.png"></p>
<h3 id="总结">总结</h3>
<p>可以发现，无论是对于合并还是变基操作的示例1和示例2，最终执行操作后的结果都是一样的。对于合并操作，git将两个分支进行合并，最后生成一个新的提交记录，提交树存在交叉。对于变基操作，git将目标分支的提交记录应用到当前分支，提交树仍然是线性的。如图所示。</p>
<p>至于在实际开发中选择合并还是变基，还是看个人喜好了。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041857723.png"></p>
<h2 id="代码冲突示例">代码冲突示例</h2>
<p>注意：本文为方便理解，所有示例均简单的修改项目中的md文件，实际开发中可能存在对多个文件的冲突，但万变不离其宗，只要你具备了解决单个文件代码冲突的能力，那么多个文件的冲突也能轻松应对。</p>
<h3 id="合并变基分支1">合并/变基分支1</h3>
<blockquote>
<p>分支情况，当前dev1的两个提交记录<code>博文1</code>和<code>博文2</code>都在dev的提交记录<code>博文3</code>之前，其余分支一样</p>
<p>时间顺序：博文1-&gt;博文2-&gt;博文3</p>
</blockquote>
<h4 id="合并">合并</h4>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171650606.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171651771.png"></p>
<p>此时合并<strong>有代码冲突</strong>，解决这个冲突。</p>
<p>发现该冲突只针对博文2，也就是最后一个提交记录</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171656401.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171653568.png"></p>
<h4 id="变基">变基</h4>
<p>该冲突为<code>博文1</code>和<code>博文3</code>的冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171659732.png"></p>
<p>该冲突为变基后的<code>博文1</code>和<code>博文2</code>的冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171704664.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171705189.png"></p>
<h3 id="合并变基分支2">合并/变基分支2</h3>
<blockquote>
<p>分支情况：</p>
<p>dev中的<code>博文3</code>在dev1中的<code>博文1</code>和<code>博文2</code>之间</p>
<p>时间顺序：博文1-&gt;博文3-&gt;博文2</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221625858.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221625313.png"></p>
<h4 id="合并-1">合并</h4>
<p>基于上述情况，合并分支存在代码冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312171852617.png"></p>
<p>在代码冲突中，存在<strong>博文2和博文3</strong>的冲突，</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221626751.png"></p>
<p>冲突解决后如图所示。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221626357.png"></p>
<p>这里紫色因为<code>博文3</code>是属于别的分支过来的，其父提交是<code>add README.md.</code>。所以从<code>add README.md.</code>出发，与dev1原本的提交记录<code>博文2</code>结合形成一个新的提交记录<code>Merge branch 'dev' into dev1</code></p>
<p>结论：分支以时间顺序进行排序，合并分支永远是两个分支的最后一个提交历史进行合并。</p>
<h4 id="变基-1">变基</h4>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221627898.png"></p>
<p><code>博文1</code>和<code>博文3</code>存在冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221627499.png"></p>
<p>冲突解决后，选择提交消息不变</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221628613.png"></p>
<p>依然存在冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221629350.png"></p>
<p>可以发现该冲突来自于已经变基的提交<code>博文1</code>和之后的<code>博文2</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221637405.png"></p>
<p>得到变基后的提交树</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221637539.png"></p>
<h3 id="合并变基分支3">合并/变基分支3</h3>
<blockquote>
<p>分支情况：</p>
<p>dev1中的两个提交记录<code>博文1</code>和<code>博文2</code>在dev中的<code>博文3</code>提交之后</p>
<p>时间顺序：博文3-&gt;博文1-&gt;博文2</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221647989.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221647856.png"></p>
<h4 id="合并-2">合并</h4>
<p><code>博文2</code>和<code>博文3</code>存在代码冲突</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401041446569.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221648662.png"></p>
<h4 id="变基-2">变基</h4>
<p>冲突来自于<code>博文3</code>和<code>博文1</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221730553.png"></p>
<p>冲突来自变基后的<code>博文1</code>和<code>博文2</code></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221730592.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202312221651338.png"></p>
<h3 id="总结-1">总结</h3>
<p>通过这三个代码冲突的示例，看到区别了吗？</p>
<p>在合并操作时，冲突通常发生在<strong>两个分支的最新提交记录</strong>上。这是因为合并是将两个不同的分支合并为一个，而最新的提交记录是两个分支的端点。如果两个分支都对同一文件进行了修改，Git
无法确定应该选择哪个更改，因此会产生冲突。</p>
<p>在变基操作时，冲突可能发生在<strong>当前分支的提交记录和目标分支的提交记录之间的每个提交记录</strong>上。这是因为变基是将一系列提交应用到另一个分支上，而不仅仅是最新的提交。如果两个分支都修改了相同的文件，冲突可能会在每个提交记录上发生，而不仅仅是最新的提交。</p>
<p>总的来说，冲突是由于两个分支都对同一文件进行了修改，而 Git
无法自动解决冲突的情况下发生的。在合并操作中，冲突通常发生在最新的提交记录上；在变基操作中，冲突可能发生在多个提交记录上。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>中国大学生服务外包创新创业大赛赛题分析</title>
    <url>/2024/01/08/%E8%B5%9B%E9%A2%98/</url>
    <content><![CDATA[<h2 id="a01-基于文心大模型的智能阅卷平台设计与开发">【A01】
基于文心大模型的智能阅卷平台设计与开发</h2>
<h3 id="技术栈">技术栈</h3>
<ul>
<li>算法部分：PaddleOCR+NLP+文心大模型</li>
<li>后端部分：SpringBoot+Mybatis-Plus+Mysql+Redis+SpringSecurity</li>
<li>前端部分：Nginx+Vue</li>
<li>其他：Git</li>
</ul>
<h3 id="问题及解决方案">问题及解决方案</h3>
<h4 id="评阅效率与成本">评阅效率与成本</h4>
<p><strong>问题描述：</strong>传统评阅面临评阅速度较慢、人力需求大的问题，特别是在<strong>大量试卷</strong>需要评阅时，<strong>评阅及反馈时效性</strong>能否被满足，将是一个巨大的挑战；</p>
<p><strong>关键点：</strong>大量试卷、评阅及反馈时效性</p>
<p><strong>解决方案</strong>：</p>
<ol type="1">
<li>批量评阅，选择、填空、判断题等机器评阅，计算题、简答题等主观题需人工阅卷。主观题可尝试利用自然语言处理（NLP）技术，<em>让机器能够更准确地理解和评价学生的文字表达，将题干和答案输入给<strong>文心大模型</strong></em>，由大模型给阅卷老师提出建议辅助阅卷。</li>
<li>分配任务，将试卷任务划分为多个子任务，由多个评阅者同时处理，以提高评阅速度；将试卷任务分配给多个评阅者，多个评阅者负责不同数量的试卷。</li>
<li>实时反馈，设计评阅者和学生两个角色，让评阅者或学生能够迅速获取评阅结果并及时进行反馈，如老师评阅完后生成时间等数据、试卷评阅完后发送信息给学生，除分数外还可以包括评语和建议。学生端可以设计往期的数据统计、教师端可以设计往期评阅趋势等。</li>
</ol>
<h4 id="有阅无评">有阅无评</h4>
<p><strong>问题描述：</strong>在实际评阅场景中。往往需要更具有<strong>针对性和个性化的评价和建议</strong>，而不仅仅是分数反馈。在这过程中，评阅者需要将关键概念，<strong>结合学生自身特点进行充分关联</strong>，提供更贴近学生需求的知识延展和学科建议；</p>
<p><strong>关键点：</strong>针对性和个性化的评价和建议、关联学生特点、提供知识延展和学科建议</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>反馈设计，评阅者可以输入关键概念给文心大模型，基于文心大模型给出专业评价和建议，或者评阅者自行写出评价和建议。学生端收到反馈后，可以使用文心大模型提取反馈中的知识，并给出学习建议。</li>
<li><em>增加多样性，包括提供更多的学科相关资源链接、在线学习平台等。这可以帮助学生更全面地理解和拓展相关知识。</em></li>
</ol>
<h4 id="学情信息跟踪实际">学情信息跟踪实际</h4>
<p><strong>问题描述：</strong>评阅者在实际操作中难以<strong>全面、数字化地记录学生的评价和进步情况</strong>，进而影响评估的针对性和指导性作用；</p>
<p><strong>关键点：</strong>全面、数字化记录学生的评价和进步情况</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>学情数据可视化，评阅者可以看到该学生历届考试的试卷、评阅建议或成绩趋势图等。</li>
</ol>
<h4 id="实际评阅风格的单一">实际评阅风格的单一</h4>
<p><strong>问题描述：</strong>在实际评阅过程中，评语描述表达方式相对统一，难以通过<strong>多样化的评语风格</strong>来更好地引导学生理解知识点和提高学业水平；</p>
<p><strong>关键点：</strong>多样化的评语风格</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>通用评语库，
构建一个通用的评语库，包含常见的评价和建议，评阅者可以从中选择或修改，以提高评价的一致性和效率。还可以提供评阅者多样化的评语模板，包括鼓励性的、建议性的、肯定的、挑战性的等不同类型。评阅者可以根据学生的表现灵活选择合适的模板，使评语更富有变化。</li>
</ol>
<h4 id="学科限制与切换">学科限制与切换</h4>
<p><strong>问题描述：</strong>由于不同学科具有独特的评价标准和要求，传统评阅工具难以在不同学科间切换，需要更多的学科专业性和差异化的评阅方式。</p>
<p><strong>关键点：</strong>更多的学科专业性和差异化的评阅方式</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>学科试卷分配给对应的学科老师</li>
<li>学科专业化的大模型支持，
集成不同学科领域的专业化大模型，使其能够理解和应用特定学科的术语、概念和评价标准。这有助于提高评阅的准确性和专业性？？？</li>
</ol>
<h3 id="任务清单">任务清单</h3>
<p>（1）试卷图像快速采集与存储；</p>
<p>（2）字符识别与提取；</p>
<p>（3）内容理解与评阅内容生成；</p>
<p>（4）评阅内容的二次编辑；</p>
<p>（5）评阅结果的可视化、整理与导出；</p>
<p>（6）学情数据可视化；</p>
<p>（7）跨平台支持；</p>
<p>（8）实时采集与分析（可选）；</p>
<p>（9）其它拓展功能和创新方向，如软硬一体解决方案。</p>
<h3 id="功能模块">功能模块</h3>
<ul>
<li>试卷导入模块</li>
<li>评阅分配模块</li>
<li>智能评阅模块</li>
<li>学情分析模块</li>
<li>个人信息模块</li>
</ul>
<h2 id="a15基于知识图谱的大学生就业能力评价和职位推荐系统">【A15】基于知识图谱的大学生就业能力评价和职位推荐系统</h2>
<h3 id="技术栈-1">技术栈</h3>
<ul>
<li>算法部分：知识图谱、NLP、推荐和预测模型、文心大模型</li>
<li>后端部分：SpringBoot+Mybatis-Plus+Mysql+Redis+SpringSecurity</li>
<li>前端部分：Nginx+Vue</li>
<li>其他：Git</li>
</ul>
<h3 id="参考网站">参考网站</h3>
<blockquote>
<p>老鱼简历：https://www.laoyujianli.com/</p>
<p>牛客：https://www.nowcoder.com/</p>
</blockquote>
<h3 id="数据集">数据集</h3>
<blockquote>
<p>链接：https://pan.baidu.com/s/1BsrKlVRbWe6i9DTUcOcGtg?pwd=vmeh
提取码：vmeh</p>
</blockquote>
<h3 id="技术要求与指标">技术要求与指标</h3>
<ul>
<li><p>推荐有效性达到80%
以上（用户调查：电子或计算机类相关专业毕业生简历与岗位样例库进行匹配）；</p></li>
<li><p>系统数据库中个人隐私信息（姓名、手机、邮箱、通讯地址等至少4项）进行加密，只能被授权人员解密；</p></li>
<li><p>架构设计上可并发支持1000人以上同时在线使用，推荐响应时间在5s以内；</p></li>
<li><p>技术不限，开发工具不限，可采用开源技术。</p></li>
</ul>
<h3 id="业务背景">业务背景</h3>
<h4 id="知识图谱构建">知识图谱构建</h4>
<p>职位推荐系统需要构建一个包含相关职位、技能要求、行业信息等多个领域知识的知识图谱。</p>
<h4 id="聚合和分析用户信息">聚合和分析用户信息</h4>
<p>与知识库相结合，对用户的个人简历、求职意向、工作经验等信息进行聚合和分析处理。根据用户提供的信息学习用户的兴趣和特征，并利用这些特征在知识图谱上匹配职位需求和其他相关信息。</p>
<h4 id="建立推荐模型">建立推荐模型</h4>
<p>根据用户信息设计推荐算法和预测模型。通常来说，推荐算法有协同过滤、关键因素模型、深度学习模型等，具体选择应该根据实际情况来确定。</p>
<h4 id="推荐结果展示">推荐结果展示</h4>
<p>将推荐结果呈现给用户，并支持用户进行选择和反馈。需要注意的是推荐结果的呈现方式也应该根据不同用户群体的需求和喜好来定制化。</p>
<h3 id="问题及解决方案-1">问题及解决方案</h3>
<p>实现一套大学生就业能力评价和智能岗位推荐系统，根据提供的岗位信息样例库，设计一套含智能算法的软件系统方案：基于知识图谱的岗位信息，利用职位和用户信息，结合推荐算法和相关技术，为用户提供符合其需求和兴趣的职位推荐结果和能力评价结果。</p>
<h4 id="能力评价">能力评价</h4>
<p><strong>问题描述：</strong>用户上传个人简历，并明确自己期望的职位，系统自动<strong>判断用户与期望职位间的契合度</strong>，差异性，给出提升建议，让其知晓对于意向岗位自身知识和技能上的缺陷，找到短板，有针对性提升自我能力。</p>
<p><strong>关键点：</strong>判断用户与期望职位间的契合度、给出提升建议</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>信息提取，利用自然语言处理（NLP）技术提取用户简历和期望职位中的关键词和技能。设计算法计算技能匹配度分数，考虑关键技能的重要性和权重。</li>
<li>构建知识图谱，基于构建的知识图谱，将用户的技能与职位要求进行匹配。利用图谱中的关系和节点信息，评估用户对于职位所需知识的覆盖程度。</li>
<li>差异性分析，分析用户的简历和期望职位之间的差异，包括技能、工作经验、项目经历等方面。</li>
<li>提升建议生成，基于差异性分析和匹配度评估，生成个性化的提升建议。针对用户的短板提供培训建议、学习资源链接、实践项目建议等，以提高其在期望职位上的竞争力。</li>
<li>用户反馈机制，提供用户反馈功能，让用户对系统的匹配度评估和提升建议进行确认。</li>
</ol>
<h4 id="岗位推荐">岗位推荐</h4>
<p><strong>问题描述：</strong>用户上传个人简历，系统自动分析简历内容，生成推荐职位，用户可以给出推荐是否有效的反馈。如果不满意，可修订简历部分内容，重新进行推荐。</p>
<p><strong>关键点：</strong>推荐职位</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>简历内容分析，利用自然语言处理（NLP）技术对用户上传的简历进行内容分析。</li>
<li>用户兴趣，基于用户上传的历史简历数据，建立用户的兴趣和偏好模型。考虑用户之前的工作经验、求职意向、职业发展方向等信息。</li>
<li>职位推荐算法设计，选择合适的推荐算法，如协同过滤、基于内容的推荐、深度学习模型等。结合用户的兴趣模型和简历特征向量，计算与不同职位的匹配度。</li>
<li>修订简历，如果用户不满意推荐结果，系统应提供修订简历的功能。用户可以编辑、添加或删除简历中的信息，系统重新分析并生成更新后的推荐职位。</li>
<li>用户历史记录查看，用户可以查看自己历史上传的简历和推荐结果，了解职业发展轨迹。</li>
</ol>
<h4 id="招聘推荐">招聘推荐</h4>
<p><strong>问题描述：</strong>企业招聘人员输入或上传职位要求，系统自动分析匹配求职人员简历，筛选出符合期望的人员列表。</p>
<p><strong>关键点：</strong>招聘推荐</p>
<p><strong>解决方案：</strong></p>
<ol type="1">
<li>职位要求解析，利用自然语言处理技术，对企业输入或上传的职位要求进行解析。提取关键技能、经验要求、学历等信息，构建职位要求的特征向量。</li>
<li>求职人员匹配度计算，基于已有的用户简历数据，计算每个求职人员与职位要求的匹配度。利用算法综合考虑关键技能匹配、工作经验匹配等因素。</li>
<li>候选人员筛选，根据匹配度计算结果，筛选出符合职位要求的候选人员列表。设置合适的匹配度阈值，确保选出的人员满足企业的期望。可以设计系统推荐排名，推荐排名靠前的人员供企业参考。考虑推荐结果的多样性，确保涵盖不同技能和经验背景的候选人。</li>
<li>候选人员详细信息展示，提供候选人员的详细信息，包括简历、技能、工作经历等。支持企业预览候选人员的综合素质，以便更好地做出招聘决策。</li>
</ol>
<h3 id="用户期望">用户期望</h3>
<p>对开发的产品方案期望如下：</p>
<p>（1）算法优化合理，求职与招聘推荐结果与用户期望一致性高；</p>
<p>（2）胜任度能力评价结果合理，给出的提升建议符合用户短板；</p>
<p>（3）保护简历中个人数据的安全，不侵犯用户隐私；</p>
<p>（4）扩展功能：可以对注册用户的数据和操作行为进行统计分析，给出热门职位、热门技能、热门专业等的一些趋势图等。</p>
<h3 id="功能模块-1">功能模块</h3>
<ul>
<li>简历上传模块</li>
<li>能力评价模块</li>
<li>岗位推荐模块</li>
<li>招聘推荐模块</li>
<li>热门推荐模块</li>
<li>个人信息模块</li>
</ul>
<h2 id="队伍分配">队伍分配</h2>
<blockquote>
<p>A01：周锦辉+罗骏岚+李鑫+杨康庆+禹乐</p>
</blockquote>
<blockquote>
<p>A15：李翔+李慧聪+周亚+朱豪尔+郑国盛</p>
</blockquote>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>赛题分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【消息队列】RabbitMQ基本概念</title>
    <url>/2024/06/30/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91RabbitMQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="rabbitmq的架构">1.RabbitMQ的架构</h2>
<p><strong>Producer(生产者)：</strong>生产者是消息的发送方，负责将消息发布到RabbitMQ的交换器
(Exchange)。</p>
<p><strong>Consumer(消费者)：</strong>消费者是消息的接收方，负责从队列中获取消息，并进行处理和消费。</p>
<p><strong>Exchange(交换器)：</strong>交换器是消息的接收和路由中心，它接收来自生产者的消息，并将消息路由到一个或多个与之绑定的队列(Queue)中。</p>
<p><strong>Queue(队列)：</strong>队列是消息的存储和消费地，它保存着未被消费的消息，等待消费者(Consumer)
从队列中获取并处理消息。</p>
<p><strong>Binding(绑定)：</strong>绑定是交换器和队列之间的关联关系，它定义了交换器将消息路由到哪些队列中。</p>
<p><strong>VHost(虚拟主机)：</strong>它类似于操作系统中的命名空间，用于将RabbitMQ的资源<strong>进行隔离和分组</strong>。每个VHost拥有自己的交换器、队列、绑定和权限设置，不同VHost之间的资源相互独立，互不干扰。VHost可以用于将不同的应用或服务进行隔离，以防止彼此之间的消息冲突和资源竞争。</p>
<h2 id="rabbitmq的工作模式">2.RabbitMQ的工作模式</h2>
<ol type="1">
<li><strong>简单模式（Simple
Mode）</strong>：在这种模式下，有一个生产者和一个消费者。生产者发送消息，消费者接收并处理这些消息。这种模式是最简单的RabbitMQ使用方式。</li>
<li><strong>Work模式（Work
Queues）</strong>：在这种模式下，有一个生产者和多个消费者。生产者发送消息到队列中，消费者从队列中取出消息进行处理。RabbitMQ通过轮询的方式将消息平均发送给消费者，确保一条消息只被一个消费者接收和处理。</li>
<li><strong>发布/订阅模式（Publish/Subscribe）</strong>：在这种模式下，生产者发送消息到交换机，交换机将消息广播到所有与之绑定的队列中，然后消费者从队列中取出消息进行消费。这种模式允许消费者有选择性地接收消息。</li>
<li><strong>路由模式（Routing）</strong>：路由模式与发布/订阅模式类似，但是生产者发送消息时需要指定一个路由键（routing
key），交换机根据路由键将消息发送到匹配的队列中。消费者需要将其队列绑定到交换机，并指定路由键以便接收消息。</li>
<li><strong>Topic模式</strong>：这种模式是路由模式的扩展，它使用更灵活的匹配规则。生产者发送消息时指定一个路由键，消费者可以将其队列绑定到交换机上，并指定一个模式（topic），该模式可以包含通配符，用于匹配路由键。这样，消费者可以接收符合特定模式的所有消息。</li>
<li><strong>RPC模式</strong>：支持生产者和消费者不在同一个系统中，即允许远程调用的情况。通常，消费者作为服务端，放置在远程的系统中，提供接口，生产者调用接口，并发送消息。</li>
</ol>
<h2 id="rabbitmq的作用">3.RabbitMQ的作用</h2>
<ol type="1">
<li><strong>应用解耦</strong>：在生产者和消费者之间建立了一个缓冲区，使得两者之间的处理速度可以异步进行，不需要严格匹配。这大大增加了系统的灵活性和可扩展性。</li>
<li><strong>削峰填谷</strong>：在高并发场景下，大量请求可能瞬间涌入系统，导致系统压力过大。RabbitMQ可以作为一个缓冲存储，将一部分请求暂时存入队列中，起到“削峰”的作用，保证系统平稳运行，在高峰期过去后，继续从队列中取出消息进行处理，直到积压的消息被完全消费。</li>
<li><strong>异步通信</strong>：RabbitMQ支持异步通信，生产者将消息发送到队列后，不必等待消费者处理完消息再返回结果，而是可以继续执行其他任务。这大大提高了系统的并发处理能力和响应速度。</li>
<li><strong>流量整形</strong>：RabbitMQ可以对消息进行优先级排序、延迟处理等，使得消息的处理更加有序和高效。</li>
</ol>
<h2 id="如何处理rabbitmq的消息积压问题">4.如何处理RabbitMQ的消息积压问题？</h2>
<ol type="1">
<li><strong>增加消费者数量</strong>：当消息队列中的消息数量超出当前消费者的处理能力时，可以动态地增加消费者的数量。这样，更多的消费者可以并行地处理消息，从而加快消息的消费速度。</li>
<li><strong>提高消费者的处理能力</strong>：优化消费者的代码逻辑，提升消费者的性能，例如通过<strong>多线程</strong>或其他并行处理技术，可以提高单个消费者的处理速度。</li>
<li><strong>设置消息的过期时间</strong>：为了避免消息无限期地积压在队列中，可以为消息设置一个合理的过期时间。当消息在队列中等待时间过长且未被消费时，RabbitMQ可以自动将其丢弃或进行其他处理。</li>
</ol>
<h2 id="rabbitmq的死信队列">5.RabbitMQ的死信队列</h2>
<h3 id="死信队列介绍">死信队列介绍</h3>
<p>RabbitMQ的死信队列(Dead Letter
Queue，简称DLQ)是一种用于处理<strong>消息处理失败</strong>或<strong>无法路由的消息</strong>的机制。它允许将无法被正常消费的消息重新路由到另一个队列，以便稍后进行进一步的处理、分析或排查问题。</p>
<p>当消息队列里面的消息出现以下几种情况时，就可能会被称为”死信”:</p>
<ol type="1">
<li><strong>消息处理失败：</strong>当消费者由于代码错误、消息格式不正确、业务规则冲突等原因无法成功处理一条消息时，这条消息可以被标记为死信。</li>
<li><strong>消息过期：</strong>在RabbitMQ中，消息可以设置过期时间。如果消息在规定的时间内没有被消费，它可以被认为是死信并被发送到死信队列。</li>
<li><strong>消息被拒绝：</strong>当消费者明确拒绝一条消息时，它可以被标记为死信并发送到死信队列。拒绝消息的原因可能是消息无法处理，或者消费者认为消息不符合处理条件。</li>
<li><strong>消息无法路由：</strong>当消息不能被路由到任何队列时，例如，没有匹配的绑定关系或路由键时，消息可以被发送到死信队列。</li>
</ol>
<p>当消息变成”死信”之后，如果配置了死信队列，它将被发送到死信交换机，死信交换机将死信投递到一个队列上，这个队列就是死信队列。但是如果没有配置死信队列，那么这个消息将被丢弃。</p>
<h3 id="配置死信队列">配置死信队列</h3>
<p>在RabbitMQ中，死信队列通常与交换机(Exchange) 和队列(Queue)
之间的绑定关系一起使用。要设置死信队列，通常需要以下步骤:</p>
<ol type="1">
<li><strong>创建死信队列：</strong>定义一个用于存储死信消息的队列。</li>
<li><strong>创建死信交换机：</strong>为死信队列定义一个交换机，通常是一个direct类型的交换机。</li>
<li><strong>将队列与死信交换机绑定：</strong>将主要队列和死信交换机绑定，以便无法处理的消息能够被转发到死信队列。</li>
<li><strong>在主要队列上设置死信属性：</strong>通过设置队列的<strong><code>x-dead-letter-exchange</code></strong>和<strong><code>x-dead-letter-routing-key</code></strong>属性，来指定死信消息应该被发送到哪个交换机和路由键。</li>
</ol>
<p>当消息被标记为死信时，它将被发送到死信队列，并可以由应用程序进一步处理、审查或记录。这种机制有助于增加消息处理的可靠性和容错性，确保不丢失重要的消息，并提供了一种处理失败消息的方式。</p>
<h2 id="rabbitmq如何实现延迟队列">6.RabbitMQ如何实现延迟队列</h2>
<h3 id="死信队列">死信队列</h3>
<p>当RabbitMQ中的一条正常的消息，因为过了存活时间(TTL过期)、队列长度超限、被消费者拒绝等原因无法被
消费时，就会变成Dead Message，即<strong>死信</strong>。</p>
<blockquote>
<p><strong>实现方法</strong></p>
</blockquote>
<p>当一个消息变成死信之后，他就能被重新发送到死信队列中(其实是交换机-exchange)。基于这样的机制，就可以实现延迟消息了。那就是我们给一个消息设定TTL，但是并不消费这个消息，等他过期，过期后就会进入到死信队列，然后我们再监听死信队列的消息消费就行了。</p>
<p>而且，RabbitMQ中的这个TTL是可以设置任意时长的，这相比于RocketMQ只支持一些固定的时长而显得更加灵活一些。</p>
<blockquote>
<p><strong>死信队列实现延迟队列的缺点</strong></p>
</blockquote>
<p>但是，死信队列的实现方式存在一个问题，那就是可能造成队头阻塞，因为队列是先进先出的，而目每次只会判断队头的消息是否过期，那么，如果队头的消息时间很长，一直都不过期，那么就会阻塞整个队列，这时候即使排在他后面的消息过期了，那么也会被一直阻塞。</p>
<p>基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性可以实现高可用，以及处理大并发量。他的缺点一是可能存在消息阻塞的问题；二是方案比较复杂，不仅要依赖RabbitMQ，而且还需要声明很多队列出来，增加系统的复杂度。</p>
<h3 id="rabbitmq插件">RabbitMQ插件</h3>
<blockquote>
<p><strong>实现方法</strong></p>
</blockquote>
<p>基于插件的方式，消息并不会立即进入队列，而是先把他们保存在一个基于Erlang开发的Mnesia数据库中，然后通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message交换机中。</p>
<p>基于RabbitMQ插件的方式可以实现延迟消息，并且不存在消息阳塞的问题，但是因为是基于插件的，而这个插件
支持的最大延长时间是(232)-1
毫秒，大约49天，超过这个时就会被立即消费。</p>
<blockquote>
<p><strong>RabbitMQ插件实现延迟队列的缺点</strong></p>
</blockquote>
<p>不过这个方案也有一定的限制，它将延迟消息存在于 Mnesia
表中，并且在当前节点上具有单个磁盘副本，存在丢失的可能。</p>
<p>目前该插件的当前设计并不真正适合包合大量延迟消息(例如数十万或数百万)的场景，另外该插件的一个可变性来源是依赖于
Erlang
计时器，在系统中使用了一定数量的长时间计时器之后，它们开始争用调度程序资源，并且时间漂移不断累积。</p>
<h2 id="保证rabbitmq的消息可靠性">7.保证RabbitMQ的消息可靠性</h2>
<p>为了确保消息不丢失，可以采取以下措施：</p>
<ol type="1">
<li><strong>持久化消息：</strong>
将消息持久化到磁盘中，这样即使系统崩溃，消息也不会丢失。常见的MQ如RabbitMQ、Kafka、ActiveMQ都支持消息持久化。</li>
<li><strong>确认机制（Acknowledgment）：</strong>
发送方和接收方都需要确认消息的接收。发送方在发送消息后等待接收方的确认，接收方处理消息后需要确认已成功处理。</li>
<li><strong>重复发送：</strong>
如果在设定时间内没有收到确认，发送方可以重试发送消息。这需要消息处理具备幂等性，即多次处理同一条消息不会造成副作用。</li>
<li><strong>死信队列（Dead Letter Queue, DLQ）：</strong>
当消息无法被成功处理或无法被确认时，将其转移到死信队列中进行后续处理。</li>
<li><strong>高可用集群：</strong>
通过MQ集群来实现高可用性，防止单点故障导致消息丢失。</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】随机盐值+双重SHA256加密实战</title>
    <url>/2024/07/08/%E3%80%90SpringBoot%E3%80%91%E9%9A%8F%E6%9C%BA%E7%9B%90%E5%80%BC+%E5%8F%8C%E9%87%8DSHA256%E5%8A%A0%E5%AF%86%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="sha-256和salt">1.SHA-256和Salt<a id="why"></a></h2>
<h3 id="什么是sha-256">1.1.什么是SHA-256</h3>
<blockquote>
<p><strong>SHA-256</strong>是一种信息摘要算法，也是一种密码散列函数。对于任意长度的消息，SHA256都会产生一个256bit长的散列值（哈希值），用于确保信息传输完整一致，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的<strong>十六进制字符串</strong>来表示。</p>
</blockquote>
<p><strong>SHA-256的具备以下几个关键特点：</strong></p>
<ol type="1">
<li><strong>固定长度输出</strong>：无论输入数据的大小，SHA-256都会产生一个256位（32字节）的固定长度散列值。</li>
<li><strong>不可逆性</strong>：SHA-256的设计使得从生成的散列值无法还原原始输入数据。这种不可逆性在安全性上是非常重要的。</li>
<li><strong>抗碰撞性</strong>：找到两个不同的输入数据具有相同的散列值（碰撞）是极其困难的。虽然理论上碰撞可能发生，但SHA-256被设计得非常抗碰撞。</li>
</ol>
<p>除了SHA-256之外，还有一个密码散列函数<strong>MD5</strong>，过去也常被用于密码加密，但MD5在安全性上低于SHA-256，现在已经很少用于密码加密了，本文不做考虑。</p>
<p><strong>SHA-256 和 MD5 的比较：</strong></p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 53%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>SHA-256</th>
<th>MD5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输出长度</td>
<td>256 位（64 个十六进制字符）</td>
<td>128 位（32 个十六进制字符）</td>
</tr>
<tr class="even">
<td>安全性</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="odd">
<td>计算速度</td>
<td>较慢</td>
<td>快</td>
</tr>
<tr class="even">
<td>抗碰撞能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr class="odd">
<td>应用场景</td>
<td>数据完整性校验、数字签名、密码存储、区块链</td>
<td>曾用于文件校验、密码存储</td>
</tr>
<tr class="even">
<td>推荐使用</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="什么是随机盐值">1.2.什么是随机盐值</h3>
<blockquote>
<p><strong>盐值（salt）</strong>是一种在密码学和安全计算中常用的随机数据，用于增强密码散列的安全性。</p>
<p><strong>随机盐值（random
salt）</strong>是一种用于增强密码散列安全性的技术。它是一个随机生成的数据块，在将密码输入散列函数之前，将<strong>盐值与密码组合</strong>。通过引入随机盐值，可以有效地防止<strong>彩虹表攻击</strong>和相同密码<strong>散列值重复</strong>的问题。</p>
</blockquote>
<p><strong>盐值的作用：</strong></p>
<ol type="1">
<li><strong>防止彩虹表攻击</strong>：
彩虹表是一个预计算的哈希值数据库，用于快速查找常见密码的哈希值。通过在密码哈希之前加入随机盐值，即使密码相同，其最终的哈希值也会不同，从而使彩虹表无效。</li>
<li><strong>避免散列值重复</strong>：
如果两个用户使用相同的密码，在没有盐值的情况下，他们的哈希值会相同。加入盐值后，即使密码相同，生成的哈希值也会不同，这有助于防止攻击者通过观察哈希值来推测用户是否使用了相同的密码。</li>
<li><strong>增加攻击难度</strong>：
盐值增加了密码哈希的复杂性。即使攻击者获取了存储的哈希值和盐值，他们仍需对每个盐值进行单独的暴力破解，显著增加了破解的时间和计算成本。</li>
</ol>
<h2 id="如何进行加密操作">1.3.如何进行加密操作</h2>
<p>本文采用的加密方式是在前端采用md加密防止<strong>明文传输</strong>，后端对密码<strong>二次加密</strong>后再进行<strong>随机盐值</strong>的混入。</p>
<h2 id="前端实现">2.前端实现<a id="front"></a></h2>
<blockquote>
<p>引入md5.min.js</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jquery --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/jquery.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/bootstrap/css/bootstrap.min.css&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/bootstrap/js/bootstrap.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jquery-validator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-validation/jquery.validate.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-validation/localization/messages_zh.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- md5.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/md5.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- common.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/common.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">id</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:50%; margin:0 auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center; margin-bottom: 20px&quot;</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-label col-md-4&quot;</span>&gt;</span>请输入手机号码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">minlength</span>=<span class="string">&quot;11&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;11&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;手机号码&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-label col-md-4&quot;</span>&gt;</span>请输入密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;reset()&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#loginForm&quot;</span>).<span class="title function_">validate</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">submitHandler</span>: <span class="keyword">function</span> (<span class="params">form</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">doLogin</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">doLogin</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inputPass = $(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> salt = <span class="string">&quot;1a2b3c4d&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> str = <span class="string">&quot;&quot;</span> + salt.<span class="title function_">charAt</span>(<span class="number">0</span>) + salt.<span class="title function_">charAt</span>(<span class="number">2</span>) + inputPass + salt.<span class="title function_">charAt</span>(<span class="number">5</span>) + salt.<span class="title function_">charAt</span>(<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> password = <span class="title function_">md5</span>(str);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login/doLogin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">mobile</span>: $(<span class="string">&quot;#mobile&quot;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">password</span>: password</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                layer.<span class="title function_">closeAll</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    layer.<span class="title function_">msg</span>(<span class="string">&quot;成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;userTicket=&quot;</span> + data.<span class="property">object</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;/goods/toList&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    layer.<span class="title function_">msg</span>(data.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                layer.<span class="title function_">closeAll</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后端实现">3.后端实现<a id="how"></a></h2>
<h3 id="导入maven依赖">3.1.导入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="密码加密">3.2.密码加密</h3>
<h4 id="密码加盐">3.2.1.密码加盐</h4>
<p>首先使用Apache的<code>RandomStringUtils</code>工具类，生成16位的盐值。然后将盐拼接到明文后面，进行SHA256加密。</p>
<p>这个加密后的SHA256是个固定64长度的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个16位的随机数，也就是盐</span></span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将盐拼接到明文后，并生成新的sha256码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> DigestUtils.sha256Hex(password + salt);</span><br></pre></td></tr></table></figure>
<h4 id="随机盐值混合">3.2.2.随机盐值混合</h4>
<p>加盐后的SHA256码长度为80位，这里我们采用的<strong>盐值混合规则：将SHA-256散列值的每四个字符中间插入一个盐值字符，依次交替排列。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将盐混到新生成的SHA-256码中，之所以这样做是为了后期解密，校验密码</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>); <span class="comment">// SHA-256是64个字符，加16个字符的盐，总共80个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span>));</span><br><span class="line">    sb.append(salt.charAt(i));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">2</span>));</span><br><span class="line">    sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>这样就完成了加密的操作：<strong>密码加盐 + 盐值混合</strong>。</p>
<h3 id="密码解密">3.3.密码解密</h3>
<h4 id="提取盐值和加盐密码">3.3.1.提取盐值和加盐密码</h4>
<p>按照加密时采用的规则：<strong>将SHA-256散列值的每四个字符中间插入一个盐值字符，依次交替排列。</strong></p>
<p>我们可以将盐值和加盐后的SHA-256码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取盐值和加盐后的SHA-256码</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">64</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">2</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">    sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">4</span>));</span><br><span class="line">    sb2.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> sb1.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> sb2.toString();</span><br></pre></td></tr></table></figure>
<h4 id="比较密码">3.3.2.比较密码</h4>
<p>最后，将取出的盐值与原始密码再次加盐，再次得到加盐密码，与sha256Hex比较即可判断密码是否相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较二者是否相同</span></span><br><span class="line"><span class="keyword">return</span>  DigestUtils.sha256Hex(password + salt).equals(sha256Hex);</span><br></pre></td></tr></table></figure>
<h3 id="完整工具类">3.4.完整工具类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SHA256Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * 生成盐和加盐后的SHA-256码，并将盐混入到SHA-256码中,对SHA-256密码进行加强</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个16位的随机数，也就是盐</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将盐拼接到明文后，并生成新的sha256码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> DigestUtils.sha256Hex(password + salt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将盐混到新生成的SHA-256码中，之所以这样做是为了后期解密，校验密码</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>); <span class="comment">// SHA-256是64个字符，加16个字符的盐，总共80个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span>));</span><br><span class="line">            sb.append(salt.charAt(i));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">2</span>));</span><br><span class="line">            sb.append(sha256Hex.charAt(i * <span class="number">4</span> + <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * 从混入盐的SHA-256码中提取盐值和加盐后的SHA-256码</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verifyPassword</span><span class="params">(String password, String encrypted)</span> &#123;</span><br><span class="line">        <span class="comment">// 提取盐值和加盐后的SHA-256码</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">64</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">2</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">            sb1.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">4</span>));</span><br><span class="line">            sb2.append(encrypted.charAt(i * <span class="number">5</span> + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha256Hex</span> <span class="operator">=</span> sb1.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较二者是否相同</span></span><br><span class="line">        <span class="keyword">return</span>  DigestUtils.sha256Hex(password + salt).equals(sha256Hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>密码加密</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringSecurity】认证授权全流程实战</title>
    <url>/2024/01/18/%E3%80%90SpringSecurity%E3%80%91%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>Spring
Security是一个强大且灵活的身份验证和访问控制框架，用于Java应用程序。它是基于Spring框架的一个子项目，旨在为应用程序提供安全性。</p>
<p>Spring
Security致力于为Java应用程序提供<strong>认证</strong>和<strong>授权</strong>功能。开发者可以轻松地为应用程序添加强大的安全性，以满足各种复杂的安全需求。</p>
<h2 id="springsecurity完整流程">SpringSecurity完整流程</h2>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401181741086.png"></p>
<p><strong>JwtAuthenticationTokenFilter：</strong>这里是我们自己定义的过滤器，主要负责放行不携带token的请求（如注册或登录请求），并对携带token的请求设置授权信息</p>
<p><strong>UsernamePasswordAuthenticationFilter：</strong>负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要由它负责</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<h2 id="一般认证工作流程">一般认证工作流程</h2>
<blockquote>
<p><strong>Authentication接口：</strong>它的实现类表示当前访问系统的用户，封装了用户相关信息。</p>
<p><strong>AuthenticationManager接口：</strong>定义了认证Authentication的方法</p>
<p><strong>UserDetailsService接口：</strong>加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p><strong>UserDetails接口：</strong>提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401181713332.png"></p>
<h2 id="数据库">数据库</h2>
<p>数据库的采用<strong>RBAC权限模型（基于角色的权限控制）</strong>进行设计。</p>
<p>RBAC至少需要三张表：用户表–角色表–权限表（多对多的关系比较合理）</p>
<ul>
<li>用户表（user）：存储用户名、密码等基础信息，进行登录校验</li>
<li>角色表（role）：对用户的角色进行分配</li>
<li>权限表（menu）：存储使用不同功能所需的权限</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182039664.png"></p>
<h2 id="注册流程">注册流程</h2>
<h3 id="配置匿名访问">配置匿名访问</h3>
<p>在配置类中允许注册请求可以匿名访问</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182109765.png"></p>
<h3 id="编写实现类">编写实现类</h3>
<p>registerDTO中存在字符串roleId和实体类user，先取出user判断是否存在相同手机号。若该手机号没有注册过用户，对密码进行加密后即可将用户存入数据库。</p>
<p>创建register方法映射，保存用户的同时也要将roleId一并存入关系表中，使用户获得对应角色。如下图。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182203732.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取Map中的数据</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> registerDTO.getUser();</span><br><span class="line">       <span class="type">String</span> <span class="variable">roleId</span> <span class="operator">=</span> registerDTO.getRoleId();</span><br><span class="line">       <span class="comment">// 判断是否存在相同手机号</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">dataUser</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">               .eq(User::getUserPhone, user.getUserPhone()).one();</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(dataUser)) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;该手机号已注册过用户，请勿重复注册&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 密码加密</span></span><br><span class="line">       user.setUserPassword(passwordEncoder</span><br><span class="line">               .encode(user.getUserPassword()));</span><br><span class="line">       <span class="comment">// 将用户及对应角色存入数据库</span></span><br><span class="line">       save(user);</span><br><span class="line">       userMapper.register(user.getUserPhone(), roleId);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Result.ok(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="登录流程">登录流程</h2>
<h3 id="配置匿名访问-1">配置匿名访问</h3>
<p>在配置类中允许登录请求可以匿名访问</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182109765.png"></p>
<h3 id="调用userdetailsserviceimpl">调用UserDetailsServiceImpl</h3>
<p>登录流程一般对应<code>认证工作流程</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       <span class="comment">//AuthenticationManager 进行用户认证，校验手机号和密码是否正确</span></span><br><span class="line">       <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserPhone(), user.getUserPassword());</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">       <span class="comment">//认证失败给出提示</span></span><br><span class="line">       <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//认证通过，生成jwt并返回</span></span><br><span class="line">       <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">       <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JwtUtil.createToken(userId);</span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       stringRedisTemplate.opsForValue()</span><br><span class="line">               .set(LOGIN_CODE_KEY + userId, JSONUtil.toJsonStr(loginUser));</span><br><span class="line">       map.put(<span class="string">&quot;token&quot;</span>, jwtToken);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Result.ok(map);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>先看这段代码：<code>UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserPhone(), user.getUserPassword());</code>这里先用用户手机号和密码生成UsernamePasswordAuthenticationToken</p>
<p>再看这段代码：<code>Authentication authenticate = authenticationManager.authenticate(authenticationToken);</code>利用authenticate<strong>调用自定义实现类UserDetailsServiceImpl</strong>，根据用户名判断用户是否存在（对应认证流程的1、2、3、4）</p>
<h3 id="实现userdetailsserviceimpl">实现UserDetailsServiceImpl</h3>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182207049.png"></p>
<p>由于试下的是UserDetailsService接口，所以必须实现其方法loadUserByUsername（根据用户名查询数据库是否存在）这里我传入的是手机号。数据库中若存在用户，则返回UserDetails对象（这里的权限信息暂且不看，对应认证流程的5、5.1、5.2、6）</p>
<p>UserDetails对象返回后，authenticate方法会默认通过PasswordEncoder比对UserDetails与Authentication的密码是否相同。因为UserDetails是通过自定义实现类<strong>从数据库中查询出的user对象</strong>，而Authentication相当于是<strong>用户输入的用户名和密码</strong>，也就可以理解为通过前面自定义实现类利用用户名查询到用户后，再看这个用户的密码是否正确。如果用户名或密码不正确，authenticate将会为空，则抛出异常信息。（对应认证流程的7）</p>
<p>由于这里的登录流程不涉及8，9，10，所以不再叙述。</p>
<p>在剩下的代码中我们利用用userId生成了jwt的令牌token，将其存入Redis中并返回token给前端。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401182230778.png"></p>
<h2 id="登出流程">登出流程</h2>
<h3 id="编写过滤器">编写过滤器</h3>
<p>除login、register请求外的所有请求都需要携带token才能访问，因此需要设计token拦截器代码，如下。</p>
<p>对于不携带token的请求（如登录/注册）直接放行；对于携带token的请求先判断该用户是否登录，即redis中是否存在相关信息，若存在，将用户授权信息存入SecurityContextHolder，方便用户授权，最后直接放行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">// 没有token，放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = JwtUtil.parseJwt(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;token非法：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue().get(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> JSONUtil.toBean(userJson, LoginUser.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还需将token拦截器设置在过滤器UsernamePasswordAuthenticationFilter的前面。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401192329419.png"></p>
<h3 id="编写实现类-1">编写实现类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取SecurityContextHolder中的用户id</span></span><br><span class="line">       <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">               (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">       <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">       <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 删除redis中的值</span></span><br><span class="line">       stringRedisTemplate</span><br><span class="line">               .delete(LOGIN_CODE_KEY + userId);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>获取SecurityContextHolder中的用户id后，删除redis中存储的值，即登出成功。</p>
<h2 id="授权流程">授权流程</h2>
<p>确保实现类正确编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorities != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把permissions中String类型的权限信息封装成SimpleGrantedAuthority对象</span></span><br><span class="line">        authorities = permissions.stream()</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在token拦截器中，我们添加了这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure>
<p>这样非登录/注册请求都会被设置授权信息。</p>
<p>为对应接口添加注解@PreAuthorize，就会检验该请求是否存在相关请求。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202401192332398.png"></p>
<h2 id="完整代码">完整代码</h2>
<h3 id="config类">config类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandlerImpl accessDeniedHandler;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointImpl authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化PasswordEncoder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/user/register&quot;</span>).anonymous()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">        <span class="comment">// 添加过滤器</span></span><br><span class="line">        http</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 配置异常处理器</span></span><br><span class="line">        http</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">        <span class="comment">// 允许跨域</span></span><br><span class="line">        http.cors();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration authenticationConfiguration)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置身份验证管理器</span></span><br><span class="line">        <span class="keyword">return</span> authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller类">controller类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.logout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.register(registerDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dto类">dto类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> String roleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> modox</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023年6月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 封装结果后返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SUCCESS_CODE</span> <span class="operator">=</span> <span class="number">200</span>;     <span class="comment">// 访问成功状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">TOKEN_ERROR</span> <span class="operator">=</span> <span class="number">400</span>;      <span class="comment">// Token错误状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ERROR_CODE</span> <span class="operator">=</span> <span class="number">500</span>;       <span class="comment">// 访问失败状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;                               <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg;                                 <span class="comment">// 提示消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer status, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Integer status,String msg,Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(status,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(String msg,Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,<span class="string">&quot;操作成功&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(SUCCESS_CODE,<span class="string">&quot;操作成功&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(Integer status,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(status,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ERROR_CODE,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ERROR_CODE,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title function_">ok</span><span class="params">(Map&lt;String,Object&gt; map)</span>&#123;</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,SUCCESS_CODE);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title function_">ok</span><span class="params">(PageInfo pageInfo)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,SUCCESS_CODE);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;count&quot;</span>,pageInfo.getTotal());</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>,pageInfo.getList());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="entity类">entity类</h3>
<p>UserDetails的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorities != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把permissions中String类型的权限信息封装成SimpleGrantedAuthority对象</span></span><br><span class="line">        authorities = permissions.stream()</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;grd_menu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String menuId;</span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line">    <span class="keyword">private</span> String menuPerms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;grd_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userSex;</span><br><span class="line">    <span class="keyword">private</span> String userPhone;</span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line">    <span class="keyword">private</span> String userSchool;</span><br><span class="line">    <span class="keyword">private</span> Byte[] userImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter类">filter类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">// 没有token，放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = JwtUtil.parseJwt(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;token非法：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue().get(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> JSONUtil.toBean(userJson, LoginUser.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入SecurityContextHolder，设置用户授权信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handler类">handler类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;您的权限不足&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(result);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        WebUtils.renderString(response, json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;用户认证失败&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(result);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        WebUtils.renderString(response, json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service实现类">service实现类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;  <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String userPhone)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;user_phone&quot;</span>, userPhone);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(wrapper);</span><br><span class="line">        <span class="comment">//若数据库中不存在用户</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该手机号未注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        List&lt;String&gt; list = menuMapper.selectPermsByUserPhone(user.getUserPhone());</span><br><span class="line">        <span class="comment">// 封装成UserDetails对象返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//AuthenticationManager 进行用户认证，校验手机号和密码是否正确</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserPhone(), user.getUserPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="comment">//认证失败给出提示</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//认证通过，生成jwt并返回</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JwtUtil.createToken(userId);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue()</span><br><span class="line">                .set(LOGIN_CODE_KEY + userId, JSONUtil.toJsonStr(loginUser));</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>, jwtToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取SecurityContextHolder中的用户id</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getUserId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除redis中的值</span></span><br><span class="line">        stringRedisTemplate</span><br><span class="line">                .delete(LOGIN_CODE_KEY + userId);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(RegisterDTO registerDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Map中的数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> registerDTO.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">roleId</span> <span class="operator">=</span> registerDTO.getRoleId();</span><br><span class="line">        <span class="comment">// 判断是否存在相同手机号</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">dataUser</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">                .eq(User::getUserPhone, user.getUserPhone()).one();</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(dataUser)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;该手机号已注册过用户，请勿重复注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 密码加密</span></span><br><span class="line">        user.setUserPassword(passwordEncoder</span><br><span class="line">                .encode(user.getUserPassword()));</span><br><span class="line">        <span class="comment">// 将用户及对应角色存入数据库</span></span><br><span class="line">        save(user);</span><br><span class="line">        userMapper.register(user.getUserPhone(), roleId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="utils类">utils类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">// token失效：24小时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;token&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIPE</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_SECRET</span> <span class="operator">=</span> <span class="string">&quot;modox@ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的用户Id生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT规则生成的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">                .setSubject(<span class="string">&quot;grd_user&quot;</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIPE))</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, APP_SECRET)</span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token是否有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果token有效返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(jwtToken))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据token获取User信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析token获得的user对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseJwt</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line">        <span class="comment">//验证token</span></span><br><span class="line">        <span class="keyword">if</span> (checkToken(jwtToken)) &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken).getBody();</span><br><span class="line">            <span class="keyword">return</span> claims.get(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;超时或不合法token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:code:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_CODE_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:token:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_USER_TTL</span> <span class="operator">=</span> <span class="number">36000L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>身份校验</tag>
      </tags>
  </entry>
  <entry>
    <title>【RabbitMQ】一文详解消息可靠性</title>
    <url>/2024/07/13/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    <content><![CDATA[<h2 id="前言">1.前言<a id="front"></a></h2>
<p>RabbitMQ
是一款高性能、高可靠性的消息中间件，广泛应用于分布式系统中。它允许系统中的各个模块进行异步通信，提供了高度的灵活性和可伸缩性。然而，这种通信模式也带来了一些挑战，其中最重要的之一是<strong>确保消息的可靠性</strong>。</p>
<p>影响消息可靠性的因素主要有以下几点：</p>
<ul>
<li>发送消息时连接RabbitMQ失败</li>
<li>发送时丢失：
<ul>
<li>生产者发送的消息未送达交换机；</li>
<li>消息到达交换机后未到达队列；</li>
</ul></li>
<li>MQ 宕机，队列中的消息会丢失；</li>
<li>消费者接收到消息后未消费就宕机了。</li>
</ul>
<h2 id="生产者">2.生产者<a id="producter"></a></h2>
<h3 id="生产者重连机制">2.1.生产者重连机制</h3>
<p>生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，RabbitMQ提供的消息发送时的重连机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p>
<p><strong>在生产者yml文件添加配置开启重连机制</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure>
<p>当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。但是RabbitMQ提供的重试机制是<strong>阻塞式的重试</strong>。
如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，就需要合理配置等待时长和重试次数，或者使用<strong>异步线程</strong>来执行发送消息的代码</p>
<h3 id="生产者确认机制">2.2.生产者确认机制</h3>
<p>RabbitMQ的生产者确认机制（Publisher
Confirm）是一种确保消息从生产者发送到MQ过程中不丢失的机制。当消息发送到
RabbitMQ
后，系统会返回一个结果给消息的发送者，表明消息的处理状态。这个结果有两种可能的值：</p>
<p>返回结果有两种方式：</p>
<ul>
<li><strong>publisher-confirm(发送者确认)</strong>
<ul>
<li>消息成功投递到交换机，返回ACK。</li>
<li>消息未投递到交换机，返回NACK。（可能是由于网络波动未能连接到RabbitMQ，可利用生产者重连机制解决）</li>
</ul></li>
<li><strong>publisher-return(发送者回执)</strong>
<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK和路由失败原因。（这种问题一般是因为路由键设置错误，可以人为规避）</li>
</ul></li>
</ul>
<p>通过这种机制，生产者在发送消息后获取返回的回执结果，从而采取对应的策略，如消息重发或记录失败信息。</p>
<h2 id="数据持久化">3.数据持久化<a id="queue"></a></h2>
<h3 id="配置持久化">3.1.配置持久化</h3>
<p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题</p>
<ol type="1">
<li>RabbitMQ宕机，存在内存中的消息会丢失。</li>
<li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞。</li>
</ol>
<p>为了提升性能，默认情况下MQ的数据都是在内存存储的<strong>临时数据</strong>，重启后就会消失。RabbitMQ可以通过配置数据持久化，从而将消息保存在磁盘，包括：</p>
<ul>
<li>交换机持久化（确保RabbitMQ重启后交换机仍然存在）</li>
<li>队列持久化（确保RabbitMQ重启后队列仍然存在）</li>
<li>消息持久化（确保RabbitMQ重启后队列中的消息仍然存在）</li>
</ul>
<p>由于Spring会在创建队列时默认将交换机和队列设置为持久化，发送消息时也默认指定消息为持久化消息，因此不需要额外配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将消息指定为持久化消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">    .withBody(<span class="string">&quot;hello&quot;</span>.getBytes(standardcharsets.UTF_8))</span><br><span class="line">    .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();</span><br><span class="line"><span class="comment">// 给队列发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, message);</span><br></pre></td></tr></table></figure>
<h3 id="惰性队列">3.2.惰性队列</h3>
<p>从RabbitMQ的3.6.0版本开始，就增加了<code>Lazy Queue</code>的概念，也就是<strong>惰性队列</strong>。</p>
<p><strong>在3.12版本后，所有队列都是Lazy
Queue模式，无法更改。</strong></p>
<p>惰性队列的特点如下：</p>
<ul>
<li><p>接收到消息后直接存入磁盘而非内存(内存中只保留最近的消息，默认2048条)</p></li>
<li><p>消费者要消费消息时才会从磁盘中读取并加载到内存</p></li>
<li><p>支持数百万条的消息存储</p></li>
</ul>
<p>对于低于3.12版本的情况，可以使用注解的arguments来指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;grade.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;intel.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;intel.grade&quot;,</span></span><br><span class="line"><span class="meta">            arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么需要数据持久化">3.3.为什么需要数据持久化？</h3>
<p>数据持久化在 RabbitMQ 中有以下重要作用：</p>
<p><strong>队列和交换机的持久化：</strong></p>
<ul>
<li><strong>防止重启后丢失</strong>：将队列和交换机设置为持久化，可以防止
RabbitMQ
服务器重启后丢失这些队列和交换机，确保它们的存在和绑定关系保持不变。</li>
</ul>
<p><strong>消息的持久化：</strong></p>
<ol type="1">
<li><strong>安全性</strong>：
<ul>
<li><strong>防止数据丢失</strong>：消息持久化后，可以防止 RabbitMQ
服务器重启或宕机时数据丢失，方便数据恢复，保证消息的可靠性和耐久性。</li>
</ul></li>
<li><strong>性能</strong>：
<ul>
<li><strong>内存管理</strong>：未持久化的临时消息默认存储在内存中。内存空间有限，大量消息涌入时会导致内存占满，系统需要进行
<code>page out</code> 操作将消息写入磁盘。频繁的 <code>page out</code>
操作会严重影响性能。</li>
<li><strong>预防内存溢出</strong>：通过持久化消息，可以缓解内存压力，防止因内存溢出导致的系统性能问题和崩溃。</li>
</ul></li>
</ol>
<h2 id="消费者">4.消费者<a id="consumer"></a></h2>
<h3 id="消费者确认机制">4.1.消费者确认机制</h3>
<p>为了确认消费者是否正确处理了消息，RabbitMQ提供了消费者确认机制。当消费者处理消息后，会返回回执信息给RabbitMQ。回执有三种值：</p>
<ul>
<li>ack：消息处理成功，RabbitMQ从队列中删除消息。</li>
<li>nack：消息处理失败，RabbitMQ需要再次投递消息。</li>
<li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除消息。</li>
</ul>
<p>在SpringBoot项目中，我们可以通过配置文件选择回执信息的处理方式，一共有三种处理方式：</p>
<ul>
<li><p><strong>none</strong>：不处理。RabbitMQ
假定消费者获取消息后会一定会成功处理，因此消息投递后立即返回<code>ack</code>，将消息从队列中删除。</p></li>
<li><p><strong>manual</strong>：手动模式。需要在业务代码结束后，调用SpringAMQP提供的API发送<code>ack</code>或<code>reject</code>，存在代码侵入问题，但比较灵活。</p></li>
<li><p><strong>auto</strong>：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑进行了环绕增强，返回结果如下：</p>
<ul>
<li><p>如果消费者正常处理消息，自动返回<code>ack</code>并删除队列的消息。</p></li>
<li><p>如果消费者消息处理失败，自动返回<code>nack</code>并重新向消费者投递消息。</p></li>
<li><p>如果消息校验异常，自动返回<code>reject</code>并删除队列中的消息。</p></li>
</ul></li>
</ul>
<blockquote>
<p><strong>注意：</strong>手动模式返回回执消息时通常需要显式指定<code>requeue</code>参数，当<code>requeue=true</code>时，表明消息需要重新入队；当<code>requeue=false</code>时，RabbitMQ将从队列删除消息。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># none，关闭ack；manual，手动ack；auto，自动 ack</span></span><br></pre></td></tr></table></figure>
<h3 id="消息失败重试机制">4.2.消息失败重试机制</h3>
<p>当消费者出现异常后，消息会<strong>不断requeue</strong>（重新入队）到队列，再重新发送给消费者，然后再次异常，再次requeue无限循环，导致mq的消息处理飙升，带来不必要的压力。</p>
<p>可以通过设置yml文件开启失败重试机制，在消息异常时利用本地重试，而不是无限制的进行requeue操作。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false 有状态。如果业务中包含事务，这里改为 false</span></span><br></pre></td></tr></table></figure>
<h3 id="消息失败处理策略">4.3.消息失败处理策略</h3>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有
MessageRecoverer 接口来处理，它包含三种不同的实现：</p>
<ul>
<li><strong>RejectAndDontRequeueRecoverer</strong>：重试次数耗尽后，直接<code>reject</code>，丢弃消息，这是默认采取的方式；</li>
<li><strong>ImmediateRequeueMessageRecoverer</strong>：重试次数耗尽后，返回<code>nack</code>，消息重新入队；</li>
<li><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机。</li>
</ul>
<h2 id="死信队列">5.死信队列<a id="deadletter"></a></h2>
<p>尽管通过以上设置可以确保消息在生产者、消息队列和消费者之间的传递过程中不会丢失，但在某些情况下，消费者仍可能无法成功处理消息（如消息重试次数耗尽后仍无法被消费）。这时候，我们需要一个机制来妥善处理这些无法被正常消费的消息。死信队列便是用于解决这一问题的兜底机制。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407122312671.svg"></p>
<h3 id="死信">5.1.死信</h3>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead
letter）：</p>
<ul>
<li><strong>消息被拒绝：</strong>
当消费者明确拒绝一个消息并且设置不再重新入队（requeue=false）时，这个消息会被标记为死信。</li>
<li><strong>消息过期：</strong>
每个消息或队列可以设置一个TTL（Time-To-Live），即消息的存活时间。如果消息在队列中停留的时间超过了这个TTL，消息会被认为过期，并被转移到死信队列。</li>
<li><strong>队列达到最大长度：</strong>
如果队列设置了最大长度并且达到了这个限制，那么新进入的消息会被转移到死信队列中。</li>
</ul>
<h3 id="创建死信队列">5.2.创建死信队列</h3>
<h4 id="创建死信交换机和死信队列">5.2.1.创建死信交换机和死信队列</h4>
<p>正常使用注解，创建交换机和队列即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dead.queue&quot;, durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                   arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dead.exchange&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;dead.key&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deadLetterQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的消息已经死亡：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绑定死信交换机">5.2.2.绑定死信交换机</h4>
<p>如果队列通过<code>dead-letter-exchange</code>属性指定了一个交换机，那么<strong>该队列中的死信就会投递到这个交换机中</strong>。这个交换机称为死信交换机（Dead
Letter Exchange，简称DLX）</p>
<p>可以通过<code>@Argument</code>注解指定死信交互机和路由键，如下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">@RabbitListener(bindings</span> <span class="string">=</span> <span class="string">@QueueBinding(</span></span><br><span class="line">            <span class="string">value</span> <span class="string">=</span> <span class="string">@Queue(name</span> <span class="string">=</span> <span class="string">&quot;simple.queue&quot;</span><span class="string">,</span> <span class="string">durable</span> <span class="string">=</span> <span class="string">&quot;true&quot;</span><span class="string">,</span></span><br><span class="line">                    <span class="string">arguments</span> <span class="string">=</span> &#123;</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;lazy&quot;</span><span class="string">)</span>,</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;dead.exchange&quot;</span><span class="string">)</span>,</span><br><span class="line">                            <span class="string">@Argument(name</span> <span class="string">=</span> <span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">value</span> <span class="string">=</span> <span class="string">&quot;dead.key&quot;</span><span class="string">)</span></span><br><span class="line">                    &#125;<span class="string">),</span></span><br><span class="line">            <span class="string">exchange</span> <span class="string">=</span> <span class="string">@Exchange(name</span> <span class="string">=</span> <span class="string">&quot;simple.topic&quot;</span><span class="string">,</span></span><br><span class="line">                    <span class="string">type</span> <span class="string">=</span> <span class="string">ExchangeTypes.TOPIC),</span></span><br><span class="line">            <span class="string">key</span> <span class="string">=</span> <span class="string">&quot;simple.key&quot;</span></span><br><span class="line">    <span class="string">))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息可靠性</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】SpringCache轻松启用Redis缓存</title>
    <url>/2024/07/15/%E3%80%90SpringBoot%E3%80%91SpringCache%E8%BD%BB%E6%9D%BE%E5%90%AF%E7%94%A8Redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="前言">1.前言<a id="front"></a></h2>
<p><code>Spring Cache</code>是Spring提供的一种缓存抽象机制，旨在通过简化缓存操作来提高系统性能和响应速度。<code>Spring Cache</code>可以将方法的返回值缓存起来，当下次调用方法时如果从缓存中查询到了数据，可以直接从缓存中获取结果，而<strong>无需再次执行方法体中的代码</strong>。</p>
<h2 id="常用注解">2.常用注解<a id="common"></a></h2>
<ul>
<li><span class="citation" data-cites="Cacheable">@Cacheable</span>：在方法执行前查看是否有缓存对应的数据，如果有直接返回数据，如果没有调用方法获取数据返回，并缓存起来；</li>
<li><span class="citation" data-cites="CacheEvict">@CacheEvict</span>：将一条或多条数据从缓存中删除；</li>
<li><span class="citation" data-cites="CachePut">@CachePut</span>：将方法的返回值放到缓存中；</li>
<li><span class="citation" data-cites="EnableCaching">@EnableCaching</span>：开启缓存注解功能；</li>
<li><span class="citation" data-cites="Caching">@Caching</span>：组合多个缓存注解。</li>
</ul>
<h2 id="启用缓存">3.启用缓存<a id="start"></a></h2>
<h3 id="配置yaml文件">3.1.配置yaml文件</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cache:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">simple</span>  </span><br><span class="line">    <span class="attr">simple:</span>  </span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">600s</span></span><br></pre></td></tr></table></figure>
<h3 id="添加注解">3.2.添加注解</h3>
<p>在启动类上添加注解<code>@EnableCaching</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootstrap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringBootstrap.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建缓存">3.3.创建缓存</h3>
<blockquote>
<p>使用<code>@CachePut</code>注解。当方法执行完后，如果缓存不存在则创建缓存；如果缓存存在则更新缓存。</p>
<p>注解中的value属性可指定缓存的名称，key属性则可指定缓存的键，可使用SpEL表达式来获取key的值。</p>
<p>这里result表示方法的返回值UserInfo，从UserInfo中获取id属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;user&quot;, key = &quot;#result.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">create</span><span class="params">(UserCreateRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求中的数据映射给实体类（相关方法自行创建）</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserConverter.createByRequest(request);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> userService.save(user);</span><br><span class="line">    <span class="keyword">if</span> (save) &#123;</span><br><span class="line">        <span class="keyword">return</span> UserConverter.toInfo(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User.create.fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新缓存">3.4.更新缓存</h3>
<blockquote>
<p>同样使用<code>@CachePut</code>注解。当方法执行完后，如果缓存不存在则创建缓存；如果缓存存在则更新缓存。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;user&quot;, key = &quot;#result.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">update</span><span class="params">(UserUpdateRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求中的数据映映射给wrapper（相关方法自行创建）</span></span><br><span class="line">    Wrapper&lt;User&gt; wrapper = UserConverter.updateWrapperByRequest(request);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> userService.update(wrapper);</span><br><span class="line">    <span class="keyword">if</span> (update) &#123;</span><br><span class="line">        <span class="keyword">return</span> UserConverter.toInfo(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User.update.fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询缓存">3.5.查询缓存</h3>
<blockquote>
<p>使用<code>@Cacheable</code>注解。在方法执行前，首先会查询缓存，如果缓存不存在，则根据方法的返回结果创建缓存；如果缓存存在，则直接返回数据，不执行方法。</p>
<p>这里使用request表示方法的参数UserQueryRequest。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;user&quot;, key = &quot;#request.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">query</span><span class="params">(UserQueryRequest request)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(request.getId());</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User.not.exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c2cInterestCategory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除缓存">3.6.删除缓存</h3>
<blockquote>
<p>使用<code>@CacheEvict</code>注解。当方法执行完后，会根据key删除对应的缓存。</p>
<p>这里可以使用condition属性，当返回结果为true（删除成功）后，才去删除缓存。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;user&quot;, key = &quot;#request.id&quot;, condition = &quot;#result.equals(true)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">delete</span><span class="params">(UserDeleteRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.removeById(request.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重操作">3.7.多重操作</h3>
<blockquote>
<p>使用<code>@Caching</code>注解，通过使用不同的属性进行相应操作。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/379518c4ae66f2d1ef34865c44c6f1dc.png"></p>
<p>创建/更新多个缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">            put = &#123;</span></span><br><span class="line"><span class="meta">                    @CachePut(value = &quot;userById&quot;, key = &quot;#result.id&quot;),</span></span><br><span class="line"><span class="meta">                    @CachePut(value = &quot;userByPhone&quot;, key = &quot;#request.phone&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br></pre></td></tr></table></figure>
<p>删除多个缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">            evict = &#123;</span></span><br><span class="line"><span class="meta">                    @CacheEvict(value = &quot;userById&quot;, key = &quot;#result.id&quot;),</span></span><br><span class="line"><span class="meta">                    @CacheEvict(value = &quot;userByPhone&quot;, key = &quot;#request.phone&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【工厂模式】深入浅出工厂模式三大实现方案</title>
    <url>/2024/07/28/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介">1.简介</h2>
<p><strong>工厂模式</strong>是一种创建型设计模式，通过提供一个接口或抽象类来创建对象，而不是直接实例化对象。工厂模式的主要思想是将对象的创建与使用分离，使得创建对象的过程更加灵活和可扩展。</p>
<p>工厂模式主要包括以下角色：</p>
<ul>
<li><strong>抽象工厂（Abstract
Factory）</strong>：定义了一个创建产品对象的接口，可以包含多个方法来创建不同类型的产品。</li>
<li><strong>具体工厂（Concrete
Factory）</strong>：实现抽象工厂接口，负责实例化具体的产品对象。</li>
<li><strong>抽象产品（Abstract
Product）</strong>：定义了产品的接口或抽象类，是工厂方法和抽象工厂模式中的基础。</li>
<li><strong>具体产品（Concrete
Product）</strong>：实现抽象产品接口，具体定义产品的功能和行为。</li>
</ul>
<h2 id="简单工厂模式">2.简单工厂模式</h2>
<p><strong>简单工厂模式（Simple Factory
Pattern）</strong>：由一个工厂类根据传入的参数决定创建哪一种产品类的实例。它通常包含一个静态方法，这个方法根据参数创建相应的对象。</p>
<p>定义一个简单的例子：电脑有很多品牌，如惠普电脑、联想电脑，如果需要创建这两个对象时，主动new出来，使用了简单工厂模式后，可以把创建的动作交给工厂类，只需要指定参数即可获取对应的对象。</p>
<h3 id="实现方法">实现方法</h3>
<ol type="1">
<li>编写产品类</li>
</ol>
<p>首先创建一个Computer接口，不同的产品实现这一接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品，实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是惠普电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是联想电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写工厂类</li>
</ol>
<p>简单工厂模式不存在抽象工厂，只需编写一个工厂类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据传入的参数创建对应产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;HP&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HPComputer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;Lenovo&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenovoComputer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;该类型无法被生产&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>测试类使用工厂创建产品</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建HP电脑</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">hp</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Lenovo电脑</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">lenovo</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        hp.compute();</span><br><span class="line">        lenovo.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<h3 id="小结">小结</h3>
<p>简单工厂模式虽然实现比较简单，但是工厂类的职责过重，增加新的产品类型需要修改工厂类，违背了开闭原则。</p>
<blockquote>
<p><strong>开闭原则：</strong>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</p>
<p><strong>对扩展开放（Open for
extension）</strong>：软件实体应该允许在不改变其现有代码的情况下，通过增加新功能来对其进行扩展。也就是说，当软件的需求发生变化时，我们应该能够通过添加新代码来满足这些需求，而不需要修改已有的代码。</p>
<p><strong>对修改关闭（Closed for
modification）</strong>：一旦软件实体被开发完成并投入使用，其源代码就不应该再被修改。这可以防止对现有功能的破坏，减少引入新的错误的风险，并使软件更加稳定和可维护。</p>
</blockquote>
<h2 id="工厂方法模式">3.工厂方法模式</h2>
<p><strong>工厂方法模式（Factory Method
Pattern）</strong>：定义一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建推迟到子类。</p>
<h3 id="实现方法-1">实现方法</h3>
<ol type="1">
<li>编写产品类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品，实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是惠普电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是联想电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写工厂类</li>
</ol>
<p>需要定义一个抽象工厂，然后由具体工厂创建对应的产品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerFactory</span> &#123;</span><br><span class="line">    Computer <span class="title function_">createComputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HP工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPComputerFactory</span> <span class="keyword">implements</span> <span class="title class_">ComputerFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HPComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Lenovo工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoComputerFactory</span> <span class="keyword">implements</span> <span class="title class_">ComputerFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenovoComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>测试类使用不同的具体工厂创建产品</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建HP电脑</span></span><br><span class="line">        <span class="type">HPComputerFactory</span> <span class="variable">hpFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HPComputerFactory</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">hpComputer</span> <span class="operator">=</span> hpFactory.createComputer();</span><br><span class="line">        hpComputer.compute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Lenovo电脑</span></span><br><span class="line">        <span class="type">LenovoComputerFactory</span> <span class="variable">lenovoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LenovoComputerFactory</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">lenovoComputer</span> <span class="operator">=</span> lenovoFactory.createComputer();</span><br><span class="line">        lenovoComputer.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<h3 id="小结-1">小结</h3>
<p>优点：</p>
<ul>
<li>遵循开闭原则，新增产品时不需要修改现有系统代码，只需要添加新的具体工厂和具体产品类。</li>
<li>更符合单一职责原则，每个具体工厂类只负责创建一种产品。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了系统复杂度，需要增加额外的类和接口。</li>
</ul>
<h2 id="抽象工厂模式">4.抽象工厂模式</h2>
<p><strong>抽象工厂模式（Abstract Factory
Pattern）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适用于<strong>产品族</strong>的场景，即多个产品等级结构中相关的产品需要一起创建和使用。</p>
<blockquote>
<p><strong>产品等级结构：</strong>指产品的继承结构，例如一个电脑抽象类，它有HP电脑、Lenovo电脑等实现类，那么这个电脑抽象类和他的实现类就构成了一个产品等级结构。</p>
<p><strong>产品族：</strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如，Lenovo除了生产电脑还可以生产打印机等其他产品。</p>
</blockquote>
<h3 id="实现方法-2">实现方法</h3>
<ol type="1">
<li>编写产品类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义电脑抽象产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义电脑具体产品，实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是惠普电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoComputer</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是联想电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义打印机抽象产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义打印机具体产品，实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPPrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是惠普打印机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoPrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是联想打印机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写工厂类</li>
</ol>
<p>定义一个抽象工厂，该工厂可以创建多个产品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Computer <span class="title function_">createComputer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Printer <span class="title function_">createPrinter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HP工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HPComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer <span class="title function_">createPrinter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HPPrinter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Lenovo工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovoFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenovoComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer <span class="title function_">createPrinter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenovoPrinter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>测试类使用不同的具体工厂创建产品</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HPFactory</span> <span class="variable">hpFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HPFactory</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">hpComputer</span> <span class="operator">=</span> hpFactory.createComputer();</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">hpPrinter</span> <span class="operator">=</span> hpFactory.createPrinter();</span><br><span class="line"></span><br><span class="line">        hpComputer.compute();</span><br><span class="line">        hpPrinter.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">LenovoFactory</span> <span class="variable">lenovoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LenovoFactory</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">lenovoComputer</span> <span class="operator">=</span> lenovoFactory.createComputer();</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">lenovoPrinter</span> <span class="operator">=</span> lenovoFactory.createPrinter();</span><br><span class="line">        lenovoComputer.compute();</span><br><span class="line">        lenovoPrinter.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<h3 id="小结-2">小结</h3>
<p>优点：</p>
<ul>
<li>符合开闭原则，新增产品族时无需修改现有系统代码。</li>
<li>符合单一职责原则，每个具体工厂类只负责创建一类产品族。</li>
<li>保证产品族的一致性，同一个工厂创建的产品是属于同一个产品族的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了系统的复杂度。修改产品族时，需要修改所有具体工厂类，扩展性稍差。</li>
</ul>
<h2 id="总结">5.总结</h2>
<blockquote>
<p><strong>适用场景：</strong></p>
</blockquote>
<ul>
<li><p><strong>简单工厂模式</strong>：适用于产品种类较少，客户端只需根据参数获得具体产品的简单场景。适合产品种类不经常变化的场合。</p></li>
<li><p><strong>工厂方法模式</strong>：适用于产品种类较多，每个产品有相应的具体工厂类。适合需要扩展新产品，且不希望修改现有代码的场合。</p></li>
<li><p><strong>抽象工厂模式</strong>：适用于产品族较多，每个产品族中包含多个相关产品。适合创建一系列相关或相互依赖的产品，且希望统一管理产品族的场合。</p></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【代理模式】详细剖析静态代理、JDK动态代理和CGLIB动态代理</title>
    <url>/2024/07/28/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介">1.简介</h2>
<p><strong>代理模式</strong>是常用的Java设计模式，该模式的特点是<strong>代理类与委托类共享相同的接口</strong>。代理类主要负责预处理消息、过滤消息、将消息转发给委托类，并在事后处理消息等。代理类与委托类之间通常存在关联关系，一个代理类对象与一个委托类对象关联。代理类对象本身不真正实现服务，而是通过调用委托类对象的相关方法来提供特定的服务。</p>
<p>代理模式主要包括以下角色：</p>
<ul>
<li><strong>抽象主题（Subject）</strong>：定义代理类和委托类（RealSubject）的共同接口。这个接口规定了代理类和委托类必须实现的方法，代理类可以通过这个接口来调用委托类的方法。</li>
<li><strong>真实主题（RealSubject）</strong>：实现抽象主题，定义委托类的操作。它包含了实际的业务逻辑，是客户端实际需要调用的对象。</li>
<li><strong>代理类（Proxy）</strong>：实现抽象主题，持有对委托类的引用，并在其方法被调用时进行控制。代理类在调用委托类的方法前后可以添加一些额外的功能，如日志记录、权限控制、事务处理等。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407281114432.png"></p>
<h2 id="静态代理">2.静态代理</h2>
<p><strong>静态代理：</strong>在编译时期确定代理类和目标类的关系，代理类和目标类都要实现同一个接口。</p>
<p>定义一个简单的例子：假如一个租客需要租房子，他可以直接通过<strong>房东（委托类）</strong>去租房，也可以经过<strong>中介（代理类）</strong>去租房。房东（realsubject）和中介（proxy）都需要实现subject接口实现房子出租。</p>
<ol type="1">
<li>确定接口具体行为</li>
</ol>
<p>首先创建一个Person接口。这个接口是房东和中介的共同接口，租房行为可以被中介代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 出租房子</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写委托类业务逻辑</li>
</ol>
<p>创建一个委托类，实现subject接口，并编写业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Landlord</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="comment">// 房东直售</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租，收款1000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>代理类增强方法</li>
</ol>
<p>创建一个代理类，同样实现subject接口，对委托类的方法进行增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agency</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Landlord landlord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agency</span><span class="params">(Landlord landlord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.landlord = landlord;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 中介出租，额外收取费用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始办理租房手续&quot;</span>);</span><br><span class="line">        landlord.hire();</span><br><span class="line">        System.out.println(<span class="string">&quot;额外收取中介费200元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>测试类使用代理对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="type">Landlord</span> <span class="variable">landlord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Landlord</span>();</span><br><span class="line">        <span class="type">Agency</span> <span class="variable">agency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agency</span>(landlord);</span><br><span class="line">        <span class="comment">// 使用代理方法</span></span><br><span class="line">        agency.hire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，可以发现对方法进行了增强</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407281227360.png"></p>
<h2 id="动态代理">3.动态代理</h2>
<p><strong>动态代理：</strong>在程序运行时动态生成代理类（subject的实现类）。</p>
<p><strong>相比于静态代理，
动态代理的优势在于其较高的灵活性和代码复用性</strong>。同一个动态代理处理器可以代理多个目标对象，而静态代理则需要创建大量的代理类。</p>
<p>在Java中，可以通过JDK和CGLIB实现动态代理。</p>
<h3 id="jdk动态代理">3.1.JDK动态代理</h3>
<h4 id="实现原理">实现原理</h4>
<p><strong>JDK动态代理：</strong>在java的<code>java.lang.reflect</code>包下提供了<code>Proxy</code>类和<code>InvocationHandler</code>接口，利用这两个类和接口，可以<strong>在运行时动态生成指定接口的实现类</strong>。</p>
<blockquote>
<p><code>Proxy</code>类就是用来创建一个代理对象的类，在JDK动态代理中我们需要使用其<code>newProxyInstance</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">    ClassLoader loader, </span></span><br><span class="line"><span class="params">    Class&lt;?&gt;[] interfaces, </span></span><br><span class="line"><span class="params">    InvocationHandler h)</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用就是创建一个代理类对象，它接收以下三个参数：</p>
<ul>
<li><strong>loader</strong>：一个ClassLoader对象，指定哪个ClassLoader将加载生成的代理类。</li>
<li><strong>interfaces</strong>：一个Interface对象数组，定义代理对象实现的一组接口，代理类可以调用这些接口中声明的所有方法。</li>
<li><strong>h</strong>：一个InvocationHandler对象，指定代理对象的方法调用将关联到哪个InvocationHandler对象，由它处理实际的方法调用。</li>
</ul>
<blockquote>
<p><code>InvocationHandler</code>接口提供了一个<code>invoke</code>方法，当代理对象调用方法时，<code>invoke</code>方法会被调用。通过实现这个接口，可以在方法调用前后添加自定义逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * proxy:代理类代理的真实代理对象com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="comment">    * method:我们所要调用某个对象真实的方法的Method对象</span></span><br><span class="line"><span class="comment">    * args:指代代理对象方法传递的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<h4 id="代码实现">代码实现</h4>
<ol type="1">
<li>确定接口具体行为</li>
</ol>
<p>这里我们设计两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseServiceA</span> &#123;</span><br><span class="line">    <span class="comment">// 出租房子</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseServiceB</span> &#123;</span><br><span class="line">    <span class="comment">// 转租房子</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sublet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写委托类业务逻辑</li>
</ol>
<p>委托类实现这两个接口，并且定义具体的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HouseServiceA</span>, HouseServiceB &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sublet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;转租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>编写代理工厂代码</li>
</ol>
<p>代理工厂负责在运行时动态生成代理类，需要实现<code>InvocationHandler</code>接口重写<code>invoke</code>方法来做方法增强，使用<code>Proxy</code>类创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理实现InvocationHandler接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义获取代理对象的方法（将目标对象传入进行代理）</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getJDKProxy</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="comment">//JDK动态代理只能针对实现了接口的类进行代理，因此需要传递接口的class</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;HouseServiceA.class, HouseServiceB.class&#125;,</span><br><span class="line">                <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理开始&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用invoke方法，result存储该方法的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>测试类使用代理对象</li>
</ol>
<p>在实际使用时，只需要将工厂类生成的代理对象转为需要的代理类，即可实现同时代理多个接口的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建代理类工厂</span></span><br><span class="line">        <span class="type">HouseFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseFactory</span>();</span><br><span class="line">        <span class="comment">// 动态生成接口A的代理类</span></span><br><span class="line">        <span class="type">HouseServiceA</span> <span class="variable">houseProxyA</span> <span class="operator">=</span> (HouseServiceA) factory.getJDKProxy(<span class="keyword">new</span> <span class="title class_">HouseServiceImpl</span>());</span><br><span class="line">        houseProxyA.hire();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        <span class="comment">// 动态生成接口B的代理类</span></span><br><span class="line">        <span class="type">HouseServiceB</span> <span class="variable">houseProxyB</span> <span class="operator">=</span> (HouseServiceB) factory.getJDKProxy(<span class="keyword">new</span> <span class="title class_">HouseServiceImpl</span>());</span><br><span class="line">        houseProxyB.sublet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407281338919.png"></p>
<h3 id="cglib动态代理">3.2.CGLIB动态代理</h3>
<h4 id="实现原理-1">实现原理</h4>
<p><strong>CGLIB动态代理：</strong>依赖于ASM下的<code>Enhancer</code>类和<code>MethodInterceptor</code>接口，可以<strong>在运行时动态生成目标类的子类</strong>。</p>
<blockquote>
<p><code>Enhancer</code>类是用来创建代理对象的类。在CGLIB动态代理中，我们需要使用其<code>create</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enhancer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用是创建一个代理类对象，通常还需要设置以下几个属性：</p>
<ul>
<li><strong>setSuperclass</strong>：设置被代理的目标类，CGLIB通过生成目标类的子类来实现代理。</li>
<li><strong>setCallback</strong>：设置回调接口，用于处理代理对象的方法调用。</li>
</ul>
<blockquote>
<p><code>MethodInterceptor</code>接口提供了一个<code>intercept</code>方法，当代理对象调用方法时，<code>intercept</code>方法会被调用。通过实现这个接口，可以在方法调用前后添加自定义逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * obj: 代理对象</span></span><br><span class="line"><span class="comment">    * method: 被代理的方法</span></span><br><span class="line"><span class="comment">    * args: 方法的参数</span></span><br><span class="line"><span class="comment">    * proxy: 用于调用父类方法的代理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<p>与JDK动态代理不同，CGLIB代理<strong>不需要目标类实现接口</strong>。CGLIB通过生成目标类的子类并重写方法来实现代理，因此它可以代理没有实现接口的类。</p>
<h4 id="代码实现-1">代码实现</h4>
<ol type="1">
<li>首先导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编写委托类业务逻辑（无需实现接口）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hire</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sublet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;转租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>测试类使用代理对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseFactory</span>();</span><br><span class="line">        <span class="type">HouseServiceImpl</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> (HouseServiceImpl) factory.getCglibProxy(<span class="keyword">new</span> <span class="title class_">HouseServiceImpl</span>());</span><br><span class="line">        cglibProxy.hire();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        cglibProxy.sublet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407281418946.png"></p>
<h2 id="总结">4.总结</h2>
<h3 id="静态代理-1">静态代理</h3>
<p>实现方式：</p>
<ul>
<li>由程序员显式编写代理类。<strong>代理类在编译期确定</strong>，编译前就存在代理类的字节码文件。</li>
<li>需要实现与目标对象相同的接口，且在代理类中显式调用目标对象的方法。</li>
</ul>
<p>优点：</p>
<ul>
<li>结构简单，容易理解。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每增加一个接口，都需要编写对应的代理类，代码量大，维护成本高。静态代理类在编译期生成，灵活性差。</li>
</ul>
<h3 id="jdk动态代理-1">JDK动态代理</h3>
<p>实现方式：</p>
<ul>
<li>使用<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。</li>
<li><strong>代理类在运行时动态生成</strong>，不需要显式编写代理类。</li>
</ul>
<p>优点：</p>
<ul>
<li>代理类在运行时生成，增加了代码的灵活性和可维护性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能代理实现了接口的类，不能代理没有实现接口的类。</li>
</ul>
<h3 id="cglib动态代理-1">CGLIB动态代理</h3>
<p>实现方式：</p>
<ul>
<li>使用CGLIB（Code Generation Library），依赖ASM字节码生成框架。</li>
<li><strong>代理类在运行时动态生成</strong>，不需要显式编写代理类。</li>
</ul>
<p>优点：</p>
<ul>
<li>不要求目标类实现接口，可以代理普通的类。</li>
<li>性能通常比JDK动态代理更高，尤其在代理大量方法调用时更为显著。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能代理<code>final</code>类和<code>final</code>方法。</li>
</ul>
<blockquote>
<p><strong>适用场景：</strong></p>
</blockquote>
<ul>
<li><p><strong>静态代理</strong>：需要手动编写代理类，适用于简单的场景，但不够灵活，维护成本高。</p></li>
<li><p><strong>JDK动态代理</strong>：适用于实现了接口的类，代理类在运行时生成，灵活性高，但只能代理接口。</p></li>
<li><p><strong>CGLIB动态代理</strong>：适用于没有实现接口的类，性能优于JDK动态代理，但不能代理<code>final</code>类和<code>final</code>方法，且使用复杂度稍高。</p></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL】一文吃透MVCC执行原理</title>
    <url>/2024/08/02/%E3%80%90MySQL%E3%80%91%E4%B8%80%E6%96%87%E5%90%83%E9%80%8FMVCC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="mvcc是什么">1.MVCC是什么？</h2>
<p>MVCC全称Multi-Version Concurrency
Control，即<strong>多版本并发控制</strong>。它通过维护数据的多个版本来实现高效的并发控制，用于在多个并发事务同时<strong>读写</strong>数据库时保持数据的<strong>一致性</strong>和<strong>隔离性</strong>。</p>
<p>在搞清楚MVCC的实现原理之前，还需要了解快照读和当前读的概念。</p>
<blockquote>
<p><strong>一致性非锁定读（快照读）</strong></p>
</blockquote>
<p>简单的select语句（不加锁）就是快照读，读取的是记录数据的可见版本，不加锁，是非阻塞读。</p>
<ul>
<li><code>select ...</code></li>
</ul>
<blockquote>
<p><strong>一致性锁定读（当前读）</strong></p>
</blockquote>
<p>读取的是记录的最新版本，读取时需要保证其他并发事务不能修改当前记录，会对读取的记录加锁。如果执行的是下列语句，就是锁定读。</p>
<ul>
<li><code>select ... lock in share mode</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>update</code>、<code>delete</code>
操作</li>
</ul>
<h2 id="mvcc实现原理">2.MVCC实现原理</h2>
<p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo
log</strong>。</p>
<h3 id="隐藏字段">隐藏字段</h3>
<p>在内部，<code>InnoDB</code>
存储引擎为<strong>每行数据</strong>添加了三个隐藏字段</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DB_ROW_ID（6字节）</td>
<td>隐藏主键，如果当前表不存在主键，则将该隐藏字段作为主键</td>
</tr>
<tr class="even">
<td>DB_TRX_ID（6字节）</td>
<td>最近修改事务ID，记录插入这条数据或最后一次修改该记录的事务ID</td>
</tr>
<tr class="odd">
<td>DB_ROLL_PTR（7字节）</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log</td>
</tr>
</tbody>
</table>
<p>假设有一个学生表，该表没有指定主键。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291548685.png"></p>
<p>那么该表实际上的字段如下，如果存在主键则不存在<code>DB_ROW_ID</code>字段。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291554966.png"></p>
<h3 id="undo-log">undo log</h3>
<p><code>undo log</code> 分为两种类型：<code>insert undo log</code> 和
<code>update undo log</code>。</p>
<ul>
<li><code>Insert undo log</code>
是在事务进行插入操作时生成的日志。其主要作用是用于事务回滚时撤销插入操作。<strong>该日志只在回滚时需要，在事务提交后，可被立即删除。</strong></li>
<li><code>Update undo log</code>
是在事务进行更新或删除操作时生成的日志。其主要作用是用于事务回滚时撤销更新和删除操作。<strong>该日志不仅在回滚时需要，在快照读时也需要，不会被立即删除。</strong></li>
</ul>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个一个
DB_TRX_ID事务id 和 DB_ROLL_PTR 指针：</p>
<ul>
<li>通过 DB_TRX_ID 可以知道该记录是被哪个事务修改的；</li>
<li>通过 DB_ROLL_PTR 指针可以将这些 undo log
串成一个链表，这个链表就被称为版本链；</li>
</ul>
<blockquote>
<p><strong><em>举例说明：</em></strong></p>
</blockquote>
<p>事务1已经提前执行了<code>INSERT INTO user (id, age, name) VALUES (10, 10, 'Jack');</code>语句插入了一条记录。则<code>DB_TRX_ID</code>（插入这条数据或最后一次修改该记录的事务ID）为1，由于<code>insert undo log</code>在事务提交后自动删除，所以不存在undo
log日志，<code>DB_ROLL_PTR</code>为null。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291751813.png">该示例中有四个并发事务，其他事务在不同的时刻将执行update语句修改记录。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291744033.png"></p>
<p>所有事务执行完毕后，当前记录的DB_TRX_ID为4，且形成了一条Update Undo
Log版本链，<strong>后续MVCC可以利用这条版本链获取旧数据。</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291803408.png"></p>
<h3 id="read-view">Read View</h3>
<p>ReadView（读视图）是<strong>快照读</strong>执行时MVCC获取数据的依据，记录并维护系统尚未提交的事务（也称为活跃事务）id。</p>
<p>ReadView有以下四个重要字段：</p>
<table>
<thead>
<tr class="header">
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>m_ids</td>
<td>当前活跃事务的ID集合</td>
</tr>
<tr class="even">
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr class="odd">
<td>max_trx_id</td>
<td>预分配事务ID，当前最大事务ID+1（事务ID自增）</td>
</tr>
<tr class="even">
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tips：</strong><code>m_ids</code>的长度可不是<code>max_trx_id - min_trx_id</code>，因为m_ids是当前<strong>活跃事务</strong>的ID集合，在<code>min_trx_id</code>到<code>max_trx_id</code>即可能有<strong>活跃事务</strong>，也可能有<strong>非活跃事务</strong>。</p>
</blockquote>
<p><strong>当一个事务需要读取一条记录时，需要遵循以下四条规则进行读取（非常重要）：</strong></p>
<ol type="1">
<li><p><code>DB_TRX_ID == creator_trx_id</code>时，说明该数据就是当前事务更改的，<strong>可以访问该版本</strong>。</p></li>
<li><p><code>DB_TRX_ID &lt; min_trx_id</code>时，比最小活跃事务ID小，说明当前事务已经提交了，<strong>可以访问该版本</strong>。</p></li>
<li><p><code>DB_TRX_ID &gt; max_trx_id</code>时，比预分配事务ID大，说明当前事务在ReadView生成后才开始，还没有提交<strong>不能访问该版本</strong>。</p></li>
<li><p><code>min_trx_id &lt;= DB_TRX_ID &lt;= max_trx_id</code>时，<strong>如果DB_TRX_ID不在m_ids中，即当前事务已经提交了，可以访问该版本。</strong></p></li>
</ol>
<p>看完这些规则我们可以总结以下规律：</p>
<ol type="1">
<li>当前事务可以读取自己更改的记录，对应第一条规则</li>
<li>只有一个事务提交了，才能去读取该事务ID下的版本记录（保证事务的隔离性，防止脏读），对应第二、三、四条规则</li>
</ol>
<h2 id="mvcc的执行流程">3.MVCC的执行流程</h2>
<p>这里承接第二部分举过的案例，来具体分析事务5在<strong>不同隔离级别</strong>两次<strong>查询id为10的记录</strong>时，分别会读取哪个版本的数据。学会这个案例之后，就能理解MVCC如何解决<strong>不可重复读</strong>和<strong>幻读</strong>的问题。</p>
<h3 id="rc隔离级别">RC隔离级别</h3>
<p>在RC隔离级别下，事务每一次执行快照读时都会生成一次ReadView。</p>
<p>在第一次查询时，还未提交的事务有3、4、5，那么m_ids（活跃事务ID集合）为{3,4,5}，min_trx_id（最小活跃事务ID）为3，max_trx_id（预提交事务ID）为5+1=6，creator_trx_id（事务创建者ID）为5。</p>
<p>在第二次查询时，还未提交的事务有4、5，那么m_ids（活跃事务ID集合）为{4,5}，min_trx_id（最小活跃事务ID）为4，max_trx_id（预提交事务ID）为5+1=6，creator_trx_id（事务创建者ID）为5。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291855687.png"></p>
<h3 id="rr隔离级别">RR隔离级别</h3>
<p>在RR隔离级别下，仅在事务中<strong>第一次执行快照读</strong>时生成ReadView，后续复用该ReadView。</p>
<p>在第一次查询时，还未提交的事务有3、4、5，那么m_ids（活跃事务ID集合）为{3,4,5}，min_trx_id（最小活跃事务ID）为3，max_trx_id（预提交事务ID）为5+1=6，creator_trx_id（事务创建者ID）为5。</p>
<p>在第二次查询时，直接复用ReadView。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291900296.png"></p>
<h3 id="读取版本记录">读取版本记录</h3>
<p><strong>在读取版本记录时，需要根据DB_TRX_ID匹配ReadView的读取规则，判断当前记录对DB_TRX_ID对应的事务是否可见，如果可见，直接读取当前版本，如果不可见，则读取前一个undo
log记录继续进行匹配。</strong></p>
<p>我们以第一个ReadView举例，当前undo log版本链和读视图如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291803408.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202407291907166.png"></p>
<p>当DB_TRX_ID为4，存在于活跃事务列表中，因此不可以读取该行数据，需要向前找DB_TRX_ID为3的记录。</p>
<p>当DB_TRX_ID为3时，同样存在于活跃事务列表，因此不可以读取该行数据，需要向前找DB_TRX_ID为2的记录。</p>
<p>当DB_TRX_ID为2时，发现DB_TRX_ID&lt;min_trx_id，符合规则，因此可以读取该行记录。</p>
<p>最后的读取结果为：</p>
<table>
<thead>
<tr class="header">
<th>10</th>
<th>20</th>
<th>Jack</th>
<th>2</th>
<th>0x00001</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="mvcc小结">4.MVCC小结</h2>
<h3 id="mvcc解决不可重复读">MVCC解决不可重复读</h3>
<blockquote>
<p>RC隔离级别</p>
</blockquote>
<p>在RC读取已提交下，事务每一次执行快照读时都会生成一次ReadView，这也就<strong>造成了每次读取就有不同
ReadView</strong>，那么就会读到已提交的事务修改的内容，不能解决不可重复读的问题。</p>
<blockquote>
<p>RR隔离级别</p>
</blockquote>
<p>解决 RR 不可重复读主要靠
Readview，在隔离级别为可重复读时，仅在事务中<strong>第一次执行快照读</strong>时生成ReadView，后续复用该ReadView。由于后续<strong>复用了
ReadView，所以数据对当前事务的可见性和第一次是一样的</strong>，所以从
undo log
中读到的数据快照和第一次是一样的，即便过程中有其他事务修改也读不到。因此解决了不可重复读的问题。</p>
<h3 id="mvcc解决幻读">MVCC解决幻读</h3>
<p><code>InnoDB</code>存储引擎在 RR 级别下通过
<strong><code>MVCC</code>和
<code>Next-key Lock</code>（临键锁）</strong> 来解决幻读问题：</p>
<p><strong>1、执行快照读</strong></p>
<p>在<strong>快照读</strong>的情况下，RR
隔离级别使用MVCC，只会在事务开启后的第一次查询生成
<code>Read View</code> ，并使用至事务提交。所以<strong>在生成
<code>Read View</code>
之后其它事务所做的更新、插入记录版本对当前事务并不可见</strong>，实现了可重复读和防止快照读下的
“幻读”。</p>
<p><strong>2、执行当前读</strong></p>
<p>在<strong>当前读</strong>的情况下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读。<code>InnoDB</code>
使用<code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL】索引概念解析</title>
    <url>/2024/08/01/%E3%80%90MySQL%E3%80%91%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="什么是索引">1.什么是索引？</h2>
<p><strong>MySQL中的索引是一种数据结构，用于帮助MySQL数据库管理系统快速查询数据。索引的主要目的是提高数据检索的速度，减少数据库系统需要扫描的数据量。</strong></p>
<p>优点：</p>
<ol type="1">
<li>索引可以极大的提高数据检索效率，降低数据库IO成本</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，减少CPU的消耗</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>创建索引需要消耗物理空间。对于大型数据库，索引可能会占用相当大的磁盘空间。</li>
<li>创建索引和维护索引需要消耗时间，降低表的更新效率。对表中数据进行增删改操作时，那么索引也需要动态的修改，会降低
SQL 执行效率。</li>
</ol>
<p>适用场景：</p>
<ol type="1">
<li>具有<strong>唯一性约束的字段</strong>，比如商品编码，可以适用唯一性索引</li>
<li><strong>频繁使用的列</strong>，如主键、外键</li>
<li>经常用于<strong>WHERE</strong>查询条件的字段，如果查询条件不是⼀个字段，可以建⽴联合索引。</li>
<li>用于<strong>GROUP BY</strong>或<strong>ORDER
BY</strong>中的字段，由于索引基于B+树实现，会自动维护数据的有序性，降低数据排序的成本。</li>
</ol>
<p>不适用场景：</p>
<ol type="1">
<li><p><strong>WHERE</strong>、<strong>GROUP BY</strong>或<strong>ORDER
BY</strong>用不到的字段，索引的作用是快速定位，用不到的话会额外占用空间</p></li>
<li><p>存在<strong>大量重复元素</strong>的字段，如性别，无论怎么搜索可能只会得到一半的数据。</p></li>
<li><p><strong>表数据太少</strong>的时候，无需创建索引。</p></li>
<li><p><strong>频繁修改的列</strong>，当对表中数据进行增删改操作时，由于索引需要维护B+树的有序性，会频繁的创建索引，影响数据库的性能。</p></li>
</ol>
<h2 id="索引结构选型">2.索引结构选型</h2>
<p>B+
树非常适合作为数据库索引结构，特别是在处理大量数据的场景下，能够提供高效的查询、插入和删除操作，并且支持范围查询和顺序扫描。这些特性使得
B+ 树成为 MySQL 等数据库系统中首选的索引数据结构。</p>
<p>下面将针对不同的数据结构进行分析，以说明B+树为何能在众多数据结构中脱颖而出。</p>
<h3 id="hash表">Hash表</h3>
<p>MySQL 的 InnoDB
存储引擎不直接支持常规哈希索引，但有一种<strong>自适应哈希索引</strong>（Adaptive
Hash Index）。这种索引结合了 B+
树和哈希索引的特点，适应实际数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的
B+ 树结构，存储多个键值对，减少了哈希冲突，提高了效率。</p>
<p>MySQL
没有采用哈希索引作为主要索引结构，主要因为哈希索引不支持顺序和范围查询。此外，每次
IO 只能取一个值，限制了查询性能。</p>
<h3 id="二叉查找树bst">二叉查找树(BST)</h3>
<p>二叉查找树的性能非常依赖于它的平衡程度。</p>
<ul>
<li><strong>平衡时</strong>：查询时间复杂度为 O(log N)，效率较高。</li>
<li><strong>不平衡时</strong>：最坏情况下退化为线性链表，查询效率降至
O(N)。</li>
</ul>
<h3 id="avl树">AVL树</h3>
<p>AVL
树是一种<strong>高度平衡二叉树</strong>，保证任何节点的左右子树高度之差不超过
1，查找、插入和删除的时间复杂度均为 O(log N)。AVL
树通过四种旋转操作（LL、RR、LR、RL）保持平衡，但频繁的旋转操作增加了计算开销，降低了数据库写操作的性能。</p>
<p>每个 AVL 树节点仅存储一个数据，每次磁盘 IO
只能读取一个节点的数据，需要多次 IO 查询多个节点的数据，影响了性能。</p>
<h3 id="红黑树">红黑树</h3>
<p>红黑树是一种自平衡二叉查找树，通过颜色变换和旋转操作保持平衡，具有以下特点：</p>
<ol type="1">
<li>每个节点非红即黑；</li>
<li>根节点总是黑色；</li>
<li>每个叶子节点是黑色的空节点（NIL）；</li>
<li>红色节点的子节点必须是黑色；</li>
<li>从任意节点到叶子节点的每条路径包含相同数量的黑色节点。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/red-black-tree.png"></p>
<p><strong>红黑树追求的是大致平衡</strong>，查询效率略低于 AVL
树，因为红黑树的平衡性较弱，可能导致树的高度较高，需要多次磁盘 IO
操作。这也是 MySQL
没有选择红黑树的原因之一。但红黑树的插入和删除操作效率高，因为只需进行
O(1) 次数的旋转和变色操作，保持基本平衡状态。</p>
<p><strong>红黑树广泛应用于 TreeMap、TreeSet 和 JDK1.8 的 HashMap
底层，在内存中的表现非常优异。</strong></p>
<h3 id="b树b树">B树&amp;B+树</h3>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B
树的一种变体。B 树和B+ 树中的 B 是 <code>Balanced</code>
（平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree
作为索引结构。</p>
<blockquote>
<p><strong>B 树&amp;B+ 树两者有何异同呢？</strong></p>
</blockquote>
<ol type="1">
<li><strong>存储方式不同</strong></li>
</ol>
<p>B
树的所有节点既存放键（key）也存放数据（data），而B+树只有叶子节点存放
key 和 data，非叶子节点只存放 key。</p>
<ol start="2" type="1">
<li><strong>单点查询稳定性不同</strong></li>
</ol>
<p>B
树的查询波动较大，因为每个节点既存放索引又存放记录，有时访问到非叶子节点就能找到数据，有时需要访问叶子节点才能找到。</p>
<p>B+ 树的非叶子节点仅存放索引，因此可以存放更多的索引，使得 B+ 树比 B
树更「矮胖」，查询底层节点的磁盘 I/O 次数更少。</p>
<ol start="3" type="1">
<li><strong>插入和删除效率不同</strong></li>
</ol>
<ul>
<li>在B树中，当内部节点需要删除或插入时，可能会涉及到多个子节点的调整。由于B树的非叶子节点也存储数据，因此分裂或合并操作需要确保数据的完整性和树的平衡。</li>
<li>相比之下，B+树的非叶子节点只存储键信息，不存储实际的数据。因此，在分裂或合并非叶子节点时，只需要处理键信息，这使得操作相对简单且高效。并且，B+树的叶子节点包含所有实际的数据，并且它们之间通过指针相连。这使得在删除节点时，可以更容易地重新组织数据以保持树的平衡。</li>
</ul>
<ol start="4" type="1">
<li><strong>范围查询效率不同</strong></li>
</ol>
<p>B+
树支持范围查询。进行范围查找时，从根节点遍历到叶子节点即可，因为数据都存储在叶子节点上，且叶子节点通过指针连接，便于范围查找。</p>
<h2 id="索引的类型">3.索引的类型</h2>
<p>按照底层存储方式角度划分：</p>
<ul>
<li>聚簇索引（聚集索引）：索引结构和数据<strong>一起存放</strong>的索引，<strong>只有InnoDB
中的主键索引属于聚簇索引</strong>。</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据<strong>分开存放</strong>的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL
的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>
</ul>
<p>按照应用维度划分：</p>
<h3 id="主键索引">主键索引</h3>
<p>加速查询 + 列值唯一 + 不可以有NULL + 表中只有一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="普通索引">普通索引</h3>
<p>加速查询 + 列值可以重复 + 可以有NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON tb_user(name);</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引">唯一索引</h3>
<p>加速查询 + 列值唯一 + 可以有NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_email ON tb_user(email);</span><br></pre></td></tr></table></figure>
<h3 id="联合索引">联合索引</h3>
<p>多个列组成一个索引，专门用于组合搜索，其效率大于多个单列索引的合并效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_cover ON tb_user(name, email);</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引">覆盖索引</h3>
<p>一个索引包含所有需要查询的字段的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_cover ON tb_user(name, email);</span><br><span class="line"></span><br><span class="line">SELECT name, email FROM tb_user WHERE name = &#x27;John&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="全文索引">全文索引</h3>
<p>对文本的内容进行分词，进行搜索。目前只有
<code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code>
列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如
ElasticSearch 代替。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    title VARCHAR(200),</span><br><span class="line">    content TEXT,</span><br><span class="line">    FULLTEXT (title, content)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL】全面剖析索引失效、回表查询与索引下推</title>
    <url>/2024/08/03/%E3%80%90MySQL%E3%80%91%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E3%80%81%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</url>
    <content><![CDATA[<h2 id="索引失效的情况">1.索引失效的情况</h2>
<p>以tb_user表举例，id为主键索引、name和phone字段上建立了一个普通索引，name和phone均为varchar类型。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021323066.png"></p>
<h3 id="索引列运算">索引列运算</h3>
<blockquote>
<p><strong>当在 <code>WHERE</code> 子句或 <code>JOIN</code>
子句中对列使用函数或表达式时，索引会失效。</strong></p>
</blockquote>
<p>执行以下语句，可以发现执行计划中索引已经生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021307931.png"></p>
<p>如果我们使用substring函数只取前三个字符，则索引失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where <span class="title function_">SUBSTRING</span><span class="params">(name, <span class="number">1</span>, <span class="number">3</span>)</span> = <span class="string">&#x27;Jac&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以发现type为ALL，key为null，<strong>说明本次查询没有执行索引，走的是全表扫描</strong>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021308061.png"></p>
<h3 id="隐式类型转换">隐式类型转换</h3>
<blockquote>
<p><strong>当列的类型和查询中的值类型不同时，MySQL
可能会进行隐式类型转换，导致索引失效。</strong></p>
</blockquote>
<p>执行以下语句，phone为varchar类型，如果等号右侧不加引号，则发生隐式转换，索引失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user <span class="type">where</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="number">13016161546</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021316202.png"></p>
<h3 id="前导通配符查询">前导通配符查询</h3>
<blockquote>
<p><strong>使用通配符查询时，如果通配符在字符串的前面，索引会失效。</strong></p>
</blockquote>
<p>执行以下语句，查询name字段后缀为<code>ack</code>的数据，索引失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where name like <span class="string">&#x27;%ack&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021316202.png"></p>
<h3 id="or连接条件">or连接条件</h3>
<blockquote>
<p><strong>当 or 条件中某个列没有索引时，索引会失效</strong></p>
</blockquote>
<p>执行以下语句，因为name和phone都是索引字段，索引正常生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;Jack&#x27;</span> <span class="type">or</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="string">&#x27;15846234682&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021325531.png"></p>
<p>执行以下语句，因为age字段没有设置索引，所以索引失效查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;Jack&#x27;</span> <span class="type">or</span> <span class="variable">age</span> <span class="operator">=</span> <span class="string">&#x27;20&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021328278.png"></p>
<h3 id="最左匹配原则">最左匹配原则</h3>
<blockquote>
<p><strong>对于联合索引（多个列组成的索引），如果查询条件不包含索引的最左前缀部分，索引会失效。</strong></p>
<p><strong>TIPS：</strong>这里指的最左是联合索引中的顺序，而不是SQL语句查询条件的顺序。</p>
</blockquote>
<p>在本例中，我们新建一个表<code>table</code>，给字段col1、col2、age建立联合索引（col1,
col2, age）</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021358430.png"></p>
<ul>
<li><strong>遵循最左匹配发展</strong></li>
</ul>
<p>按照最左前缀法则查询数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from `table` <span class="type">where</span> <span class="variable">col1</span> <span class="operator">=</span> <span class="string">&#x27;user&#x27;</span> <span class="type">and</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span> <span class="type">and</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<p>可以发现，联合索引的总长度为107</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021400955.png"></p>
<ul>
<li><strong>不遵循最左匹配法则（查询条件中不包括联合索引的最左前缀部分）</strong></li>
</ul>
<p>如果不按照最左匹配法则，直接查询col2的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from `table` <span class="type">where</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>本次查询走的是<code>index</code>全索引扫描，性能上要低于<code>ref</code>。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021351634.png"></p>
<ul>
<li><strong>不遵循最左匹配法则（查询条件中包含<code>&gt; &lt;</code>范围查询）</strong></li>
</ul>
<p>如果查询条件中使用了<code>&gt; &lt;</code>，则不遵循最左匹配法则（可以使用其他范围查询符号），<strong>范围查询右侧的索引失效。</strong></p>
<p>执行以下语句，由于age在联合索引（col1, col2,
age）中是最后一个，所以不存在其右侧索引失效的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">explain select * from `table` <span class="type">where</span> <span class="variable">col1</span> <span class="operator">=</span> <span class="string">&#x27;user&#x27;</span> <span class="type">and</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span> and age &gt; <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021411852.png"></p>
<p>但是如果我们将col2和age调换顺序，改为（col1, age,
col2），则col2索引失效。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021412826.png"></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021412887.png"></p>
<h3 id="数据分布情况">数据分布情况</h3>
<blockquote>
<p><strong>MySQL会根据表中数据的分布情况，决定是否使用索引</strong></p>
</blockquote>
<p>举一个简单的例子，如果表中的age字段最小值为10，查询条件为age &gt;=
10。则在查询时可能不会走索引，因为走索引和不走索引都需要查询表中的全部数据，不过判断一个语句是否走索引还是要根据<code>explain</code>关键字返回的结果进行判断。</p>
<h2 id="回表查询">2.回表查询</h2>
<p><strong>回表查询</strong>是指在使用<strong>辅助索引</strong>（二级索引）进行查询时，由于辅助索引中不包含查询所需的所有列数据，数据库必须通过索引找到对应的数据行位置，再去实际的数据表（即“回表”）中读取完整的数据行。<strong>这种操作会增加额外的
I/O
开销，因此回表查询通常比直接从索引中获取数据的查询更慢。</strong></p>
<h3 id="回表查询示例">回表查询示例</h3>
<p>假设有以下表数据，id为主键索引，name为普通索引。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021453416.png"></p>
<p><strong>主键索引</strong>（id）的索引结构如下图，在叶子节点中存储的是<strong>每一行的数据</strong>。如果我们直接根据id查询，就可以在遍历索引时直接拿到每一行的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_user where id = 2;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021459755.png"></p>
<p><strong>辅助索引</strong>（name）的索引结构如下，叶子节点存储的是该行的主键（id），如果需要查询该行的数据，则需要遍历索引后获得主键id，再根据这个主键id前往主键索引中查询，这个过程就是<strong>回表查询</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_user where name = &#x27;Arm&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408021503521.png"></p>
<h3 id="避免回表查询">避免回表查询</h3>
<p>避免回表查询很简单，只需要保证查询的列能够被索引结构覆盖即可。通过创建一个包含所有查询所需列的索引，数据库可以直接从索引中获取所有需要的数据，无需回表。</p>
<p><strong>覆盖索引</strong>（Covering
Index）是指查询所需的所有列都包含在同一个索引中，从而避免回表操作。这样可以显著提高查询性能。</p>
<p>比如我们直接使用以下语句，就可以避免回表查询，因为name索引中包含了name和id的数据，而无需回到数据库进行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from tb_user where name = &#x27;Arm&#x27;;</span><br><span class="line"></span><br><span class="line">select id, name from tb_user where name = &#x27;Arm&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="索引下推">3.索引下推</h2>
<p><strong>索引下推（Index Condition Pushdown，ICP）</strong>是 MySQL
5.6 及以上版本中引入的一种优化技术，用于提高使用索引查询的效率。ICP
可以减少回表操作（即从索引表跳回数据表读取完整行数据）的次数，从而提高查询性能。</p>
<p><strong>除了可以减少回表次数之外，索引下推还可以减少存储引擎层和
Server 层的数据传输量。</strong></p>
<h3 id="工作原理">工作原理</h3>
<p>在没有索引下推的情况下，MySQL 的查询执行流程通常是：</p>
<ol type="1">
<li><strong>索引扫描</strong>：存储引擎使用索引查找满足索引条件的记录。</li>
<li><strong>返回记录</strong>：将这些记录返回给 MySQL 服务器。</li>
<li><strong>行过滤</strong>：MySQL
服务器根据剩余的查询条件进一步过滤这些记录。</li>
</ol>
<p>使用索引下推后，MySQL
优化器会在索引扫描阶段<strong>尽可能多地应用查询条件</strong>，只有在通过索引扫描无法完全过滤的情况下，才进行回表操作。</p>
<h3 id="适用场景">适用场景</h3>
<p>索引下推在以下场景中尤其有效：</p>
<ol type="1">
<li><strong>范围查询</strong>：对索引列进行范围查询时，例如
<code>BETWEEN</code>、<code>&lt;</code>、<code>&gt;</code> 等。</li>
<li><strong>联合索引查询</strong>：在联合索引的前缀列上进行查询，并且查询条件涉及非索引列时。</li>
<li><strong>复杂条件查询</strong>：查询条件包含多个过滤条件时，例如
<code>AND</code>、<code>OR</code> 等。</li>
</ol>
<h3 id="示例">示例</h3>
<p>假设有一个包含联合索引 <code>idx_name_age</code> 的表
<code>tb_user</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    address VARCHAR(255),</span><br><span class="line">    INDEX idx_name_age (name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where name = &#x27;John&#x27; and age &gt; 30 and address like &#x27;%Street%&#x27;;</span><br></pre></td></tr></table></figure>
<p>在没有索引下推的情况下，MySQL 会：</p>
<ol type="1">
<li>使用索引 <code>idx_name_age</code> 找到 <code>name = 'John'</code>
的所有记录。</li>
<li>回表读取每一条记录的实际数据。</li>
<li>对回表后的数据应用剩余条件 <code>age &gt; 30</code> 和
<code>address LIKE '%Street%'</code> 进行过滤。</li>
</ol>
<p>在启用索引下推的情况下，MySQL 会：</p>
<ol type="1">
<li>使用索引 <code>idx_name_age</code> 找到 <code>name = 'John'</code>
且 <code>age &gt; 30</code> 的记录（在索引扫描阶段应用部分条件）。</li>
<li>仅对符合前两个条件的记录进行回表操作。</li>
<li>对回表后的数据应用剩余条件 <code>address LIKE '%Street%'</code>
进行最终过滤。</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL】慢sql查询优化</title>
    <url>/2024/08/04/%E3%80%90MySQL%E3%80%91%E6%85%A2sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="定位慢sql">定位慢sql</h1>
<h2 id="工具排查慢sql">工具排查慢sql</h2>
<ul>
<li>调试工具：Arthas</li>
<li>运维工具：Skywalking</li>
</ul>
<p>通过以上工具可以看到哪个接口比较慢，并且可以分析SQL具体的执行时间，定位到哪个sql出了问题。</p>
<h2 id="启用慢查询日志">启用慢查询日志</h2>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位:秒，默认10秒)的所有SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启MySQL慢日志查询开关</span></span><br><span class="line"><span class="string">slow_query_log=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢日志的时间为1秒，SQL语句执行时间超过1秒，就会视为慢查询，记录到慢查询日志中</span></span><br><span class="line"><span class="string">long_query_time=2</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，重启MySQL服务保证配置生效。</p>
<p>慢查询日志一般的返回结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time:2024-08-01T12:00:00.123456Z</span></span><br><span class="line"><span class="comment"># User@Host: root[root] @ localhost [] Id: 	8</span></span><br><span class="line"><span class="comment"># Query time:2.345678 Lock_time:0.012345 Rows sent:10 Rows examined: 100</span></span><br><span class="line"><span class="string">SET</span> <span class="string">timestamp=1650000000;</span></span><br><span class="line"><span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">orders</span> <span class="string">WHERE</span> <span class="string">status</span> <span class="string">=&#x27;pending&#x27;</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">gmt</span> <span class="string">created</span> <span class="string">DESC;</span></span><br></pre></td></tr></table></figure>
<p>需要关注以下内容：</p>
<ul>
<li><p><strong>Query_time（查询时间）</strong>：查询执行的总时间，单位为秒。是关键的指标，用于判断查询的性能。</p></li>
<li><p><strong>Lock_time（锁定时间）</strong>：表被锁定的时间，单位为秒。可以帮助判断是否存在锁等待问题。</p></li>
<li><p><strong>Rows_sent（发送的行数）</strong>：查询返回的行数。</p></li>
<li><p><strong>Rows_examined（检查的行数）</strong>：查询过程中检查的行数，用于判断查询的效率。</p></li>
</ul>
<h1 id="分析慢sql">分析慢sql</h1>
<h2 id="profile详情">profile详情</h2>
<p><code>SHOW PROFILE</code> 是 MySQL
提供的一种用于查看查询语句执行的详细步骤和资源消耗的工具。使用
<code>SHOW PROFILE</code>
命令可以帮助找出查询语句的瓶颈，优化查询性能。</p>
<blockquote>
<p><strong>启用 Profiling</strong></p>
</blockquote>
<p>在使用 <code>SHOW PROFILE</code> 之前，需要先启用 Profiling：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>执行查询</strong></p>
</blockquote>
<p>执行你想分析的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM your_table WHERE some_column = &#x27;some_value&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>查看 Profile 列表</strong></p>
</blockquote>
<p>使用以下命令查看刚才执行的查询的 Profile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure>
<p>这将显示一个查询 ID 列表及其对应的查询语句和总执行时间。</p>
<blockquote>
<p><strong>查看详细的 Profile 信息</strong></p>
</blockquote>
<p>使用 <code>SHOW PROFILE</code> 查看某个查询 ID 的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILE FOR QUERY query_id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>查看CPU信息</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILE CPU FOR QUERY query_id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>典型返回</strong></p>
</blockquote>
<p><strong>Status</strong>表示查询的不同执行阶段。<strong>Duration</strong>即每个阶段所用的时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+--------------------+----------+</span><br><span class="line">| Status             | Duration |</span><br><span class="line">+--------------------+----------+</span><br><span class="line">| starting           | 0.000002 |</span><br><span class="line">| waiting for data   | 0.000001 |</span><br><span class="line">| executing          | 0.003000 |</span><br><span class="line">| sending data       | 0.000003 |</span><br><span class="line">+--------------------+----------+</span><br></pre></td></tr></table></figure>
<h2 id="explain执行计划">explain执行计划</h2>
<p><code>explain</code> 是 MySQL 提供的一种用于分析和调试 SQL
查询的工具。</p>
<p>通过使用 <code>explain</code>，可以了解 MySQL
在执行查询时采用的具体执行计划，包括访问数据表的方式、使用的索引、连接表的顺序等信息。这些信息对于优化查询性能至关重要。</p>
<h3 id="基本概念">基本概念</h3>
<p><code>EXPLAIN</code> 执行计划支持
<code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>
以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code>
查询语句，要获取一条sql语句的执行计划，只需要在语句前加上<code>explain</code>关键字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain + sql语句;</span><br></pre></td></tr></table></figure>
<p>执行计划的返回结果一般是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | dept_emp | NULL       | ALL   | NULL            | NULL    | NULL    | NULL | 331143 |   100.00 | Using where |</span><br><span class="line">+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>
<p>返回结果中各字段的含义解释如下：</p>
<table>
<thead>
<tr class="header">
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr class="even">
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr class="odd">
<td>table</td>
<td>用到的表名</td>
</tr>
<tr class="even">
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr class="odd">
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr class="even">
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr class="odd">
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr class="even">
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr class="odd">
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr class="even">
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr class="odd">
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr class="even">
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<h3 id="字段释意">字段释意</h3>
<h4 id="id">id</h4>
<p>查询的序列标识符，用于表示查询的执行顺序。值越大，优先级越低，执行顺序越靠后。</p>
<h4 id="select_type">select_type</h4>
<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>
<ul>
<li><code>SIMPLE</code>: 简单查询，不包含子查询或 UNION。</li>
<li><code>PRIMARY</code>: 最外层的 SELECT 查询。</li>
<li><code>SUBQUERY</code>: 子查询中的第一个 SELECT。</li>
<li><code>DERIVED</code>: 派生表（子查询中的 FROM 子句）。</li>
<li><code>UNION</code>: UNION 操作中的第二个或后续的 SELECT 查询。</li>
<li><code>UNION RESULT</code>: UNION 的结果集。</li>
</ul>
<h4 id="table">table</h4>
<p>查询用到的表名。</p>
<h4 id="type重要">type（重要）</h4>
<p>查询执行的类型，描述了查询是如何执行的。常见的类型如下，这些类型的性能从最优到最差排序为：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></p>
<ul>
<li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如MyISAM），且表中只有一行记录的情况下，访问方法是
system ，是 const 的一种特例。</li>
<li><strong>const</strong>：常数索引扫描，表中只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
<li><strong>eq_ref</strong>：唯一索引扫描。在连接查询时，被连接表针对连接表中的每一行只会返回最多一行结果。它是除了
<code>system</code> 和 <code>const</code>
之外最优的连接方式，通常用于使用主键或唯一索引的所有字段作为连接条件。</li>
<li><strong>ref</strong>：普通索引扫描，会扫描索引树的一部分来查找匹配的行。</li>
<li><strong>range</strong>：范围扫描，只会遍历索引树的一个范围来查找匹配的行。</li>
<li><strong>index</strong>：全索引扫描，会遍历整个索引树来查找匹配的行。</li>
<li><strong>ALL</strong>：全表扫描，将遍历整张表来查找匹配的行。</li>
</ul>
<h4 id="possible_keys">possible_keys</h4>
<p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为
NULL ，则表示没有索引可以使用。</p>
<h4 id="key重要">key（重要）</h4>
<p>key 列表示 MySQL 实际使用到的索引。如果为
NULL，则表示未用到索引。</p>
<h4 id="key_len重要">key_len（重要）</h4>
<p>key 列表示 MySQL 实际使用到的索引的长度。</p>
<h4 id="extra重要">Extra（重要）</h4>
<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解
MySQL 到底是如何执行查询的。常见的值如下：</p>
<ul>
<li><strong>Using
index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>
<li><strong>Using index
condition</strong>：表示查询优化器选择使用了<strong>索引下推</strong>这个特性。</li>
<li><strong>Using where</strong>：表明查询使用了 WHERE
子句进行条件过滤，通常是因为使用非索引列查询或者未使用覆盖索引。</li>
<li><strong>Using where; Using
index</strong>：查询的列使用了覆盖索引，但where筛选条件不是联合索引的前导列或者只是前导列的一个范围。</li>
<li><strong>Using
filesort</strong>：在排序时使用了文件排序而不是索引排序，通常是因为无法使用索引进行排序。</li>
<li><strong>Using temporary</strong>：MySQL
需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>
<li><strong>Using join buffer (Block Nested
Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL
会先将驱动表读出来放到 join buffer
中，再遍历被驱动表与驱动表进行查询。</li>
</ul>
<h1 id="优化慢sql">优化慢sql</h1>
<h2 id="sql优化方案">sql优化方案</h2>
<p>根据<code>explain</code>执行计划的返回结果，我们可以根据以下字段进行sql优化：</p>
<ul>
<li>通过<code>key</code>和<code>key_len</code>检査<strong>是否命中了索引</strong>（索引本身存在是否有失效的情况）</li>
<li>通过<code>type</code>字段查看sql是否有进一步的优化空间，<strong>是否存在全索引扫描或全表扫描</strong></li>
<li>通过<code>extra</code>字段判断，<strong>是否出现了回表的情况</strong>，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
<h3 id="索引不合理">索引不合理</h3>
<ul>
<li>回表查询，查询的字段没有使用覆盖索引，需要回表查询数据。</li>
<li>索引失效，如查询条件中使用了函数或者运算、OR连接条件中没有使用索引、不符合最左匹配原则、使用了前导通配符、查询条件使用了隐式的类型转换等。</li>
</ul>
<h3 id="多表join">多表join</h3>
<ol type="1">
<li>在内存中做关联，可以先从数据库中把数据查询出来，然后在代码中进行二次查询，进行数据的关联。</li>
<li>数据冗余，可以把一些重要的数据在表中做冗余，避免使用多表查询。</li>
</ol>
<h3 id="查询字段过多">查询字段过多</h3>
<ul>
<li>查询无关字段，比如使用了<code>select *</code>查询了无关字段。</li>
<li>如果确实需要查询大量字段，可以考虑做分库分表。</li>
</ul>
<h3 id="数据库连接数不足">数据库连接数不足</h3>
<ul>
<li>业务量太大，可以用分库减少单库的业务压力。</li>
<li>存在一些慢SQL和长事务导致的，需要具体分析。</li>
</ul>
<h2 id="深分页优化查询">深分页优化查询</h2>
<h3 id="传统分页">传统分页</h3>
<p><strong>传统分页通常使用 <code>OFFSET</code> 和 <code>LIMIT</code>
来实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name ORDER BY column_name LIMIT 10 OFFSET 1000;</span><br></pre></td></tr></table></figure>
<p>这种方法对于小数据集或页数较小时效果较好，但在数据量非常大的情况下，<code>OFFSET</code>
的值越大，数据库需要扫描的行数就越多，性能会急剧下降。</p>
<h3 id="深分页">深分页</h3>
<p><strong>深分页通过避免使用 <code>OFFSET</code>
来提高性能</strong></p>
<p><strong>1.覆盖索引+子查询：</strong>
这种方法<strong>通过子查询使用覆盖索引快速定位到分页的起始位置</strong>，外部查询从该位置获取实际数据，避免大量数据扫描和回表操作。</p>
<p>如本例中通过子查询定位到了第100001页的起始位置，向后获取100行数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id &gt; (SELECT id FROM users ORDER BY id LIMIT 100000, 1) LIMIT 100;</span><br></pre></td></tr></table></figure>
<p>这种方法避免了大量数据扫描，<strong>适用于有索引列</strong>的情况。</p>
<p><strong>2.存储分页结果：</strong>
另一种方法是将分页结果存储在缓存（如
Redis）或临时表中，从而避免频繁查询数据库。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 第一次查询并缓存结果</span><br><span class="line">SELECT * FROM table_name ORDER BY column_name LIMIT 1000;</span><br><span class="line">-- 将结果缓存起来，随后从缓存中进行分页</span><br></pre></td></tr></table></figure>
<p>这种方法<strong>适用于需要多次访问相同分页结果</strong>的场景。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】Java内存区域图文详解</title>
    <url>/2024/08/07/%E3%80%90JVM%E3%80%91Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="jvm运行时区域总览">1.JVM运行时区域总览</h2>
<p>Java 虚拟机在执行 Java
程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p>
<p>JVM运行时区域也成为<strong>Java内存区域</strong>。
在讨论Java内存模型时，通常将其分为线程共享区域和线程私有区域：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/15a805d278b831d1097145a80c23c046.png"></p>
<h2 id="线程私有区域">2.线程私有区域</h2>
<h3 id="程序计数器">2.1.程序计数器</h3>
<p>程序计数器是一块较小的<strong>内存空间</strong>，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>程序计数器主要有两个作用：</p>
<ol type="1">
<li><p>字节码解释器通过<strong>改变程序计数器</strong>来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p></li>
<li><p>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p></li>
</ol>
<p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code>
的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="java虚拟机栈">2.2.Java虚拟机栈</h3>
<p>JVM栈可以说是 JVM 运行时数据区域的一个核心，除了一些 Native
方法调用是通过本地方法栈实现的，其他<strong>所有的 Java
方法调用都是通过JVM栈</strong>来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p>
<p><strong>从方法调用直至执行完成的过程，就对应着一个栈帧在 Java
虚拟机栈中入栈和出栈的过程。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4194bd2ac809db04d8eeaae1afa4ff6f.png"></p>
<blockquote>
<p>局部变量表</p>
</blockquote>
<p><strong>局部变量表</strong>
主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference
类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0d7cf1a84b68da00f66296e4e90e433.png"></p>
<blockquote>
<p>操作数栈</p>
</blockquote>
<p><strong>操作数栈</strong>
主要作为方法调用的中转站使用，用于存放方法执行过程中产生的<strong>中间计算结果</strong>。另外，计算过程中产生的<strong>临时变量</strong>也会放在操作数栈中。</p>
<blockquote>
<p>动态链接</p>
</blockquote>
<p><strong>动态链接</strong>
主要服务一个方法需要调用其他方法的场景。Class
文件的常量池里保存有大量的<strong>符号引用</strong>，比如方法引用的符号引用。动态链接的作用就是为了<strong>将符号引用转换为调用方法的直接引用</strong>，这个过程也被称为
<strong>动态连接</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5f8bb04546c685a25c62a0668c9ab6fc.png"></p>
<blockquote>
<p>方法返回地址</p>
</blockquote>
<p>方法返回地址是<strong>当前方法执行完成后</strong>，线程应该跳转到的<strong>下一条指令</strong>的地址。这个返回地址实际上是保存在栈帧中的一个特殊位置，用于在方法执行完毕后恢复程序的执行流程。</p>
<h3 id="本地方法栈">2.3.本地方法栈</h3>
<p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行
Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native
方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现
<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>
两种错误。</p>
<h2 id="线程共享区域">3.线程共享区域</h2>
<h3 id="堆">3.1.堆</h3>
<p>Java 虚拟机所管理的内存中最大的一块，Java
堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java
堆是<strong>垃圾收集器</strong>管理的<strong>主要区域</strong>，因此也被称作
<strong>GC 堆（Garbage Collected
Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以
Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old
等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p><strong>JDK 8 版本之前，堆内存被通常分为下面三部分：</strong></p>
<ol type="1">
<li>新生代(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ol>
<p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间)
取代，元空间使用的是本地内存。</strong></p>
<p>下图所示的 Eden 区、两个 Survivor
区都属于新生代，中间一层属于老年代，最下面一层属于元空间。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b70bd47c8d208f98a0ce75eb6d40895c.png"></p>
<h4 id="字符串常量池">字符串常量池</h4>
<p><strong>字符串常量池</strong> 是 JVM
为了提升性能和减少内存消耗针对字符串（String
类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p>JDK1.7
之前，字符串常量池存放在永久代，JDK1.7之后<strong>字符串常量池、静态变量和常量</strong>从永久代移动了
Java 堆中。</p>
<blockquote>
<p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>
</blockquote>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集
(Full GC)的时候才会被执行 GC。Java
程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<h3 id="方法区">3.2.方法区</h3>
<p><strong>方法区是JVM规范定义的一块用于存储类的元数据、常量、静态变量、即时编译器(JIT编译器)编译后的代码等数据的内存区域。</strong></p>
<p><strong>当虚拟机要使用一个类时，它需要读取并解析 Class
文件获取相关信息，再将信息存入到方法区。</strong>
方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<blockquote>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong>
方法区和永久代以及元空间的关系很像 Java
中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是
HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8
之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/97c6b050e30b12ad47312b5af8de1a6b.png"></p>
<blockquote>
<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace)
呢?</strong></p>
</blockquote>
<p>1、永久代有 JVM
本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code>
标志设置<strong>最大元空间大小</strong>，默认值为
unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code>
调整标志定义<strong>初始元空间大小</strong>，如果未指定此标志，则
Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由
<code>MaxPermSize</code> 控制了,
而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
<blockquote>
<p><strong>在JDK
1.8中，运行时常量池和字符串常量池逻辑上属于方法区，但是实际存放在堆内存中</strong>。</p>
</blockquote>
<h4 id="运行时常量池">运行时常量池</h4>
<p>JVM的运行时常量池是方法区的一部分，它主要用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。这些字面量和符号引用是在<strong>类加载</strong>的过程中，<strong>从Class文件的常量池中加载到方法区的运行时常量池中的。</strong></p>
<p><strong>字面量是源代码中的固定值的表示法</strong>，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的<strong>符号引用</strong>包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p>
<p><strong>常量池会在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出
<code>OutOfMemoryError</code> 错误。</p>
<blockquote>
<p><strong>Class常量池：</strong>
可以理解为是<strong>Class文件</strong>中的资源仓库。
Class文件中除了包含<strong>类的版本、字段、方法、接口等描述信息</strong>外，还有就是<strong>常量池</strong>(constant
pool table)，用于存放编译器生成的<strong>各种字面量和符号引用</strong>。
Class是用来保存常量的一个媒介场所，并且是一个中间场所。<strong>Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】深入JIT优化机制</title>
    <url>/2024/08/08/%E3%80%90JVM%E3%80%91%E6%B7%B1%E5%85%A5JIT%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="jit优化技术">1.JIT优化技术</h2>
<p>在将高级语言转化为计算机可识别的机器语言时，常用的两种方式是编译和解释。Java在编译过程中，首先将代码编译成字节码。但是，字节码并不能直接在机器上执行。因此，JVM中内置了解释器（Interpreter），它在<strong>运行时将字节码逐行翻译成机器码</strong>并执行。</p>
<p>然而，解释器的执行方式是一边翻译，一边执行，导致执行效率较低。<strong>为了提高效率，HotSpot
JVM引入了JIT（Just-In-Time）编译技术。</strong></p>
<p>有了JIT技术后，JVM仍然通过解释器进行初始执行。但当JVM发现某个方法或代码块被频繁执行时，它将其标记为“热点代码”（Hot
Spot
Code）。JIT随后将这些热点代码编译为机器码，并进行优化。优化后的机器码被缓存起来，以便下次直接使用，从而显著提升执行效率。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bf7e979c2922d5887d26966c500c97c8.png"></p>
<h2 id="热点检测">2.热点检测</h2>
<p>上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测，有以下两种</p>
<ol type="1">
<li><p><strong>基于采样的方式探测：</strong>
周期性检测各个线程的栈顶，发现某个方法经常出现在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因千扰热点探测。</p></li>
<li><p><strong>基于计数器的热点探测：</strong>
采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。</p>
<p>在HotSpot虚拟机中使用的是第二种一一基于计数器的热点探测方法，因此它为每个方法准备了两个计数器:
方法调用计数器和回边计数器。</p>
<p>方法计数器。顾名思义，就是记录一个方法被调用次数的计数器</p>
<p>回边计数器。是记录方法中的for或者while的运行次数的计数器</p></li>
</ol>
<h2 id="编译优化">3.编译优化</h2>
<h3 id="逃逸分析">逃逸分析</h3>
<ol type="1">
<li><strong>全局逃逸：</strong>对象超出了方法或线程的范围，比如被存储在<strong>静态字段</strong>或<strong>作为方法的返回值</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalEscapeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> object staticObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">globalEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> 0bject();<span class="comment">// 这个对象赋值给静态字段，因此它是全局逃逸的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> stringBuffer <span class="title function_">craetestringBuffer</span><span class="params">(string sl,string s2)</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">stringBuffer</span>();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如我们新建的staticObject就是全局逃逸的。以及下面的方法中的sb对象，也是全局逃逸的。</p>
<ol start="2" type="1">
<li><strong>参数逃逸：</strong>
对象被作为参数传递或被参数引用，但在方法调用期间不会全局逃逸。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgEscapeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">obiect</span> <span class="variable">localobject</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">object</span>();</span><br><span class="line">		methodB(localobject);<span class="comment">//localobject作为参数传递，但不会从methodB中逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">(object param)</span>&#123;</span><br><span class="line">        <span class="comment">//在这里使用param</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如传递到methodB中的param对象，就是发生了参数逃逸的。因为他从methodA中逃逸到了methodB中</p>
<ol start="3" type="1">
<li><strong>无逃逸：</strong>
对象可以被标量替换，意味着它的内存分配可以从生成的代码中移除。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title function_">createstringBuffer</span><span class="params">(string s1,string s2)</span> &#123;</span><br><span class="line">    <span class="type">stringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">stringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.tostring();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的sb，就没有发生逃逸，因为这个对象本身没有作为参数传递，也没有被当做方法返回值，并没有赋值给静态变量。</p>
<p><strong>在Java中，不同的逃逸状态影响JIT
(即时编译器)的优化策略：</strong></p>
<ol type="1">
<li><p><strong>全局逃逸：</strong>
由于对象可能被多个线程访问，全局逃逸的对象一般不适合进行栈上分配或其他内存优化。但JIT可能会进行其他类型的优化，如<strong>方法内联</strong>或<strong>循环优化</strong>。</p></li>
<li><p><strong>参数逃逸：</strong>
这种情况下，对象虽然作为参数传递，但不会被方法外部的代码使用。JIT可以对这些对象进行一些优化，例如<strong>锁消除</strong>。</p></li>
<li><p><strong>无逃逸：</strong>
这是最适合优化的情况。JIT可以采取多种优化措施，如在<strong>栈上分配</strong>内存，消除锁甚至完全消除对象分配
<strong>(标量替换)</strong>。这些优化可以显著提高性能，减少垃圾收集的压力。</p></li>
</ol>
<h3 id="方法内联">方法内联</h3>
<p>方法内联是Java中的一个优化技术，即时编译器JIT用它来提高程序的运行效率。在Java中，方法内联意味着将一个方法的代码直接插入到调用它的地方，从而<strong>避免了方法调用的开销</strong>。这种优化对于小型且频繁调用的方法特别有用。</p>
<h3 id="锁消除">锁消除</h3>
<p>锁消除是 JIT
编译器在编译期间通过分析代码的同步块，判断是否存在锁竞争的可能性。如果<strong>某个锁在多线程环境下不存在竞争，那么它就可以在生成的机器码中消除这些锁操作</strong>，以减少不必要的开销。</p>
<h3 id="栈上分配">栈上分配</h3>
<p><strong>栈上分配的好处：</strong></p>
<ol type="1">
<li><strong>减少GC压力</strong>：对象分配在栈上，当方法执行完毕后，栈上的内存会自动释放，不需要垃圾回收（GC）来管理，从而减少了GC的压力。</li>
<li><strong>提高性能</strong>：栈上的内存分配和释放非常高效，因为它只是对栈指针进行简单的移动操作，而堆上的内存管理相对复杂，需要垃圾回收器的参与。</li>
</ol>
<blockquote>
<p><strong>Java中的对象一定在堆上分配内存吗?</strong></p>
</blockquote>
<p>不一定，在HotSpot虚拟机中，存在JIT优化的机制，JIT优化中可能会进行逃逸分析，当经过逃逸分析发现某个对象不会逃逸出当前方法（即它只在方法内部使用），那么这个对象就不会被分配到堆上，而是进行<strong>栈上分配</strong>。</p>
<h3 id="标量替换">标量替换</h3>
<p><strong>标量</strong>是指一个无法再分解成更小的数据的数据。<strong>Java中的原始数据类型就是标量</strong>。相对的，那些还可以分解的数据叫做聚合量，<strong>Java中的对象就是聚合量</strong>，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JIT</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis】持久化机制最全解析</title>
    <url>/2024/08/07/%E3%80%90Redis%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="rdb持久化">RDB持久化</h2>
<p>RDB全称Redis Database Backup
file（Redis数据备份文件）。通过<strong>将Redis数据集的快照保存到磁盘上的二进制文件中来实现</strong>。生成
RDB 文件的过程可以通过手动命令或自动触发。</p>
<h3 id="实现原理">实现原理</h3>
<p><strong>开始 BGSAVE</strong>：</p>
<ul>
<li>Redis 主进程接收到 <code>BGSAVE</code> 命令后，调用
<code>fork</code>
创建一个子进程，子进程会先复制主进程的页表（记录虚拟地址与物理地址的映射关系），而不是立即复制实际的内存数据。</li>
<li>在 fork 完成后，父子进程共享相同的内存页，子进程负责生成 RDB
文件，主进程可以继续处理客户端请求。</li>
</ul>
<p><strong>生成 RDB 文件</strong>：</p>
<ul>
<li>子进程根据页表，扫描 Redis
数据集，将每个键值对序列化为二进制格式，并写入到临时 RDB 文件中。</li>
<li>序列化后的数据被写入到一个临时 RDB 文件中，以避免影响现有 RDB
文件的使用。</li>
<li><strong>写时复制（Copy-On-Write, COW）</strong>：
<ul>
<li>在生成 RDB
文件的过程中，如果主进程执行了写操作（如插入、更新、删除数据），操作系统会触发写时复制机制。COW
机制会为被修改的内存页创建一个副本，并将写操作应用到这个副本上，而不是直接修改共享的内存页。</li>
<li>主进程在读取被修改的数据时，会从生成的副本中读取，而子进程则继续读取原始的内存页。这种机制确保了子进程在生成
RDB
文件时看到的是一致且稳定的数据快照，而主进程可以不受影响地继续处理新的写操作。</li>
</ul></li>
</ul>
<p><strong>完成 RDB 文件</strong>：</p>
<ul>
<li>子进程生成 RDB 文件后，将临时 RDB 文件重命名为正式的 RDB
文件，确保文件替换过程是原子的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fdf7b6cfd054243fcc3bc8a6070ccafa.png"></p>
<h3 id="手动启用">手动启用</h3>
<p>Redis 提供了以下两个命令来手动生成 RDB 快照文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save # 同步保存操作，由Redis主进程来执行RDB，会阻塞所有命令</span><br><span class="line">bgsave # 开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis
启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis
主进程，也没毛病。</p>
</blockquote>
<h3 id="定时启用">定时启用</h3>
<p>可以通过配置文件中的 <code>save</code>
选项进行定时触发RDB持久化。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>	#在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>	#在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>	#在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个key发生变化，Redis就会自动触发bgsave命</span><br></pre></td></tr></table></figure>
<h2 id="aof持久化">AOF持久化</h2>
<p>AOF全称为Append Only
File（追加文件）。通过<strong>将每次写操作记录到AOF文件中来实现</strong>。这种方式的特点是将
Redis 接收到的每个写命令都追加到文件末尾。</p>
<h3 id="实现原理-1">实现原理</h3>
<p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol type="1">
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF
缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF
文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（
<code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用
<code>fsync</code> 函数（系统调用）， <code>fsync</code>
针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code>
将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF
文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF
文件进行数据恢复。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/13ba660a72aad283d70bc33744034be0.png"></p>
<h3 id="启用aof">启用AOF</h3>
<p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启
AOF（Redis 6.0 之后默认开启），可以通过 <code>appendonly</code>
参数开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF，默认是no</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="刷盘策略">刷盘策略</h3>
<p>开启 AOF 持久化后，每执行一条会更改 Redis 中数据的命令，Redis
就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code>
中，然后再写入到系统内核缓冲区中，最后根据刷盘策略的配置来决定何时将系统内核缓冲区中的数据<strong>同步到硬盘</strong>中。</p>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到A0F文件，是默认方案</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 29%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>刷盘时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>always</strong></td>
<td>同步刷盘</td>
<td>可靠性高，几乎不丢数据</td>
<td>性能影响大</td>
</tr>
<tr class="even">
<td><strong>everysec</strong></td>
<td>每秒刷盘</td>
<td>性能适中</td>
<td>最多丢失1秒数据</td>
</tr>
<tr class="odd">
<td><strong>no</strong></td>
<td>操作系统控制</td>
<td>性能最好</td>
<td>可靠性较差，可能丢失大量数据</td>
</tr>
</tbody>
</table>
<h3 id="文件重写">文件重写</h3>
<p>随着时间的推移，AOF
文件会因为不断追加写命令而变得越来越大，可能会导致磁盘空间不足和恢复速度变慢。可以<strong>通过重新生成一个新的
AOF
文件，将当前的数据集以最少的命令集记录下来，从而缩小文件大小</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/29a69c0ba1e14d99d844b41736bb3387.png"></p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF
重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF
文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF
文件的工作之后，服务器会将重写缓冲区中的所有内容<strong>追加到新 AOF
文件的末尾</strong>，使得新的 AOF
文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF
文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>开启 AOF 重写功能，可以调用 <code>bgrewriteaof</code>
命令手动执行，也可以设置阈值进行自动执行。</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：如果 AOF
文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB</li>
<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF
大小和上一次重写时 AOF 大小的比值。如果当前 AOF
文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动
AOF 重写。默认值为 100。</li>
</ul>
<blockquote>
<p><strong>AOF校验机制了解吗</strong></p>
</blockquote>
<p><strong>AOF 校验机制是 Redis 在启动时对 AOF
文件进行检查</strong>，以判断文件是否完整，是否有损坏或者丢失的数据。</p>
<p>这个机制的原理其实非常简单，就是通过使用一种叫做
<strong>校验和（checksum）</strong> 的数字来验证 AOF
文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64
算法计算得出的数字。<strong>如果文件内容发生了变化，那么校验和也会随之改变</strong>。因此，Redis
在启动时会比较<strong>计算出的校验</strong>和与<strong>文件末尾保存的校验和</strong>（计算的时候会把最后一行保存校验和的内容给忽略掉），从而判断
AOF 文件是否完整。如果发现文件有问题，Redis
就会拒绝启动并提供相应的错误信息。</p>
<p>类似地，RDB 文件也有类似的校验机制来保证 RDB
文件的正确性，这里就不重复进行介绍了。</p>
<h2 id="如何选择rdb和aof">如何选择RDB和AOF</h2>
<h3 id="rdbredis-database-file">RDB（Redis Database File）</h3>
<p><strong>优点：</strong></p>
<ol type="1">
<li><strong>持久化速度快</strong>：RDB
文件在持久化时会生成一个数据快照，可以快速地恢复大规模的数据集。</li>
<li><strong>文件较小</strong>：RDB 文件是二进制格式的，通常比 AOF
文件更小，占用的磁盘空间较少。</li>
<li><strong>恢复速度快</strong>：RDB 文件在恢复数据时，加载速度通常比
AOF 快，因为 RDB 文件是一个完整的数据快照，不需要逐条回放写操作。</li>
<li><strong>对性能影响小</strong>：RDB
持久化是通过子进程完成的，主进程可以继续处理客户端请求，因此对 Redis
性能影响较小。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol type="1">
<li><strong>数据丢失风险高</strong>：因为 RDB
持久化是定期执行的（如每隔几分钟或根据配置的触发条件），在上一次持久化到下一次持久化之间的数据可能会丢失。</li>
<li><strong>生成过程消耗资源</strong>：生成 RDB 文件需要 fork
子进程并占用一定的 CPU 和内存资源，特别是数据量大时会影响性能。</li>
</ol>
<h3 id="aofappend-only-file">AOF（Append-Only File）</h3>
<p><strong>优点：</strong></p>
<ol type="1">
<li><strong>数据丢失风险低</strong>：AOF
通过追加日志记录每次写操作，可以更频繁地持久化数据（甚至可以做到每秒持久化一次），因此数据丢失的风险较低。</li>
<li><strong>可调的同步策略</strong>：AOF 提供了多种同步策略（如
<code>always</code>、<code>everysec</code> 和
<code>no</code>），可以根据需要在性能和数据安全性之间做权衡。</li>
<li><strong>更人性化</strong>：AOF
文件是可读的日志文件，方便人类阅读和分析，有助于调试和故障排查。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol type="1">
<li><strong>文件较大</strong>：AOF 文件记录了每个写操作，文件大小通常比
RDB 大很多，占用更多的磁盘空间。</li>
<li><strong>恢复速度慢</strong>：AOF
恢复数据时需要回放所有的写操作日志，恢复速度通常比 RDB 慢。</li>
<li><strong>性能开销较大</strong>：因为 AOF
需要在每次写操作后追加日志，频繁的磁盘 I/O
操作会带来一定的性能开销，特别是在同步策略设置为 <code>always</code>
时。</li>
</ol>
<h3 id="综合比较">综合比较</h3>
<ol type="1">
<li><strong>数据安全性</strong>：AOF
提供更高的数据安全性，适用于对数据丢失敏感的场景；RDB
在数据持久化频率较低时有较高的数据丢失风险。</li>
<li><strong>性能</strong>：RDB 对 Redis
性能影响较小，适用于性能要求高的场景；AOF 因为频繁的磁盘 I/O
操作，对性能有一定的影响。</li>
<li><strong>恢复速度</strong>：RDB
恢复速度更快，适用于需要快速恢复大规模数据集的场景；AOF
需要回放日志，恢复速度较慢。</li>
<li><strong>磁盘空间</strong>：RDB 文件较小，节省磁盘空间；AOF
文件较大，占用更多磁盘空间。</li>
</ol>
<h2 id="混合持久化">混合持久化</h2>
<p>Redis 4.0 引入了混合持久化机制，结合了 RDB 和 AOF
的优点，以提高持久化的效率和可靠性。<strong>混合持久化在重启恢复数据时使用
RDB 文件的快照来快速加载数据，并且将 AOF
日志应用于此快照以实现更高的数据恢复精度。</strong></p>
<h3 id="工作原理">工作原理</h3>
<ol type="1">
<li><strong>RDB 快照</strong>：
<ul>
<li>Redis 生成 RDB 文件快照，保存整个数据库的二进制数据。</li>
<li>RDB
文件的生成是通过子进程完成的，主进程可以继续处理客户端请求。</li>
</ul></li>
<li><strong>AOF 日志</strong>：
<ul>
<li>除了生成 RDB 文件外，Redis 还会将写操作记录到 AOF 日志中。</li>
<li>在混合持久化模式下，AOF 文件的初始部分是一个 RDB
快照，后面紧接着的是增量的 AOF 日志。</li>
</ul></li>
<li><strong>持久化过程</strong>：
<ul>
<li>当 Redis 进行持久化操作时，它会首先生成一个 RDB
文件，并将这个文件内容写入 AOF 文件。</li>
<li>在 AOF 文件中，RDB 文件的内容作为初始部分，然后紧跟着追加的 AOF
日志。</li>
</ul></li>
<li><strong>数据恢复</strong>：
<ul>
<li>当 Redis 重启时，它会首先加载 AOF 文件中的 RDB
部分（即快照）来快速恢复数据。</li>
<li>然后，它会回放 AOF 文件中 RDB
部分后的增量日志，以确保数据的一致性和完整性。</li>
</ul></li>
</ol>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点：</strong></p>
<ol type="1">
<li><strong>快速恢复</strong>：使用 RDB
部分可以快速加载大部分数据，而不需要逐条回放所有写操作日志，极大地提高了数据恢复的速度。</li>
<li><strong>较高的数据安全性</strong>：结合了 RDB 和 AOF 的优点，RDB
部分确保了数据的快速恢复，而 AOF
部分提供了更高的数据持久化频率，降低了数据丢失的风险。</li>
<li><strong>性能优化</strong>：
<ul>
<li>在持久化过程中，RDB
快照的生成是通过子进程完成的，对主进程处理客户端请求的性能影响较小。</li>
<li>AOF 的增量日志记录了自上次快照以来的所有写操作，减少了持久化过程中的
I/O 操作次数，提高了系统性能。</li>
</ul></li>
</ol>
<p><strong>缺点：</strong></p>
<ol type="1">
<li><strong>配置复杂性</strong>：混合持久化的配置比单独使用 RDB 或 AOF
更加复杂，需要合理设置参数以实现最佳性能和数据安全性。</li>
<li><strong>磁盘空间占用</strong>：混合持久化模式下，AOF 文件既包含 RDB
快照部分又包含增量日志，可能会占用更多的磁盘空间。</li>
</ol>
<h3 id="启用混合持久化">启用混合持久化</h3>
<p>要启用混合持久化，可以在 Redis 配置文件 <code>redis.conf</code>
中设置以下参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 重写策略</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 AOF 文件达到指定大小或比例时触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用混合持久化</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>RDB</tag>
        <tag>AOF</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis集群】集群原理最全解析</title>
    <url>/2024/08/12/%E3%80%90Redis%E9%9B%86%E7%BE%A4%E3%80%91%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="主从集群">主从集群</h2>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7734b070a0abf4ca05aea435d026df9a.png"></p>
<h3 id="数据同步概念">数据同步概念</h3>
<h4 id="replication-id和offset">Replication Id和offset</h4>
<p>在从节点发起数据同步的请求中，有两个重要的属性：</p>
<ul>
<li><code>Replication Id</code>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid。</li>
<li><code>offset</code>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li>
</ul>
<p><strong>因此slave做数据同步，必须向master声明自己的replication
id和offset，master才可以判断到底需要同步哪些数据。</strong>
当从节点发起主从同步请求时，主节点会判断从节点的replid是否一致，如果不一致，说明是第一次请求数据同步。</p>
<h4 id="repl_baklog缓冲区">repl_baklog缓冲区</h4>
<p><code>repl_baklog</code>缓冲区是主从同步的重要机制，主节点在生成RDB文件期间会将命令记录到这个<strong>环形缓冲区</strong>中。</p>
<p>该缓冲区用于<strong>增量同步</strong>，确保从节点的偏移量与主节点保持一致。然而，如果从节点宕机且重启时缓冲区的数据已被覆盖，从节点就无法通过缓冲区恢复全部数据，导致数据不一致。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6d8fcd0ed32eda58948be44ea1fd27fb.png"></p>
<h3 id="第一次数据同步">第一次数据同步</h3>
<ol type="1">
<li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li>
<li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点。由于生成RDB文件的过程是异步的，主节点同时会持续记录在生成RDB文件期间产生的所有命令。</li>
<li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。加载完成后，从节点获取缓存区的命令，执行命令同步数据。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a1849c13d12ab6d2255cf864a1fb3862.png"></p>
<h3 id="全量同步">全量同步</h3>
<p><strong>全量同步</strong>：是指主节点生成RDB文件并发送给从节点，从节点清空本地数据并加载RDB文件的过程。它通常发生在从节点首次连接到主节点或数据不一致的情况下。</p>
<p>全量同步的发生场景有两种：</p>
<ol type="1">
<li><strong>从节点首次连接主节点：</strong>
当一个新的从节点第一次连接到主节点时，它没有任何数据副本。因此，需要进行全量同步来获取主节点的完整数据集。<strong>全量同步过程：</strong>
<ol type="1">
<li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li>
<li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点</li>
<li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。</li>
</ol></li>
<li><strong>主节点缓冲区超出容量：</strong>
主节点的<code>repl_baklog</code>缓冲区大小有上限，写满后会覆盖最早的数据。如果从节点断开时间过久，导致尚未备份的数据被覆盖，则主节点不能基于缓冲区做数据同步，只能再次使用全量同步获取RDB的完整数据集。</li>
</ol>
<p><strong>全量同步过程：</strong></p>
<ol type="1">
<li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li>
<li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点</li>
<li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。</li>
</ol>
<h3 id="增量同步">增量同步</h3>
<p><strong>增量同步</strong>：是指主节点在RDB文件生成期间记录的所有命令（写操作）被存储在<code>replication backlog</code>缓冲区中，并在全量同步完成后发送给从节点，从节点执行这些命令的过程。增量同步用于保持主从节点之间的数据一致性。</p>
<p>增量同步的发生场景有两种：</p>
<ol type="1">
<li><p><strong>全量同步后的持续增量同步：</strong>
在从节点完成初次的全量同步之后，主节点和从节点之间需要保持数据一致性。从节点会不断接收主节点的增量数据以更新其自身的数据状态。</p></li>
<li><p><strong>从节点宕机重启后的增量同步：</strong>
当从节点因为故障、宕机或其他原因暂时失联，然后重新启动并重新连接到主节点时，主节点会尝试通过增量同步来恢复数据同步的状态。</p></li>
</ol>
<p><strong>增量同步过程：</strong></p>
<ol type="1">
<li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li>
<li>主节点需要判断<code>replid</code>是否与自己一致，如果一致，说明从节点不是第一次申请数据同步了（即从节点之前进行了全量同步），主节点返回continue，允许从节点获取<code>repl_baklog</code>缓冲区的命令</li>
<li>从节点持续获取缓存区的命令，执行命令同步数据。</li>
</ol>
<h3 id="优化策略">优化策略</h3>
<p>可以从以下几个方面来优化Redis主从集群：</p>
<ul>
<li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘I/O</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘I/O</li>
<li>适当提高<code>repl_baklog</code>缓存区的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li>
</ul>
<h2 id="哨兵机制">哨兵机制</h2>
<p>在主从集群中，slave节点即使宕机，也可以从master节点上恢复数据。然而，如果master节点宕机，即使master节点做了持久化处理，在其重启后虽然能够恢复部分数据，但在重启和故障恢复的过程中，<strong>仍然可能会丢失大量数据</strong>，这对系统来说是不可接受的。</p>
<p>因此，为了解决上述问题，在主从集群的基础上引入了哨兵机制。<strong>哨兵机制的核心作用是监控主从集群中的各个节点，并在检测到master节点宕机时，自动从slave节点中选举一个新的master节点。</strong></p>
<p><strong>哨兵（Sentinel）机制的作用：</strong></p>
<ul>
<li><strong>服务状态监控：</strong>
Sentinel会不断检查集群中的master和slave节点是否按预期工作</li>
<li><strong>自动故障恢复：</strong>
如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知Redis客户端：</strong>
Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8051a5eb45d945414477798804c9d068.png"></p>
<h3 id="服务状态监控">服务状态监控</h3>
<p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<ul>
<li><strong>主观下线：</strong>
如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li><strong>客观下线：</strong>
若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。</li>
</ul>
<h3 id="自动故障恢复">自动故障恢复</h3>
<h4 id="选举新master节点">选举新master节点</h4>
<p>当sentinel检测到master节点客观下线时，需要在集群中选择一个slave节点作为新的master，选择依据是这样的：</p>
<ul>
<li><strong>节点断开时间长短</strong>：首先会判断slave节点与master节点断开时间长短，如果超过指定值<code>down-after-milliseconds * 10</code>则会排除该slave节点</li>
<li><strong>优先级判断</strong>：slave从节点有<code>slave-priority</code>参数，越小优先级越高，如果是0则永不参与选举</li>
<li><strong>数据同步状态</strong>：如果从节点优先级一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li><strong>节点 ID
大小</strong>：最后是判断slave节点的运行id大小，越小优先级越高，</li>
</ul>
<h4 id="进行故障转移">进行故障转移</h4>
<p>当节点2（master节点）故障后，sentinel选举节点1为新的master节点，故障转移步骤如下:</p>
<ul>
<li>sentinel给备选的节点1发送slaveof no one命令，让节点1成为master</li>
<li>sentinel给其它所有的slave节点发送slaveof 192.168.150.101
7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当节点2恢复后会自动成为新的master的slave节点</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/412dea73ace8d948e1a84f01c3febdfe.png"></p>
<h3 id="通知redis客户端">通知Redis客户端</h3>
<p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化及时更新连接信息。Spring的RedisTemplate底层利用<code>lettuce</code>实现了节点的感知和自动切换。</p>
<ol type="1">
<li>在pom文件中引入redis的starter依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>然后在配置文件application.yml中指定sentinel相关信息</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment">#指定master名称</span></span><br><span class="line">   <span class="attr">nodes:</span> <span class="comment">#指定redis-sentinel集群信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>配置读写分离</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configBuilder -&gt; configBuilder.readFrom(ReadFroM.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ReadFrom是配置Redis的读取策略，是一个枚举，包括下面选择:</p>
<ul>
<li><strong>MASTER：</strong> 从主节点读取</li>
<li><strong>MASTER_PREFERRED：</strong>
优先从master节点读取，master不可用才读取replica</li>
<li><strong>REPLICA：</strong> 从slave(replica)节点读取</li>
<li><strong>REPLICA_PREFERRED：</strong>
优先从slave(replica)节点读取，所有的slave都不可用才读取master</li>
</ul>
<h2 id="分片集群">分片集群</h2>
<p>主从复制和哨兵机制虽然解决了Redis的高可用性和高并发读的问题，但仍然面临以下两个挑战：</p>
<ol type="1">
<li><strong>海量数据存储的问题</strong>：单个Redis实例的内存和存储容量有限，无法处理海量数据。</li>
<li><strong>高并发写入的问题</strong>：单个主节点在高并发写入的场景下容易成为性能瓶颈。</li>
</ol>
<p>Redis中的分片集群（Sharded
Cluster）是一种将数据分布在多个Redis节点上的方式。通过将数据水平分片，分片集群能够在数据量增加时提升集群的存储容量，同时将写入压力分散到多个master节点上，提升整体性能。</p>
<p><strong>Redis 分片集群的核心作用：</strong></p>
<ul>
<li><strong>数据水平扩展：</strong>
通过将数据分片存储在多个节点上，Redis
集群能够扩展到多个实例，以应对大规模数据存储和高并发请求。</li>
<li><strong>负载均衡：</strong>
将请求均匀分布到不同的分片节点上，避免单点压力过大，确保系统性能的稳定性。</li>
<li><strong>高可用性：</strong> 通过主从复制和自动故障恢复机制，Redis
集群能够在某个节点发生故障时，继续提供服务，确保系统的高可用性。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9dceb428c1f7304d335bca94e42c4fb1.png"></p>
<h3 id="重要概念">重要概念</h3>
<h4 id="散列插槽">散列插槽</h4>
<p>Redis 集群通过<strong>哈希槽</strong>（Hash
Slot）机制来分配数据到不同的分片节点上。整个哈希空间分为 16384
个槽，每个键根据其哈希值被分配到一个特定的槽中，而槽则由集群中的各个matser节点持有。</p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li>如果key中包含<code>&#123;&#125;</code>，且<code>&#123;&#125;</code>中至少包含1个字符，<code>&#123;&#125;</code>中的部分是有效部分</li>
<li>如果key中不包含<code>&#123;&#125;</code>，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{modox}num，则根据modox计算。计算方式是利用<code>CRC16</code>算法得到一个hash值，然后对16384取余，得到的结果就是插槽的slot值。</p>
<blockquote>
<p><strong>Redis客户端如何进行数据访问？</strong>
根据键的哈希值确定数据所在的分片节点，然后直接与该节点通信。</p>
<p><strong>如何将同一类数据保存在同一个Redis节点上？</strong>
只需设置一个统一的有效部分，如{shopId}</p>
</blockquote>
<h4 id="配置纪元">配置纪元</h4>
<p>配置纪元的作用是标识和跟踪集群配置的版本，<strong>确保集群中的所有节点在主节点故障转移和配置变更时保持一致</strong>。</p>
<p><strong>1.配置纪元是只增不减的整数</strong>：</p>
<ul>
<li>每个主节点都有一个自身维护的配置纪元
(<code>clusterNode.configEpoch</code>)，表示该主节点的版本。这个配置纪元是集群变更时用于标识和协调的关键因素。</li>
<li>每个主节点的配置纪元都不同，以确保集群内的节点可以正确识别和处理最新的配置变更。</li>
</ul>
<p><strong>2.从节点会复制主节点的配置纪元</strong>：</p>
<ul>
<li>当从节点与其对应的主节点同步时，它会复制该主节点的配置纪元。这样在主节点发生故障时，从节点可以使用这个配置纪元参与选举并成为新的主节点。</li>
</ul>
<p><strong>3.全局配置纪元</strong>：</p>
<ul>
<li>整个集群维护一个全局的配置纪元
(<code>clusterState.currentEpoch</code>)，记录集群内所有主节点的配置纪元中的最大版本号。这个全局纪元会在集群发生关键事件（如故障转移、添加/删除节点）时增加，以确保集群状态的一致性。</li>
</ul>
<p><strong>4.选举时选择纪元数最大的从节点</strong>：</p>
<ul>
<li>在故障转移过程中，集群会优先选择配置纪元最大的从节点作为新的主节点。因为这个从节点的数据更可能是最新的，并且它在选举中更有可能获得其他主节点的支持。</li>
</ul>
<h3 id="服务状态监控-1">服务状态监控</h3>
<p>Redis分片集群的各个节点通过<code>ping/pong</code>进行消息通信，转播槽的信息和节点状态信息，故障发现也是通过这个动作实现的，类似于<code>sentinel</code>，有主观下线和客观下线。</p>
<ul>
<li><strong>主观下线（PFAIL）：</strong> 集群中的每个节点都会定期通过
PING-PONG 消息与其他节点通信。如果一个节点在指定时间内没有响应其他节点的
PING 请求，该节点会被标记为主观下线。</li>
<li><strong>客观下线（FAIL）：</strong> 如果多个节点都将同一个节点标记为
PFAIL，那么通过投票机制，该节点将被标记为客观下线（FAIL）。这个状态会在集群中广播，所有节点都认同该节点已不可用。</li>
</ul>
<h3 id="故障恢复">故障恢复</h3>
<h4 id="选举新的master节点">选举新的master节点</h4>
<p>Redis 分片集群和 Sentinel 机制在选举新的 master
节点时规则基本相同，唯一的区别在于节点断开时间的处理方式不同。</p>
<ul>
<li><strong>节点断开时间长短</strong>：每个从节点检查与故障主节点的断线时间，断开时间超过<code>cluster-node-timeout * cluster-slave-validity-factor</code>则取消资格。cluster-slave-validity-factor
: 默认是10</li>
<li><strong>优先级判断</strong>：slave从节点有<code>slave-priority</code>参数，越小优先级越高，如果是0则永不参与选举</li>
<li><strong>数据同步状态</strong>：如果从节点优先级一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li><strong>配置纪元：</strong>
在故障转移过程中，集群会优先选择配置纪元最大的从节点作为新的主节点。因为配置纪元越大的从节点，数据更可能是新的。</li>
</ul>
<h4 id="进行故障转移-1">进行故障转移</h4>
<p>当新的 master 节点选举完成后，Redis
集群会自动进行故障转移，具体包括以下步骤：</p>
<ol type="1">
<li><strong>提升新的 master 节点</strong>：Redis 集群通过内部命令
<code>SLAVEOF NO ONE</code> 将选中的从节点提升为新的 master 节点。</li>
<li><strong>更新哈希槽映射</strong>：Redis
集群会自动更新哈希槽与节点的映射关系，新的 master 节点将执行
<code>CLUSTER DELSLOTS</code> 操作撤销故障主节点负责的槽，并执行
<code>CLUSTER ADDSLOTS</code> 把这些槽委派给自己。</li>
<li><strong>重新配置和广播</strong>：Redis
集群将剩余的从节点重新配置为新 master 节点的从节点，并广播新的 master
信息给所有节点，确保集群内所有节点都更新哈希槽映射，并将新 master
的信息同步到其他节点。</li>
<li><strong>节点重连</strong>：如果故障的 master
节点恢复上线，它通常会被重新配置为新的 master
的从节点，并同步数据以确保与新 master 保持数据一致性。</li>
</ol>
<h3 id="通知redis客户端-1">通知Redis客户端</h3>
<p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致。</p>
<ol type="1">
<li>引入redis的starter依赖</li>
<li>配置分片集群地址</li>
<li>配置读写分离</li>
</ol>
<p>与哨兵模式相比，只有yaml配置文件的配置方式存在差异，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">   <span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>
<h3 id="集群伸缩">集群伸缩</h3>
<p>Redis
集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容，对节点进行灵活上下线控制，原理可抽象为<strong>槽和对应数据在不同节点之间灵活移动。</strong></p>
<h4 id="集群扩容">集群扩容</h4>
<p><strong>1.添加节点：</strong></p>
<p>Redis分片集群提供了为现有集群添加新节点的，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new_host:new_port existing_host:existing_port</span><br><span class="line">--cluster-slave</span><br><span class="line">--cluster-master-id &lt;arg&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要直接指定新节点为某一master的从节点，可使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node &lt;新节点IP&gt;:&lt;端口&gt; &lt;现有节点IP&gt;:&lt;端口&gt; --cluster-slave --cluster-master-id &lt;主节点ID&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2.迁移插槽：</strong></p>
<p>可通过<code>reshard</code>命令将当前节点的散列插槽分配给其他节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;当前节点IP&gt;:&lt;端口&gt;</span><br></pre></td></tr></table></figure>
<p>接着Redis会提示需要移动多少插槽，自行输入即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">How many slots do you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure>
<p>然后需要输入接收插槽的节点ID，确认后即可实现插槽的迁移</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">What is the receiving node ID?</span><br></pre></td></tr></table></figure>
<p><strong>3.添加从节点：</strong></p>
<p>由于新的master节点相比其他主节点目前还没有从节点，因此该节点不具备故障转移的能力。</p>
<p>可以在从节点下使用<code>cluster replicate</code>命令为主节点添加对应从节点（在分片集群下slaveof命令添加从节点的操作不再支持）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster replicate &lt;主节点ID&gt;</span><br></pre></td></tr></table></figure>
<p>从节点内部除了对主节点发起全量复制之外，还需要更新本地节点的集群相关状态。</p>
<h4 id="集群缩容">集群缩容</h4>
<p><strong>1.迁移插槽：</strong></p>
<p>缩容操作需要非常谨慎，因为如果下线的节点持有插槽，直接删除可能会引起数据一致性问题，因此需要将槽迁移给其他节点后才能安全下线，流程同上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;当前节点IP&gt;:&lt;端口&gt;</span><br></pre></td></tr></table></figure>
<p>接着Redis会提示需要移动多少插槽，自行输入即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">How many slots do you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure>
<p>然后需要输入接收插槽的节点ID，确认后即可实现插槽的迁移</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">What is the receiving node ID?</span><br></pre></td></tr></table></figure>
<p><strong>2.忘记节点：</strong></p>
<p>在一个可用的节点上执行删除节点的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node &lt;可用的节点IP&gt;:&lt;可用的节点端口&gt; &lt;需要删除的节点ID&gt;</span><br></pre></td></tr></table></figure>
<h3 id="手动故障转移">手动故障转移</h3>
<p>在 Redis
集群中，手动故障转移允许管理员主动介入，以便在发现主节点故障时，迅速将其替换为副本节点，确保系统的持续可用性和稳定性。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9cf6e902f3f0988f2f8e3964e21bd5a5.png"></p>
<p>此外，手动数据迁移还支持三种不同模式：</p>
<ul>
<li><strong>缺省：</strong> 默认的流程，如图1~6步</li>
<li><strong>force：</strong> 省略了对offset的一致性校验</li>
<li><strong>takeover：</strong>
直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>主从集群</tag>
        <tag>哨兵机制</tag>
        <tag>分片集群</tag>
      </tags>
  </entry>
  <entry>
    <title>【单例模式】深入三大单例对象创建方式</title>
    <url>/2024/08/21/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介">1.简介</h2>
<p><strong>单例模式</strong>是一种创建型设计模式，它确保<strong>一个类在内存中只有一个实例</strong>，并提供全局访问点来共享该实例。在程序中，如果需要频繁使用同一个对象且它们的作用相同，单例模式可以避免频繁创建对象，减少内存开销。</p>
<p>单例模式主要有两种类型：</p>
<ul>
<li>懒汉式：在<strong>需要使用</strong>时才去创建该对象的单例</li>
<li>饿汉式：在<strong>类加载</strong>时就已经创建好该单例对象，等待被程序使用</li>
</ul>
<h2 id="懒汉式">2.懒汉式</h2>
<p>懒汉式创建对象的方法是在程序使用对象前，判断对象是否为空（是否被实例化），如果为空则创建该对象的实例，如果不为空直接返回该对象的实例即可。</p>
<h3 id="非线程安全">非线程安全</h3>
<p>使用 <code>static</code>
关键字修饰对象，表示该对象属于类本身，而不是类的某个实例。在应用程序的整个生命周期中，该类只会存在一个这样的实例。当多线程访问该类时，可以通过类获取这个静态对象，从而避免重复创建新对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全">线程安全</h3>
<p>上述方法在多线程创建对象的时候是有问题的。如果两个线程同时判断singleton为空，那么它们都会执行<code>singleton = new Singleton();</code>语句创建一个实例，这就变成双例了。</p>
<p>解决方法也很简单，给获取实例的方法<code>getInstance()</code>加锁即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法也存在问题：<strong>每次去获取对象都需要获取互斥锁，在高并发场景下，可能会多线程阻塞的问题。</strong></p>
<p>优化方案是：如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例。</p>
<h3 id="双重校验锁">双重校验锁</h3>
<p>在单例模式中，双重校验锁可以确保只有在第一次访问单例对象时才会进行实例化，并且在多线程环境下能够保证单例对象的唯一性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 多个线程判断类是否实例化，如果已经被实例化，直接return即可</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 多线程争抢该锁进行实例化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 保证后续的锁进来后，不需要再实例化</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细解释下这段代码的执行流程：</p>
<ol type="1">
<li>多个线程执行<code>getInstance()</code>方法后，进入<code>if (singleton == null)</code>语句块，判断类是否已经被实例化了，如果已经被实例化，直接返回对象，无需继续创建对象。</li>
<li>如果 <code>singleton</code> 为
null，多个线程争抢该锁进行实例化，同一时刻只有一个线程可以进入同步代码块去创建对象。</li>
<li>再次判断该类是否被实例化，这一步确保了上一个线程在进入同步块后创建了对象，当前线程也不会重复创建实例。</li>
</ol>
<h3 id="防止指令重排">防止指令重排</h3>
<p>尽管我们使用双重校验锁的方案保证了<strong>线程安全</strong>并提升了<strong>性能</strong>，但由于JVM<code>指令重排序</code>的存在，在多线程创建单例时仍然可能存在问题。</p>
<p>当JVM执行<code>new Singleton()</code>创建一个对象时，会经过三个步骤：</p>
<ol type="1">
<li>为singleton分配内存空间。</li>
<li>初始化singleton对象，将对象的成员变量赋值。</li>
<li>将内存空间的引用赋值给 <code>singleton</code> 变量。</li>
</ol>
<p><strong>当发生指令重排序时，这个顺序可能会发生变化，导致未完成初始化（即对象的构造方法可能尚未执行完毕，某些属性可能未被赋值）的对象被其他线程访问，如果这些线程使用了该对象的成员变量，就会导致NPE。</strong></p>
<blockquote>
<p><strong>具体场景：</strong></p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408211840672.png"></p>
<p>当<strong>线程A</strong>进入同步块并执行<code>singleton= new Singleton()</code>时，由于指令重排，创建对象的顺序变成：</p>
<ol type="1">
<li>为singleton分配内存空间。</li>
<li>将内存空间的引用赋值给 <code>singleton</code> 变量。</li>
<li>初始化singleton对象，将对象的成员变量赋值。</li>
</ol>
<p>这时候<strong>线程B</strong>在第一次检查<code>singleton == null</code>时得到的结果是<code>false</code>，因为<code>instance</code>已经不再是<code>null</code>（已经指向了内存地址），于是直接返回了这个未初始化的<strong>半成品对象</strong>。</p>
<p>由于<code>singleton</code>指向的对象尚完成初始化，当<strong>线程B</strong>在访问该对象尚未初始化的成员变量时，就会导致空指针异常<code>NullPointerException</code>。</p>
<blockquote>
<p><strong>解决方案：</strong></p>
</blockquote>
<p>只需加上<code>volatile</code>关键字即可，使用<code>volatile</code>修饰变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饿汉式">3.饿汉式</h2>
<p>饿汉式在<strong>类加载</strong>时就已经创建好单例对象，因此在程序调用时可以<strong>直接返回</strong>该对象。也就是说，我们在调用时直接获取单例对象即可，而不需要在调用时再去创建实例。</p>
<p>由于饿汉式在类加载过程中就由JVM创建了单例，因此<strong>不存在线程安全问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="破坏单例模式">4.破坏单例模式</h2>
<p>无论是使用了<code>双重校验锁+volatile关键字</code>的懒汉式还是饿汉式，都无法防止<strong>反射和序列化</strong>破坏单例模式（创建多个对象），具体演示代码如下：</p>
<blockquote>
<p><strong>反射破坏单例模式</strong></p>
</blockquote>
<p>这个原理很简单，利用反射可以<strong>强制访问</strong>类的私有构造器，从而创建另一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj1</span> <span class="operator">=</span> construct.newInstance(); </span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj2</span> <span class="operator">=</span> Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>序列化破坏单例模式</strong></p>
</blockquote>
<p>首先使用将单例对象序列化为文件流或其他形式，再使用反序列化的手段从流中读取对象。</p>
<p>当使用<code>readObject()</code>方法时，一定会创建一个新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建输出流</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Singleton.file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Singleton.file&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">    <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类">5.枚举类</h2>
<p>枚举类不仅能<strong>确保线程安全性</strong>，还可以<strong>防止反序列化破坏</strong>和<strong>反射攻击</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;  <span class="comment">// 唯一的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例方法，可以在单例实例中添加其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton instance is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取单例实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用单例实例的方法</span></span><br><span class="line">        singleton.doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证多次获取的实例是相同的</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">anotherInstance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(<span class="string">&quot;Are both instances the same? &quot;</span> + (singleton == anotherInstance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类的优点：</p>
<ol type="1">
<li><strong>线程安全</strong>：枚举类的实例在 JVM 加载时由 JVM
保证，只会实例化一次，因此枚举的单例实现天然是线程安全的。</li>
<li><strong>防止反序列化破坏</strong>：默认情况下，反序列化一个枚举类型时，会通过类加载器加载枚举类，从而保证每个枚举类型在
JVM 中仅存在一个实例。因此枚举类型可以防止反序列化导致的单例破坏。</li>
<li><strong>防止反射攻击</strong>：反射攻击是指通过反射机制来调用私有构造器从而创建多个实例的情况，但在枚举类型中，这种操作会抛出
<code>IllegalArgumentException</code>，从而有效地防止了反射攻击。</li>
</ol>
<h2 id="对比">6.对比</h2>
<h3 id="懒汉式-1"><strong>懒汉式</strong></h3>
<ul>
<li><strong>实例化时机</strong>：在第一次调用<code>getInstance()</code>方法时，才会创建单例实例。这意味着如果程序一直没有调用这个方法，单例实例将永远不会被创建。</li>
<li><strong>优点</strong>：延迟加载（Lazy
Loading），只有在需要时才创建实例，节省了系统资源。</li>
<li><strong>缺点</strong>：首次创建实例时可能会有性能开销。在多线程环境下，如果没有适当的同步机制，可能会导致线程安全问题，如重复创建实例。</li>
</ul>
<h3 id="饿汉式-1">饿汉式</h3>
<ul>
<li><strong>实例化时机</strong>：在类加载时就创建单例实例。无论是否调用<code>getInstance()</code>方法，类加载时都会创建实例。</li>
<li><strong>优点</strong>：实现简单，类加载时就完成了实例化，避免了多线程同步问题，因为JVM在类加载时确保了线程的安全性。</li>
<li><strong>缺点</strong>：即使单例实例从未被使用，也会在程序启动时创建，可能会浪费系统资源，尤其是在实例化过程较重或单例实例不常用的情况下。</li>
</ul>
<h3 id="枚举类-1">枚举类</h3>
<ul>
<li><strong>实例化时机</strong>：在枚举类被加载时创建单例实例，与饿汉式类似，枚举类型的实例会在类加载时被创建，并且JVM会确保只有一个实例存在。</li>
<li><strong>优点：</strong>
<ul>
<li><strong>线程安全</strong>：枚举类型在Java中是天然线程安全的，JVM保证了枚举实例的唯一性，无需额外的同步控制。</li>
<li><strong>防止反序列化破坏单例</strong>：枚举类在反序列化时不会创建新的实例，保证了单例的唯一性。</li>
<li><strong>防止反射攻击</strong>：枚举类在Java中不允许通过反射创建实例，因此可以防止反射攻击破坏单例。</li>
</ul></li>
<li><strong>缺点</strong>：如果单例类需要继承其他类或实现某些接口，枚举类不太适合。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程】从AQS机制到同步工具类</title>
    <url>/2024/08/30/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%BB%8EAQS%E6%9C%BA%E5%88%B6%E5%88%B0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="aqs机制">AQS机制</h1>
<p>Java 中常用的锁主要有两类，一种是 Synchronized 修饰的锁，被称为 Java
内置锁或监视器锁。另一种就是在 JUC 包中的各类同步器，包括
ReentrantLock（可重入锁）、Semaphore（信号量）、CountDownLatch 等。</p>
<p>所有的同步器都是基于AQS机制来构建的，而 AQS
类的核心数据结构是一种名为<strong>CLH锁</strong>的变体。</p>
<h2 id="clh锁">CLH锁</h2>
<p>CLH锁是一种<strong>基于链表的自旋锁</strong>，它通过维护一个隐式的等待队列来实现线程的公平性和高效性。CLH锁的核心思想是每个线程在进入临界区时都会在队列尾部排队，并且自旋等待前驱节点的状态变化。CLH
锁的特点是，它将等待线程的状态信息保存在前驱节点中，而不是在本线程中，这样就避免了过多的缓存一致性流量。</p>
<h3 id="隐式双向链表">隐式双向链表</h3>
<p><strong>加锁过程：</strong></p>
<ol type="1">
<li><strong>初始化</strong>：CLH 锁初始化时，<code>Tail</code>
指向一个状态为 <code>false</code> 的空节点。</li>
<li><strong>线程入队：</strong>
<ul>
<li>线程尝试获取锁时，创建一个状态为 <code>true</code>
的新节点，表示正在等待锁。</li>
<li>线程通过 CAS 操作将新节点插入队列尾部，并更新 <code>Tail</code>
指针。</li>
</ul></li>
<li><strong>轮询前驱节点状态</strong>：线程不断轮询其前驱节点的状态，直到前驱节点的状态变为
<code>false</code>，表示可以获取锁。</li>
</ol>
<p><strong>解锁过程：</strong></p>
<ol type="1">
<li><strong>释放锁</strong>：线程完成临界区访问后，将当前节点的状态设置为
<code>false</code>，表示释放锁。</li>
<li><strong>后继节点获取锁</strong>：后继节点检测到前驱节点状态变化，获取锁并进入临界区。</li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408292334794.png"></p>
<h2 id="aqs对clh锁的改造">AQS对CLH锁的改造</h2>
<p>CLH锁存在缺点：</p>
<ul>
<li>自旋操作，当锁持有时间长时会带来较大的 CPU 开销。</li>
<li>基本的 CLH 锁功能单一，不改造不能支持复杂的功能。</li>
</ul>
<p>Java 的 AbstractQueuedSynchronizer（AQS）借鉴了 CLH
锁的思想，并在此基础上做了诸多改进，使其更适合构建高效、可扩展的同步器。以下是
AQS 对 CLH 锁所做的一些主要改造：</p>
<h3 id="显式双向链表"><strong>显式双向链表</strong></h3>
<p>AQS
使用了显式的双向链表来维护等待队列，而不是隐式的单向链表。这样改进的好处是，它允许
AQS
更方便地处理队列中的节点操作，比如<strong>取消、唤醒特定节点</strong>等。</p>
<p>AQS 加锁过程：</p>
<ul>
<li><strong>初始化</strong>：AQS
初始化时，等待队列为空，<code>head</code> 和 <code>tail</code> 指针均为
<code>null</code>，<code>state</code> 表示锁的状态。</li>
<li><strong>线程入队</strong>：
<ul>
<li>当线程尝试获取锁时，AQS
会首先检查锁的状态（<code>state</code>）。如果锁已被其他线程占用，当前线程将无法直接获取锁。</li>
<li>线程会创建一个新的节点（<code>Node</code>），表示自己需要等待锁的释放。通过
CAS 操作，线程原子性地将该节点插入到等待队列的尾部，并更新
<code>tail</code> 指针指向该新节点。</li>
<li>如果队列为空，当前节点会成为队列中的第一个节点（即 <code>head</code>
节点）。</li>
</ul></li>
<li><strong>线程阻塞</strong>：如果当前线程无法立即获取锁（<code>state</code>
不为 0），线程会进入阻塞状态，调用 <code>LockSupport.park()</code>
挂起自己，等待其他线程释放锁。</li>
<li><strong>线程唤醒</strong>：当持有锁的线程释放锁时，会通过<code>LockSupport.unpark()</code>唤醒等待队列中的下一个线程。</li>
</ul>
<p>AQS 解锁过程：</p>
<ol type="1">
<li><strong>释放锁</strong>：持有锁的线程完成临界区的操作后，会调用
<code>release(int arg)</code> 方法将 <code>state</code> 变量设置为
0，表示锁已释放。</li>
<li><strong>唤醒后继节点</strong>：AQS 会调用
<code>LockSupport.unpark(Thread)</code> 来唤醒后继节点的线程，使其从
<code>park()</code> 的阻塞状态中恢复。</li>
<li><strong>后继节点获取锁</strong>：被唤醒的后继节点线程会重新尝试获取锁，通过
<code>CAS</code> 操作将 <code>state</code> 从 0 更新为
1。如果成功获取锁，线程将进入临界区执行任务。</li>
</ol>
<h3 id="多种同步模式"><strong>多种同步模式</strong></h3>
<p>AQS
提供了独占锁（exclusive）和共享锁（shared）两种模式。例如，<code>ReentrantLock</code>
使用的是独占模式，而 <code>Semaphore</code> 和
<code>CountDownLatch</code> 使用的是共享模式。</p>
<p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现钩子方法中的<code>tryAcquire-tryRelease</code>或<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但
AQS
也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h3 id="同步状态变量"><strong>同步状态变量</strong></h3>
<p>AQS 使用一个 <code>int</code> 型变量（称为同步状态
<code>state</code>）来表示锁的状态，而不是像 CLH
锁那样依赖前驱节点的布尔变量。AQS 通过 CAS
操作来修改这个状态，确保线程安全。</p>
<ul>
<li><strong>ReentrantLock
的可重入性</strong>：<code>ReentrantLock</code> 通过内部的
<code>state</code> 变量表示锁的占用状态。初始 <code>state</code> 为
0，表示未锁定。当线程 A 调用 <code>lock()</code> 时，通过
<code>tryAcquire()</code> 方法尝试获取锁并将 <code>state</code> 加
1。若获取成功，线程 A 可以多次获取同一锁，<code>state</code>
会累加，体现可重入性。释放时，<code>state</code> 减 1，直到回到
0，锁才真正释放，其他线程才有机会获取锁。</li>
<li><strong>CountDownLatch
的倒计时</strong>：<code>CountDownLatch</code> 使用 <code>state</code>
变量表示剩余的倒计时数。初始 <code>state</code> 为 N，表示 N
个子线程。每个子线程执行完任务后调用
<code>countDown()</code>，<code>state</code> 减
1。所有子线程执行完毕（<code>state</code> 变为
0）后，主线程被唤醒，继续执行后续操作。</li>
</ul>
<h2 id="实现同步器">实现同步器</h2>
<ul>
<li><strong>AQS 的设计</strong>：AQS
提供了一个基础的框架和队列管理功能，但具体的同步逻辑并没有在 AQS
中实现，而是留给具体的同步器来定义。这就是模板方法模式的典型应用：AQS
提供了模板方法，这些模板方法依赖于子类实现的钩子方法。</li>
<li><strong>重写钩子方法</strong>：具体的同步器，如
<code>ReentrantLock</code>、<code>Semaphore</code>，会通过其定义的<strong>内部类</strong>
<code>Sync</code> （继承自
AQS）来重写这些钩子方法。这些重写的方法决定了锁的行为（如是否公平、是否可重入、许可的数量等）。</li>
</ul>
<blockquote>
<p><strong>什么是钩子方法？</strong>
钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code>
关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>
<p>除了这些钩子方法，AQS类中其他方法都是final关键字修饰的，无法被重写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h1 id="常见同步工具类">常见同步工具类</h1>
<h2 id="reentrantlock">ReentrantLock</h2>
<p><strong>ReentrantLock是一种可重入的互斥锁，允许同一个线程在持有锁的情况下多次获取锁。它提供了更灵活的锁机制，可以显式地获取和释放锁，还支持公平锁和非公平锁的选择。通常用来实现线程间的同步，防止多个线程同时访问共享资源。</strong></p>
<p><code>ReentrantLock</code> 有一个内部类
<code>Sync</code>，<code>Sync</code> 继承
AQS，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code>
中实现的。<code>Sync</code> 有<strong>公平锁</strong>
<code>FairSync</code> 和<strong>非公平锁</strong>
<code>NonfairSync</code> 两个子类。</p>
<h3 id="公平锁非公平锁">公平锁/非公平锁</h3>
<ol type="1">
<li>抽象类<code>Sync</code>继承自AbstractQueuedSynchronizer，实现了AQS的部分方法；</li>
<li><code>NonfairSync</code>继承自<code>Sync</code>，实现了Sync中的方法，主要用于<strong>非公平锁</strong>的获取；</li>
<li><code>FairSync</code>继承自<code>Sync</code>，实现了Sync中的方法，主要用于<strong>公平锁</strong>的获取。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过构造方法实现公平锁或非公平锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造方法，ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自己可选择使用公平锁还是非公平锁，传入true是公平锁，传入false是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平锁和非公平锁只有两处不同：</p>
<ul>
<li><p><strong>公平锁：</strong>当调用<code>lock()</code>时，会先检查等待队列中是否有排队的线程。如果有排队线程，当前线程会加入队列排队；如果没有等待线程且锁没有被占用，则通过
CAS 操作直接获取锁。</p></li>
<li><p><strong>非公平锁：</strong>当调用<code>lock()</code>时，即使等待队列中有线程，非公平锁仍会尝试直接获取锁。如果CAS获取失败，则调用<code>nonfairTryAcquire()</code>方法，这时如果发现锁已经释放（<code>state == 0</code>），非公平锁会再次通过CAS立即尝试获取锁，不考虑等待队列中的其他线程。</p></li>
</ul>
<h3 id="可中断锁">可中断锁</h3>
<p>可中断锁与不可中断锁的区别在于：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。<code>lock</code>方法会忽略中断请求，继续获取锁直到成功；而<code>lockInterruptibly</code>则直接抛出中断异常来立即响应中断，由上层调用者处理中断。</p>
<ul>
<li><code>lock()</code>适用于锁获取操作不受中断影响的情况，此时可以忽略中断请求正常执行加锁操作，因为该操作仅仅记录了中断状态（通过<code>Thread.currentThread().interrupt()</code>操作，只是恢复了中断状态为true，并没有对中断进行响应)。</li>
<li>如果要求被中断线程不能参与锁的竞争操作，则应该使用<code>lockInterruptibly</code>方法，一旦检测到中断请求，立即返回不再参与锁的竞争并且取消锁获取操作（即finally中的cancelAcquire操作）</li>
</ul>
<h3 id="可重入锁">可重入锁</h3>
<p><code>ReentrantLock</code>对于可重入锁的实现依赖于<code>AOS</code>类，它的主要作用就是<strong>设置和获取持有独占锁的线程</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3737899427754241961L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractOwnableSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 当前锁的持有者（持有锁的线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">// 将当前线程设置为锁的持有者</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">// 获取当前锁的持有线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可重入锁获取和释放锁的流程如下：</p>
<ul>
<li><strong>线程获取锁的过程</strong>：
<ul>
<li>当一个线程首次获取锁时，AQS 会将<code>state</code>（代表锁的状态）从
0 增加到
1，表示锁已被占用，并通过<code>setExclusiveOwnerThread(当前线程)</code>方法将当前线程设置为锁的持有者。</li>
<li>如果当前线程尝试再次获取锁（即<strong>可重入</strong>），会检查<code>exclusiveOwnerThread</code>是否等于当前线程，如果是，则允许线程再次获取锁。此时，AQS（AbstractQueuedSynchronizer）会将<code>state</code>的值递增，记录线程重入的次数。</li>
</ul></li>
<li><strong>线程释放锁的过程</strong>：
<ul>
<li>当线程释放锁时，AQS
会将<code>state</code>的值递减。每释放一次，<code>state</code>的值减少
1，直到<code>state</code>减为 0 时，才表示锁被完全释放。</li>
<li>当锁被完全释放时，AQS 会将<code>state</code>减至
0，随后通过<code>setExclusiveOwnerThread(null)</code>方法清除锁的持有者，并唤醒等待队列中的下一个线程尝试获取锁。</li>
</ul></li>
</ul>
<h3 id="对比synchronized">对比synchronized</h3>
<ul>
<li><strong>两者都是可重入锁：</strong>
可重入锁也叫<strong>递归锁</strong>，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li>
<li><strong>获取和释放锁的动作不同：</strong>
<ul>
<li><code>synchronized</code> 是依赖于 JVM
实现的。当线程进入<code>synchronized</code>代码块或方法时，会自动获取锁，退出时自动释放锁。如果在<code>synchronized</code>代码块中抛出了异常，锁会自动释放。</li>
<li><code>ReentrantLock</code> 是 JDK 层面实现的，也就是 API
层面。需要<code>lock()</code>和<code>unlock()</code>方法配合
<code>try/finally</code>语句块来获取和释放锁。如果在<code>ReentrantLock</code>锁定的代码中抛出了异常，需要在<code>finally</code>块中手动释放锁，以确保锁的释放。</li>
</ul></li>
<li><strong>ReentrantLock增加了一些高级功能：</strong>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：
<ul>
<li><strong>等待可中断</strong> :
<code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过
<code>lock.lockInterruptibly()</code>
来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> :
<code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过
<code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>:
<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul></li>
</ul>
<h2 id="countdownlatch">CountDownLatch</h2>
<p><strong>CountDownLatch是一个计数器，它允许一个或多个线程等待其它线程完成操作后再继续执行，通常用来实现一个线程等待其它多个线程完成操作之后再继续执行的操作。</strong></p>
<p>CountDownLatch内部维护了一个计数器，该计数器通过CountDownLatch的构造方法指定。当调用<code>await()</code>方法时，它将一直阻塞，直到计数器变为0。当其它线程执行完指定的任务后，可以调用<code>countDown()</code>方法将计数器减一。当计数器减为0，所有的线程将同时被唤醒，然后继续执行。</p>
<h3 id="常用方法">常用方法</h3>
<blockquote>
<ul>
<li><strong>CountDownLatch(int
count)：</strong>CountDownLatch的构造方法，可通过count参数指定计数次数，但是要大于等于0，小于0会抛IIegalArgumentException异常。</li>
<li><strong>void
await()：</strong>如果计数器不等于0，会一直阻塞（在线程没被打断的情况下）。</li>
<li><strong>boolean await(long timeout,TimeUnit
unit)：</strong>除非线程被中断，否则会一直阻塞，直至计数器减为0或超出指定时间timeout，当计数器为0返回true，当超过指定时间，返回false。</li>
<li><strong>void
countDown()：</strong>调用一次，计数器就减1，当等于0时，释放所有线程。如果计数器的初始值就是0，那么就当没有用CountDownLatch吧。</li>
<li><strong>long
getCount()：</strong>返回当前计数器的数量，可以用来测试和调试。</li>
</ul>
</blockquote>
<h3 id="使用实例">使用实例</h3>
<p>定义线程任务，实现<code>Runnable</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountWork</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义测试类，使用for循环执行任务，知道任务结束完毕后打印结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CountWork</span> <span class="variable">countWork</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountWork</span>(countDownLatch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(countWork).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<p>可以发现，当所有任务执行完毕后，才执行了测试类后续的打印任务。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408301746656.png"></p>
<p>但是如果使用构造函数创建了4个计数<code>new CountDownLatch(4)</code>，但实际只有3个线程，则测试类阻塞，无法打印结果。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408301752103.png"></p>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p><strong>CyclicBarrier是一个同步屏障，它允许多个线程相互等待，直到到达某个公共屏障点，才能继续执行。通常用来实现多个线程在同一个屏障处等待，然后再一起继续执行的操作。</strong></p>
<p>CyclicBarrier也维护了一个类似计数器的变量，通过CyclicBarrier的构造函数指定，需要大于0，否则抛IllegalArgumenException异常。当线程到达屏障位置时，调用await()方法进行阻塞，直到所有线程到达屏障位置时，所有线程才会被释放，而屏障将会被重置为初始值以便下次使用。</p>
<h3 id="常用方法-1">常用方法</h3>
<blockquote>
<ul>
<li><strong>CyclicBarrier(int
parties)：</strong>CyclicBarrier的构造方法，可通过parties参数指定需要到达屏障的线程个数，但是要大于0，否则会抛IllegalArgumentException异常。</li>
<li><strong>CyclicBarrier(int parties,Runnable
barrierAction)：</strong>另一个构造方法，parties作用同上，barrierAction表示最后一个到达屏障点的线程要执行的逻辑。</li>
<li><strong>int
await()：</strong>表示线程到达屏障点，并等待其它线程到达，返回值表示当前线程在屏障中的位置（第几个到达的）。</li>
<li><strong>int await(long timeout,TimeUnit
unit)：</strong>与await()类似，但是设置了超时时间，如果超过指定的时间后，仍然还有线程没有到达屏障点，则等待的线程会被唤醒并执行后续操作。</li>
<li><strong>void
reset()：</strong>重置屏障状态，即将屏障计数器重置为初始值。</li>
<li><strong>int getParties()：</strong>获取需要同步的线程数量。</li>
<li><strong>int
getNumberWaiting()：</strong>获取当前正在等待的线程数量。</li>
</ul>
</blockquote>
<h3 id="使用实例-1">使用实例</h3>
<p>定义线程执行的任务，当线程执行完打印任务后，阻塞等待其他线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarrierTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义最终执行的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义测试类，当所有线程执行到屏障后，触发最终的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">FinalTask</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BarrierTask</span> <span class="variable">barrierTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BarrierTask</span>(cyclicBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(barrierTask, <span class="string">&quot;线程-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408301808915.png"></p>
<h3 id="对比countdownlatch">对比CountDownLatch</h3>
<ul>
<li>CyclicBarrier维护<strong>线程</strong>的计数，而CounDownLatch维护<strong>任务</strong>的计数。</li>
<li><strong>可重用性：</strong>两者最明显的差异就是可重用性。CyclicBarrier所有线程都到达屏障后，计数会重置为初始值。而CountDownLatch永远不会重置。</li>
</ul>
<h2 id="semaphore">Semaphore</h2>
<p><strong>Semaphore是一个计数信号量，它允许多个线程同时访问共享资源，并通过计数器来控制访问数量。它通常用来实现一个线程需要等待获取一个许可证才能访问共享资源，或者需要释放一个许可证才能完成的操作。</strong></p>
<p>Semaphore维护了一个内部计数器（许可permits），主要有两个操作，分别对应Semaphore的acquire和release方法。acquire方法用于获取资源，当计数器大于0时，将计数器减1；当计数器等于0时，将线程阻塞。release方法用于释放资源，将计数器加1，并唤醒一个等待中的线程。</p>
<h3 id="常用方法-2">常用方法</h3>
<blockquote>
<ul>
<li><strong>Semaphore(int
permits)：</strong>构造方法，permits表示Semaphore中的许可数量，它决定了同时可以访问某个资源的线程数量。</li>
<li><strong>Semaphore(int permits,boolean
fair)：</strong>构造方法，当fair为ture，设置为公平信号量。</li>
<li><strong>void
acquire()：</strong>获取一个许可，如果没有许可，则当前线程被阻塞，直到有许可。如果有许可该方法会将许可数量减1。</li>
<li><strong>void acquire(int
permits)：</strong>获取指定数量的许可，获取成功同样将许可减去指定数量，失败阻塞。</li>
<li><strong>void
release()：</strong>释放一个许可，将许可数加1。如果有其他线程正在等待许可，则唤醒其中一个线程。</li>
<li><strong>void release(int n)：</strong>释放n个许可。</li>
<li><strong>int availablePermits()：</strong>当前可用许可数。</li>
</ul>
</blockquote>
<h3 id="使用实例-2">使用实例</h3>
<p>信号量的构造方法传入参数为5，设置六个进程获取这5个资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    Semaphore park;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SemaphoreTest</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">        park = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        park.acquire();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leave</span><span class="params">()</span> &#123;</span><br><span class="line">        park.release();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 驶出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreTest</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test.enter();</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                test.leave();</span><br><span class="line">            &#125;, <span class="string">&quot;车牌号&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回结果：</strong></p>
<p>可以发现同一时刻只有五个线程获取到资源，当有资源释放时（车牌号5
驶出），其他线程才能获取资源（车牌号6 进入）。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408301706432.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>AQS机制</tag>
        <tag>ReentrantLock</tag>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程】全面解析volatile和synchronized关键字</title>
    <url>/2024/09/10/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90volatile%E5%92%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="volatile">volatile</h1>
<h2 id="可见性问题">可见性问题</h2>
<ol type="1">
<li><strong>Java内存模型</strong>：
<ul>
<li>在Java内存模型（JMM）中，每个线程有自己的<strong>工作内存</strong>（这是一个抽象概念，不同于物理内存中的缓存），用于存储从主内存中读取的变量副本。线程对变量的操作（如读取、写入）通常在其工作内存中进行，而不是直接在主内存中操作。</li>
<li>当一个线程修改了工作内存中的变量副本后，新的值可能不会立即刷新回主内存。这意味着其他线程在其工作内存中读取该变量时，可能仍然看到旧值，而不是最新值。</li>
</ul></li>
<li><strong>CPU缓存机制</strong>：
<ul>
<li>在物理层面上，现代CPU使用多级缓存（如L1、L2、L3）来加速内存访问。每个处理器核心可能会将主内存中的数据加载到自己的缓存中，并在缓存中进行操作。</li>
<li>当一个线程运行在一个处理器核心上，并修改了缓存中的数据，其他处理器核心的缓存可能不会立即同步这些修改，导致其他线程看到的是旧数据。这种情况在多核处理器系统中尤为常见。</li>
</ul></li>
<li><strong>指令重排序</strong>：
<ul>
<li>为了优化性能，编译器和CPU可能会对指令进行重排序。例如，编译器可能会将一些操作的顺序调整，使得对变量的读取和写入操作不按程序的逻辑顺序执行。</li>
<li>这种重排序可能导致一个线程的操作在另一个线程中以错误的顺序被观察到，特别是在没有适当的同步措施时。例如，线程A可能先执行了对变量的写操作，而线程B却在此之前读取了这个变量的旧值。</li>
</ul></li>
</ol>
<h2 id="变量可见性">变量可见性</h2>
<p><code>volatile</code>
关键字可以强制将变量的更新<strong>立即写入主内存</strong>，并确保其他线程读取时能看到最新的值。如果我们将变量声明为
<code>volatile</code> ，这就指示
JVM，这个变量是共享且不稳定的，每次使用它都到<strong>主存中进行读取</strong>。</p>
<p><code>volatile</code>
关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code>
关键字两者都能保证。</p>
<h2 id="指令重排序">指令重排序</h2>
<p><strong>在 Java 中，<code>volatile</code>
关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM
的指令重排序。</strong> 如果我们将变量声明为
<strong><code>volatile</code></strong>
，在对这个变量进行读写操作的时候，会通过插入特定的
<strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<p><strong>指令重排序的分类：</strong></p>
<ol type="1">
<li><strong>JVM重排序</strong>：JVM在将字节码转换为机器码时，可能会进行指令的重新排列。</li>
<li><strong>CPU重排序</strong>：处理器在执行机器码指令时，也可能会根据当前的硬件状态（如缓存、流水线等）对指令进行重新排列。</li>
<li><strong>编译器重排序</strong>：编译器在编译代码时可能会调整代码的顺序，以生成更高效的字节码。</li>
</ol>
<p><strong>指令重排序导致的问题</strong></p>
<p>指令重排序在单线程环境中通常不会导致问题，因为编译器和处理器都会确保程序的最终结果与代码的顺序一致。然而，在多线程环境下，指令重排序可能会导致数据可见性和线程安全问题。</p>
<ul>
<li><strong>可见性问题</strong>：由于指令重排序，一个线程可能在另一个线程未完成操作前看到中间状态的变量值，导致读取到不正确的数据。</li>
<li><strong>线程安全问题</strong>：当多个线程同时访问和修改共享变量时，如果没有适当的同步机制，指令重排序可能会使得线程间的操作顺序不同于预期，从而引发竞态条件，导致程序行为异常。</li>
</ul>
<h1 id="synchronized">synchronized</h1>
<p><strong><code>synchronized</code> 是 Java
中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<h2 id="使用方法">使用方法</h2>
<p><strong>1.修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得
<strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得
<strong>当前 class 的锁</strong>。</p>
<p><strong>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.修饰代码块</strong> （锁指定对象/类）</p>
<p>对括号里指定的对象/类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得
<strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得
<strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="构造方法可以使用synchronized吗">构造方法可以使用synchronized吗？</h4>
<p>不能，因为构造方法本来就是线程安全的，不存在同步的构造方法一说。</p>
<h4 id="静态-synchronized-方法和非静态-synchronized-方法之间的调用互斥吗">静态
<code>synchronized</code> 方法和非静态 <code>synchronized</code>
方法之间的调用互斥吗？</h4>
<p>不互斥。因为访问静态 <code>synchronized</code>
方法占用的锁是<strong>当前类</strong>的锁，而访问非静态
<code>synchronized</code>
方法占用的锁是<strong>当前实例</strong>的锁。</p>
</blockquote>
<h2 id="加锁方式">加锁方式</h2>
<p><code>synchronized</code>关键字对方法加锁是通过方法的<code>flags</code>标志来实现的，而对同步代码块加锁则是通过<code>monitorenter</code>和<code>monitorexit</code>指令来实现的。</p>
<ul>
<li><strong>同步方法</strong>的<code>flags</code>里面多了一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法是，会检查是否存在<code>ACC_SYNCHRONIZED</code>标识，如果有设置，则需要先获取监视器锁，方法执行后再释放监视器锁。</li>
<li><strong>同步代码块</strong>是由<code>monitorenter</code>获取锁，然后<code>monitorexit</code>释放锁。在执行<code>monitorenter</code>之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加一。当执行<code>monitorexit</code>指令时，锁的计数器也会减一。当获取锁失败时会被阻塞，一直等待锁被释放。</li>
</ul>
<h2 id="对象结构分析">对象结构分析</h2>
<p>要深入理解 <code>synchronized</code> 的实现原理，必须先了解 Java
对象在内存中的布局，尤其是对象头中的 <code>Mark Word</code>。</p>
<h3 id="对象内存结构">对象内存结构</h3>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3
块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<ul>
<li><strong>对象头</strong>包括两部分信息：
<ol type="1">
<li><strong>标记字段（Mark
Word）</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC
分代年龄、锁状态标志、线程持有的锁、偏向线程
ID、偏向时间戳等等。<strong><code>synchronized</code>就是依靠<code>Mark Word</code>字段来进行锁升级、获取锁等操作的。</strong></li>
<li><strong>类型指针（Klass
Word）</strong>：对象指向它的类元数据的指针，JVM可以通过该指针来确定这个对象是哪个类的实例。</li>
</ol></li>
<li><strong>实例数据</strong>是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>
<li><strong>对齐填充</strong>不是必然存在的，也没有什么特别的含义，仅仅起占位作用。
因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8
字节的整数倍，换句话说就是对象的大小必须是 8
字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2
倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<h3 id="mark-word">Mark Word</h3>
<p><strong><code>Mark Word</code>
不仅存储了对象的基本信息，还承担着锁状态的管理职责，包括锁的获取、升级、释放等操作。</strong>正是通过对
<code>Mark Word</code> 的精细控制，Java
虚拟机（JVM）才能高效地实现线程同步机制，从而保障并发环境下的数据一致性和程序的正确性。</p>
<p>在Java中，锁的状态分为四种，分别是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p><code>Mark Word</code>的低两位用于表示锁的状态，分别为"01"(无锁状态)、"01"(偏向锁状态)、"00"(轻量级锁状态)和"10"(重量级锁状态)。但是由于无锁状态和偏向锁都是”01"，所以在低三位引入偏向锁标记位用"0"表示无锁，"1"表示偏向。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202409101450474.png"></p>
<h2 id="锁升级过程">锁升级过程</h2>
<p>对于<code>synchronized</code>关键字，一共有四种状态：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>（级别从低到高）。</p>
<h3 id="偏向锁">偏向锁</h3>
<p>偏向锁提升性能的经验依据是：<strong>对于绝大部分锁，在整个同步周期内不仅不存在竞争，而且总由同一线程多次获得。</strong>偏向锁会偏向第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程不需要再进行同步。这使得线程获取锁的代价更低。</p>
<blockquote>
<p><strong>触发条件：</strong>如果JVM启动参数没有禁用偏向锁，那么首次进入<code>synchronized</code>块时会自动开启。</p>
</blockquote>
<p><strong>偏向锁的获取过程：</strong></p>
<ul>
<li><p><strong>初始状态：</strong>当一个对象刚创建时，它处于无锁状态。此时，<code>Mark Word</code>
中包含对象的哈希码和其他一些标记信息。</p></li>
<li><p><strong>线程尝试加锁：</strong>当线程第一次访问这个对象并进入
<code>synchronized</code> 块时，JVM 会将 <code>Mark Word</code>
中的锁标志位设置为偏向锁，并将该线程的 ID 记录在 <code>Mark Word</code>
中。这样，锁就“偏向”于这个线程。</p></li>
<li><p><strong>偏向锁加锁成功：</strong>如果同一线程再次访问该对象的
<code>synchronized</code> 块，JVM 检查 <code>Mark Word</code> 中的线程
ID，如果与当前线程的 ID
匹配，则认为该线程已经持有了锁，无需执行任何额外操作，直接进入同步块。这避免了加锁和解锁的开销；如果JVM
发现<code>Mark Word</code> 中的线程 ID
与当前线程不符，偏向锁就会被撤销。偏向锁撤销的过程包括：</p>
<ul>
<li>偏向锁升级为轻量级锁：JVM 会暂停持有偏向锁的线程，撤销偏向锁，将
<code>Mark Word</code>
更新为指向轻量级锁的状态，并将锁记录在新的线程的栈中。</li>
<li>新线程继续尝试获取锁：如果当前没有其他线程竞争锁，新的线程将获取轻量级锁；否则，锁将进一步升级为重量级锁。</li>
</ul></li>
</ul>
<p><strong>偏向锁的释放过程：</strong></p>
<ul>
<li><p><strong>解锁时：</strong>当持有偏向锁的线程退出
<code>synchronized</code> 块时，锁不会立即释放，<code>Mark Word</code>
中的线程 ID 和偏向标记位保持不变，仍然表示锁偏向于该线程。</p></li>
<li><p><strong>锁重入：</strong>如果偏向锁的线程再次进入
<code>synchronized</code>
块，可以直接重用这个锁而无需加锁操作。</p></li>
<li><p><strong>锁撤销（偏向锁失效）：</strong>如果另一线程尝试访问同一个对象的<code>synchronized</code>块，JVM
发现<code>Mark Word</code> 中的线程 ID
与当前线程不符，偏向锁就会升级为轻量级锁。</p></li>
</ul>
<h3 id="轻量级锁">轻量级锁</h3>
<p><code>轻量级锁</code>是相对基于OS的互斥量实现的重量级锁而言的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用OS的互斥量而带来的性能消耗。</p>
<p>轻量级锁提升性能的经验依据是：<strong>对于绝大部分锁，在整个同步周期内都是不存在竞争的</strong>。如果没有竞争，轻量级锁就可以使用
CAS 操作避免互斥量的开销，从而提升效率。</p>
<blockquote>
<p><strong>触发条件：</strong>当有另一个线程尝试获取已被偏向的锁时，偏向锁会升级为轻量级锁。</p>
</blockquote>
<p><strong>轻量级锁的加锁过程：</strong></p>
<ul>
<li><p><strong>创建锁记录（Lock
Record）：</strong>当线程进入同步代码块时，JVM
会在当前线程的栈帧中创建一个锁记录（Lock
Record）。这个锁记录用于存储对象当前的 <code>Mark Word</code>
的副本，称为 <strong>Displaced Mark Word</strong>。此时，锁记录中的
<code>_owner</code> 指针会指向对象的 <code>Mark Word</code>。</p></li>
<li><p><strong>CAS 尝试加锁：</strong>JVM 使用
CAS（Compare-And-Swap）操作尝试将对象头中的 <code>Mark Word</code>
更新为指向线程栈中 <code>Lock Record</code> 的指针。如果 CAS
操作成功，则表明当前线程获取了轻量级锁，锁的标志位（lock state
bits）将更新为 <code>00</code>，表示轻量级锁。</p></li>
<li><p><strong>加锁成功：</strong>若 CAS
操作成功，表示该线程已经拥有了该对象的锁，可以安全地进入同步代码块执行。</p></li>
<li><p><strong>加锁失败（锁竞争）：</strong>如果 CAS 操作失败，JVM
会检查对象的<code>Mark Word</code>
是否指向当前线程的栈帧中的锁记录：</p>
<ul>
<li><strong>当前线程已拥有锁：</strong> 如果 <code>Mark Word</code>
已经指向当前线程的锁记录，说明该线程已拥有锁，可以直接进入同步代码块继续执行。</li>
<li><strong>锁被其他线程持有：</strong> 如果 <code>Mark Word</code>
指向的是其他线程的锁记录，说明锁被其他线程占用。此时，当前线程会尝试通过
<strong>自旋</strong> 一定次数获取锁。如果在多次自旋后 CAS
仍然失败，轻量级锁会升级为 <strong>重量级锁</strong>（标志位更新为
<code>10</code>），并将 <code>Mark Word</code>
指向重量级锁的指针。之后，未获得锁的线程将进入阻塞状态，等待锁的释放。</li>
</ul></li>
</ul>
<p><strong>轻量级锁的解锁过程：</strong></p>
<ul>
<li><p><strong>CAS 释放锁：</strong>当线程退出同步代码块时，JVM 会使用
CAS 操作，将线程中锁记录的 <strong>Displaced Mark Word</strong>
恢复到对象的 <code>Mark Word</code>，即通过 CAS 将对象头的
<code>Mark Word</code> 替换为最初的值。</p></li>
<li><p><strong>解锁成功：</strong>如果 CAS
操作成功，意味着锁成功释放，整个同步过程完成。</p></li>
<li><p><strong>解锁失败（锁竞争）：</strong>如果 CAS
操作失败，说明有其他线程正在尝试获取该锁，或者锁已经升级为重量级锁。在这种情况下，JVM
会在释放锁的同时，唤醒等待该锁的阻塞线程。</p></li>
</ul>
<h3 id="重量级锁">重量级锁</h3>
<h4 id="监视器锁实现">监视器锁实现</h4>
<p><code>synchronized</code>
关键字用于实现线程同步，而它的底层是通过<strong>监视器锁（Monitor）</strong>来实现的。无论是对方法加锁还是对同步代码块加锁，JVM
都是依赖 <code>monitor</code>
机制来保证同步。在进入同步代码块之前，线程必须先获取监视器锁。成功获取锁后，锁的计数器增加
1；执行完同步代码后，计数器减少
1。如果线程无法获取锁，它会进入阻塞状态，直到锁被释放。</p>
<p>在Hotspot中，对象的监视器（monitor）锁对象由<code>ObjectMonitor</code>对象实现（C++），其跟同步相关的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//用来记录该对象被线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>;</span><br><span class="line">    _recursions   = <span class="number">0</span>; <span class="comment">//锁的重入次数</span></span><br><span class="line">    _owner        = NULL; <span class="comment">//指向持有ObjectMonitor对象的线程 </span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的monitor后进入<code>_owner</code>区域并把
monitor 中的<code>_owner</code>变量设置为当前线程，同时 monitor
中的计数器<code>count</code>加一，即获得对象锁。</p>
<p>若持有 monitor 的线程调用<code>wait()</code>方法，将释放当前持有的
monitor，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减一，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放
monitor(锁)并复位变量的值，以便其他线程进入获取 monitor(锁)。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202409010003677.png"></p>
<h4 id="加解锁">加解锁</h4>
<p>监视器锁<code>monitor</code>本质上是依赖操作系统的 Mutex Lock 互斥量
来实现的，我们一般称之为<code>重量级锁</code>。因为 OS
实现线程间的切换需要从用户态转换到核心态，这个转换过程成本较高，耗时相对较长，因此<code>synchronized</code>效率会比较低。</p>
<p>重量级锁的锁标志位为'10'，指针指向的是<code>monitor</code>对象的起始地址。</p>
<p><strong>只有在使用重量级锁时，才会涉及到 <code>monitor</code>
及线程状态的控制</strong>。线程的生命周期分为五个状态，分别是初始状态（new）、运行状态（runnable）、等待状态（waiting）、阻塞状态（blocking）和终止状态（terminated）。</p>
<blockquote>
<p><strong>触发条件：</strong>当轻量级锁的CAS操作失败，轻量级锁升级为重量级锁。</p>
</blockquote>
<p><strong>重量级锁的加锁过程：</strong></p>
<ul>
<li><strong>线程进入阻塞队列：</strong>如果锁已被其他线程持有，后续尝试获取该锁的线程会进入
<code>ObjectMonitor</code> 对象的 <code>_EntryList</code>
队列，处于<strong>阻塞状态</strong>等待锁。</li>
<li><strong>线程获取锁进入运行状态：</strong>成功获取锁的线程会从
<code>_EntryList</code>
中移出，进入<strong>运行状态</strong>。此时，<code>ObjectMonitor</code>
的 <code>_owner</code> 字段指向该线程，<code>_count</code>
加一。如果线程重入锁，<code>_count</code> 递增。</li>
<li><strong>调用 <code>wait()</code> 方法进入等待状态：</strong>线程调用
<code>wait()</code> 时，释放 <code>monitor</code>
锁，进入<strong>等待状态</strong>，<code>_owner</code> 置为
<code>null</code>，<code>_count</code> 减一。线程进入
<code>_WaitSet</code> 队列，等待 <code>notify()</code> 或
<code>notifyAll()</code> 唤醒。</li>
<li><strong>线程被唤醒后重新竞争锁：</strong>被唤醒的线程从
<code>_WaitSet</code> 移至 <code>_EntryList</code>
队列，重新竞争锁。获取锁后，进入<strong>运行状态</strong>，<code>_owner</code>
指向该线程。</li>
</ul>
<p><strong>重量级锁的解锁过程：</strong></p>
<ul>
<li><strong>线程正常退出同步代码块：</strong>线程退出同步代码块时，<code>_count</code>
减一。若 <code>_count</code> 为零，表示锁完全释放。</li>
<li><strong>释放锁和唤醒其他线程：</strong>如果 <code>_count</code>
为零，<code>_owner</code> 置为 <code>null</code>。如果
<code>_EntryList</code> 队列中有其他线程，JVM
会唤醒其中一个，让其尝试获取锁。</li>
<li><strong>线程退出或等待结束：</strong>线程执行完同步代码或被唤醒后，若锁可用，获取锁并继续执行，否则重新进入阻塞队列。锁释放时，<code>_owner</code>
置为 <code>null</code>，其他线程有机会获取锁。</li>
</ul>
<h2 id="锁优化">锁优化</h2>
<h3 id="自旋锁">自旋锁</h3>
<ul>
<li><strong>获取轻量级锁时：</strong>即当一个线程尝试获取一个被其他线程持有的轻量级锁时，会自旋等待锁的持有者释放锁。
<ul>
<li>在<code>OpenJDK 8</code>中，轻量级锁的自旋默认是开启的，最多自旋15次，每次自旋的时间逐渐延长。如果15次自旋后仍然没有获取到锁，就会升级为重量级锁。</li>
</ul></li>
<li><strong>获取重量级锁时：</strong>即当一个线程尝试获取一个被其他线程持有的重量级锁时，它会自旋等待锁的持有者释放锁。
<ul>
<li>在<code>OpenJDK 8</code>中，默认情况下不会开启重量级锁自旋。如果线程在尝试获取重量级锁时，发现该锁已经被其他线程占用，那么线程会直接阻塞，等待锁被释放。如果锁被持有时间很短，可以考虑开启重量级锁自旋，避免线程挂起和恢复带来的性能损失。</li>
</ul></li>
<li><strong>自适应自旋：</strong>在<code>JDK6</code>之后的版本中，JVM引入了自适应的自旋机制。该机制通过监控轻量级锁自旋等待的情况，动态调整自旋等待的时间。
<ul>
<li>如果自旋等待的时间很短，说明锁的竞争不激烈，当前线程可以自旋等待一段时间，避免线程挂起和恢复带来的性能损失。如果自旋等待的时间较长，说明锁的竞争比较激烈，当前线程应该及时释放CPU资源，让其他线程有机会执行。</li>
</ul></li>
</ul>
<h3 id="锁消除">锁消除</h3>
<p>锁消除是JVM在编译或即时编译（JIT）过程中通过逃逸分析判断锁对象是否只在单个线程中使用。<strong>如果确定该锁对象不会逃逸到其他线程，即它只在当前线程中被使用，JVM会自动移除这些不必要的同步锁，从而减少锁的开销。</strong></p>
<h3 id="锁粗化">锁粗化</h3>
<p>锁粗化是指将多个连续的、临近的小范围锁操作合并为一个更大的锁操作，以减少加锁和解锁的频率，从而提高性能。<strong>锁粗化的主要目的是避免在短时间内频繁进行锁的获取和释放操作，因为每次加锁和解锁都带有一定的开销。</strong></p>
<h1 id="两者比较">两者比较</h1>
<p><code>synchronized</code> 关键字和 <code>volatile</code>
关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以
<code>volatile</code>性能肯定比<code>synchronized</code>关键字要好
。但是 <code>volatile</code> 关键字只能用于<strong>变量</strong>而
<code>synchronized</code>
关键字可以<strong>修饰方法以及代码块</strong>。</li>
<li><code>volatile</code>
关键字<strong>能保证数据的可见性</strong>，但<strong>不能保证数据的原子性</strong>。<code>synchronized</code>
关键字<strong>两者都能保证</strong>。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而
<code>synchronized</code>
关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>【常用集合】深入浅出Map集合</title>
    <url>/2024/09/29/%E3%80%90%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E3%80%91%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMap%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="hashmap">HashMap</h2>
<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的
Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null
作为键只能有一个，null 作为值可以有多个。</p>
<h3 id="底层实现">底层实现</h3>
<p>通过 key 的 <code>hashCode</code> 经扰动函数处理得到 hash 值，并通过
<code>hash &amp; (length - 1)</code>
确定存储位置（length为数组的长度）。若位置已有元素，比较 hash 值和
key，相同则覆盖，不同则用链表解决冲突。扰动函数用于优化
<code>hashCode()</code> 实现，减少哈希碰撞。</p>
<h4 id="存储结构"><strong>存储结构</strong></h4>
<ul>
<li>在 JDK 1.8 之前，<code>HashMap</code> 采用 <strong>链地址法</strong>
来解决哈希冲突，即将数组与链表结合使用。当多个元素的哈希值映射到同一个桶位时，<code>HashMap</code>
会在该桶位置创建一个链表，所有冲突的元素都以链表的形式存储。在插入新元素时，<code>HashMap</code>
使用
<strong>头插法</strong>，将新元素插入链表的开头位置，以此处理哈希冲突。</li>
<li>在 JDK 1.8 之后，<code>HashMap</code>
解决哈希冲突的方式进行了优化，仍然采用 <strong>数组+链表</strong>
的结构，但引入了 <strong>红黑树</strong>
来提高性能。当某个桶位上的链表长度超过阈值（默认
8），并且哈希表桶的长度大于64时，链表会转换为红黑树，从而将链表的查询元素的时间复杂度由
O(n) 降低为 O(log n)。这样，当哈希冲突较多时，<code>HashMap</code>
仍然能够保持较高的查询和插入效率。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202409181054262.png" style="zoom: 25%;"></p>
<h4 id="数据插入方式">数据插入方式</h4>
<p>在 JDK 1.7 及之前的版本中，<code>HashMap</code>
在多线程环境下进行扩容时，由于使用<strong>头插法</strong>重排链表，<strong>多个线程同时操作同一桶位的链表</strong>可能导致节点指向错误，形成环形链表，从而引发死循环。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap
采用了<strong>尾插法</strong>来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<h4 id="长度取值">长度取值</h4>
<p><code>HashMap</code> 默认的初始化大小为
16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code>
总是使用 2 的幂作为哈希表的大小。长度采用 2
的幂，是因为二进制位操作<code>&amp;</code>相对于取模运算<code>%</code>能够提高效率。<strong>位运算直接对内存数据操作，不需要转换成10进制进行取模运算。</strong></p>
<p><strong>公式（<code>hash % length == hash &amp; (length - 1)</code>成立的前提是Hash表的长度是
2 的 n 次方</strong>。</p>
<h3 id="并发安全问题">并发安全问题</h3>
<h4 id="死锁问题">死锁问题</h4>
<p>在 JDK 1.7 及之前的版本中，<code>HashMap</code>
在多线程环境下进行扩容时，由于使用<strong>头插法</strong>重排链表，<strong>多个线程同时操作同一桶位的链表</strong>可能导致节点指向错误，形成环形链表，从而引发死循环。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap
采用了<strong>尾插法</strong>来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<h4 id="其他问题">其他问题</h4>
<ul>
<li>多线程put的时候，size的个数和真正的个数不一样</li>
<li>多线程put的时候，可能会把上一个put的值覆盖掉</li>
<li>当既有get操作，又有扩容操作的时候，有可能数据刚好被扩容换了桶，导致get不到数据</li>
<li>和其他不支持并发的集合一样，HashMap也采用了<code>fail-fast</code>操作，当多个线程同时put和get的时候，会抛出并发异常</li>
</ul>
<h3 id="扩容机制">扩容机制</h3>
<h4 id="触发扩容">触发扩容</h4>
<p><code>HashMap</code>
中的容量阈值（<code>threshold</code>）是由当前数组容量与负载因子相乘得到的<code>capacity * loadFactor</code>。当
<code>HashMap</code>
中的元素数量超过这个阈值时，会触发扩容操作。默认的负载因子为
<code>0.75</code>，数组的初始容量为 <code>16</code>。</p>
<h4 id="扩容过程">扩容过程</h4>
<p>在扩容过程中，<code>HashMap</code>
会创建一个新的数组，容量是原数组的两倍。所有原数组的元素都会被重新分配到这个新数组中。</p>
<h4 id="节点迁移">节点迁移</h4>
<ul>
<li><strong>桶元素重新映射：</strong>如果桶中只有一个元素，没有形成链表，则将原来的桶引用置为null，同时，将该元素进行<code>rehash</code>即可。</li>
<li><strong>链表重新链接：</strong>扩容后的数据迁移实际上是部分的，一些元素保持原位置，而另一些元素则会被迁移到新的位置。这种优化减少了不必要的数据移动，提升了扩容操作的效率。
<ol type="1">
<li><strong>保持原位置</strong>：对于某个元素，如果
<code>hash &amp; oldLength == 0</code>，那么该元素在扩容后的新数组中仍然保留在原位置。</li>
<li><strong>移动到新位置</strong>：如果
<code>hash &amp; oldLength != 0</code>，那么该元素在扩容后的新数组中的位置将从
<code>index</code> 变为 <code>index + oldLength</code>。</li>
</ol></li>
<li><strong>取消树化：</strong>类似于上述链表的重新链接，当重新链接操作完毕后，会判断两个哈希桶上的链表长度是否小于等于6，如果满足条件，会将红黑树取消树化，退化成链表。</li>
</ul>
<p>示例：旧哈希桶长度为8，有a、b、c、d四个元素，存储在下标为3的哈希桶上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(a)=<span class="number">3</span>;  hash(a)&amp;<span class="number">7</span>=<span class="number">3</span>;</span><br><span class="line">hash(b)=<span class="number">11</span>; hash(b)&amp;<span class="number">7</span>=<span class="number">3</span>;</span><br><span class="line">hash(c)=<span class="number">27</span>; hash(c)&amp;<span class="number">7</span>=<span class="number">3</span>;</span><br><span class="line">hash(d)=<span class="number">59</span>; hash(d)&amp;<span class="number">7</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>如果扩容为16，由于<code>hash(a)&amp;8=0;</code>无需移动，其他的不为零的元素移动到<code>index + oldLength = 3 + 8 = 11</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(a)=<span class="number">3</span>;  hash(a)&amp;<span class="number">8</span>=<span class="number">0</span>; hash(a)&amp;<span class="number">15</span>=<span class="number">3</span>;</span><br><span class="line">hash(b)=<span class="number">11</span>; hash(b)&amp;<span class="number">8</span>=<span class="number">8</span>; hash(b)&amp;<span class="number">15</span>=<span class="number">11</span></span><br><span class="line">hash(c)=<span class="number">27</span>; hash(c)&amp;<span class="number">8</span>=<span class="number">8</span>; hash(c)&amp;<span class="number">15</span>=<span class="number">11</span></span><br><span class="line">hash(d)=<span class="number">59</span>; hash(d)&amp;<span class="number">8</span>=<span class="number">8</span>; hash(d)&amp;<span class="number">15</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么HashMap的负载因子设置为0.75？</strong></p>
<ul>
<li><strong>性能和空间的平衡：</strong>
<ul>
<li>负载因子过低（例如
0.5），意味着更频繁地扩容，虽然哈希冲突会减少，但空间利用率较低，增加了内存消耗。</li>
<li>负载因子过高（例如
1.0），虽然提高了空间利用率，但增加了哈希冲突的概率，降低了查找和插入的效率。</li>
</ul></li>
<li><strong>数学依据：</strong>
<ul>
<li>负载因子选择为0.75（3/4），可以保证临界值
<code>threshold = loacFactor * capacity</code>为整数。</li>
</ul></li>
</ul>
</blockquote>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<h3 id="底层实现-1">底层实现</h3>
<h4 id="同hashmap">同HashMap</h4>
<h4 id="线程安全">线程安全</h4>
<ul>
<li><strong>JDK1.8之前：</strong>
<ul>
<li><strong>使用分段锁</strong>：在 JDK 1.7
及之前，<code>ConcurrentHashMap</code>
通过<strong>分段锁机制</strong>来实现线程安全。它将整个哈希表分为多个段（<code>Segment</code>），每个段内部维护一个独立的哈希表和锁。当对
<code>ConcurrentHashMap</code>
进行并发操作时，不同的线程可以同时操作不同的段，从而提高并发性。</li>
<li><strong>Segment 是继承了 ReentrantLock
的子类</strong>：每个段都有自己独立的可重入锁，而操作的同步性依赖于
<code>Segment</code> 的锁机制。</li>
</ul></li>
<li><strong>JDK1.8之后：</strong>
<ul>
<li><strong>移除了分段锁</strong>：在 JDK 1.8
中，<code>ConcurrentHashMap</code>
不再使用分段锁。相反，它直接使用了一个<code>Node&lt;K, V&gt;[]</code><strong>数组</strong>来存储键值对，并且通过<strong>更细粒度的锁</strong>和<strong>无锁操作</strong>来实现线程安全。</li>
<li><strong>CAS
操作</strong>：在插入和删除节点时，<code>ConcurrentHashMap</code> 使用
CAS（Compare-And-Swap）来确保并发安全。例如，当向一个空桶中插入第一个节点时，<code>ConcurrentHashMap</code>
会使用 CAS 操作直接插入，这样可以避免锁的使用。</li>
<li><strong><code>Synchronized</code>
锁</strong>：在一些复杂操作（如链表或红黑树的插入或删除）中，<code>ConcurrentHashMap</code>
使用 <code>synchronized</code>
来锁定特定的桶（<code>Node</code>），而不是整个段或整个哈希表。这种方式虽然引入了锁，但锁的粒度非常小，只会锁定冲突的桶，因此可以大大减少锁竞争。</li>
</ul></li>
<li><strong>并发度：</strong>
<ul>
<li>JDK1.8之前，最大并发度是<code>Segment</code>的个数，默认是 16。</li>
<li>JDK1.8之后，最大并发度是<code>Node&lt;K, V&gt;[]</code>数组的大小，并发度更大。</li>
</ul></li>
</ul>
<h3 id="为什么key和value都不能为null">为什么key和value都不能为null?</h3>
<p><code>null</code>是一个特殊的值，表示没有对象或没有引用。</p>
<ul>
<li><code>key</code>为null：
<ul>
<li><strong>防止异常</strong>：如果键为
<code>null</code>，哈希计算过程中会抛出
<code>NullPointerException</code>。</li>
</ul></li>
<li><code>value</code>为null：
<ul>
<li><strong>简化实现</strong>：在并发条件下无需对null值进行特殊处理，减少条件分支，提高可维护性。</li>
<li><strong>避免二义性</strong>：如果使用<code>get(key)</code>方法获取的<code>value</code>为null，则可能该
<code>key</code> 存在，但其对应的值是 <code>null</code>；或者该
<code>key</code> 不存在。</li>
</ul></li>
</ul>
<h3 id="保证复合操作的原子性">保证复合操作的原子性</h3>
<p><code>ConcurrentHashMap</code>
是线程安全的，这意味着它能够保证在多线程环境下对其进行并发读写操作时，不会出现数据不一致的情况。此外，它也避免了
JDK 1.7 及之前版本的 <code>HashMap</code> 中，在多线程操作时可能导致的
<strong>死循环问题</strong>。然而，<strong>线程安全</strong> 不等于
<strong>原子性</strong>，尤其是在涉及多个操作的情况下，<strong><code>ConcurrentHashMap</code>
并不能确保所有的复合操作都是原子性的</strong>。</p>
<blockquote>
<p><strong>复合操作：</strong>是指由多个基本操作（如
<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>
等）组合而成的操作。</p>
<p>例如：如果多个线程同时调用 <code>containsKey</code>
进行检查并随后调用
<code>put</code>，在第一个线程判断某个键不存在时，另一个线程可能已经插入了该键，这样第一个线程的操作就会覆盖另一个线程的结果，导致数据不一致。</p>
</blockquote>
<p>为了解决复合操作的原子性问题，<code>ConcurrentHashMap</code>
提供了一些内置的<strong>原子复合操作方法</strong>。这些方法能够确保整个操作过程在并发环境下是原子性的，即要么全部成功，要么全部失败，不会出现中间状态。</p>
<ul>
<li><strong><code>putIfAbsent(K key, V value)</code></strong>
<ul>
<li>如果指定的键 <code>key</code> 尚未存在于
<code>ConcurrentHashMap</code> 中，则将其对应的值设置为
<code>value</code>。该操作是原子性的，能够确保在并发情况下，只有第一个插入的线程成功，后续插入将被忽略。</li>
<li>这种操作特别适合用于避免重复插入。</li>
</ul></li>
<li><strong><code>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code></strong>
<ul>
<li>只有当指定的键 <code>key</code> 存在时，才会根据提供的
<code>remappingFunction</code>
计算新值并更新。如果键不存在，则不执行任何操作。该方法同样确保了计算和更新的原子性。</li>
</ul></li>
</ul>
<h2 id="map对比">Map对比</h2>
<h3 id="hashmap和hashtable的区别">HashMap和Hashtable的区别</h3>
<ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code>
是非线程安全的，<code>Hashtable</code> 是线程安全的,因为
<code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code>
修饰。</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code>
要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code>
基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong>
<code>HashMap</code> 可以存储 null 的 key 和 value，但 null
作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和
null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ①
创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为
11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code>
默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。②
创建时如果给定了容量初始值，那么 <code>Hashtable</code>
会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2
的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2
的幂作为哈希表的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code>
在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为
8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于
64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code>
没有这样的机制。</li>
</ul>
<h3 id="hashmap和hashset的区别">HashMap和HashSet的区别</h3>
<p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><code>HashMap</code></th>
<th style="text-align: center;"><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">实现了 <code>Map</code> 接口</td>
<td style="text-align: center;">实现 <code>Set</code> 接口</td>
</tr>
<tr class="even">
<td style="text-align: center;">存储键值对</td>
<td style="text-align: center;">仅存储对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">调用 <code>put()</code>向 map
中添加元素</td>
<td style="text-align: center;">调用 <code>add()</code>方法向
<code>Set</code> 中添加元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>HashMap</code> 使用键（Key）计算
<code>hashcode</code></td>
<td style="text-align: center;"><code>HashSet</code> 使用成员对象来计算
<code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code>
可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h3 id="hashmap和treemap的区别">HashMap和TreeMap的区别</h3>
<p><code>TreeMap</code> 和<code>HashMap</code>
都继承自<code>AbstractMap</code>
，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code>
接口。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/treemap_hierarchy.png"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code>
有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code>
有了对集合中的元素根据键排序的能力。默认是按 key
的升序排序，不过我们也可以指定排序的比较器。</p>
<h3 id="concurrenthashmap-和-hashtable-的区别">ConcurrentHashMap 和
Hashtable 的区别</h3>
<p><strong>底层数据结构</strong></p>
<ul>
<li>JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用
<strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟
<code>HashMap1.8</code>
的结构一样采用<strong>数组+链表/红黑二叉树</strong>。</li>
<li><code>Hashtable</code> 一直采用的是 <strong>数组+链表</strong>
的形式，数组是 HashMap
的主体，链表则是主要为了解决哈希冲突而存在的；</li>
</ul>
<p><strong>实现线程安全的方式（重要）</strong></p>
<ul>
<li><strong>ConcurrentHashMap：</strong>
<ul>
<li><strong>移除了分段锁</strong>：在 JDK 1.8
中，<code>ConcurrentHashMap</code>
不再使用分段锁。相反，它直接使用了一个<strong>Node数组</strong>来存储键值对，并且通过<strong>更细粒度的锁</strong>和<strong>无锁操作</strong>来实现线程安全。</li>
<li><strong>CAS
操作</strong>：在插入和删除节点时，<code>ConcurrentHashMap</code> 使用
CAS（Compare-And-Swap）来确保并发安全。例如，当向一个空桶中插入第一个节点时，<code>ConcurrentHashMap</code>
会使用 CAS 操作直接插入，这样可以避免锁的使用。</li>
<li><strong><code>Synchronized</code>
锁</strong>：在一些复杂操作（如链表或红黑树的插入或删除）中，<code>ConcurrentHashMap</code>
使用 <code>synchronized</code>
来锁定特定的桶（<code>Node</code>），而不是整个段或整个哈希表。这种方式虽然引入了锁，但锁的粒度非常小，只会锁定冲突的桶，因此可以大大减少锁竞争。</li>
</ul></li>
<li><strong>Hashtable：</strong>
<ul>
<li><strong>使用全表锁（Synchronized）</strong>：<code>Hashtable</code>
通过对每个操作（如
<code>put</code>、<code>get</code>、<code>remove</code> 等）加上
<code>synchronized</code>
来保证线程安全，但它使用的是全表锁，导致每次操作都必须锁住整个对象。这会导致多个线程在访问不同元素时也会被阻塞，增加锁竞争，降低并发性能。</li>
<li><strong>性能瓶颈</strong>：全表锁机制使得即使线程操作不同的键，仍会被串行化。在高并发场景中，锁的竞争严重影响吞吐量，导致性能大幅下降。</li>
</ul></li>
</ul>
<h3 id="如何解决hash冲突">如何解决Hash冲突？</h3>
<p><strong>1.开放定址法</strong></p>
<ul>
<li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li>
<li>常见的开放寻址技术有线性探测、二次探测和双重散列。</li>
<li>这种方法的缺点是可能导致“聚集”问题，降低哈希表的性能。</li>
</ul>
<p><strong>2.链地址法</strong></p>
<ul>
<li><p>每个哈希桶(bucket)指向一个链表。当发生冲突时，新的元素将被添加到这个链表的末尾。</p></li>
<li><p>在Java中，HashMap就是通过这种方式来解决哈希冲突的。Java8之前，HashMap使用链表来实现)</p></li>
<li><p>从Java
8开始，当链表长度超过一定阈值时，链表会转换为红黑树，以提高搜索效率。</p></li>
</ul>
<p><strong>3.再哈希法</strong></p>
<ul>
<li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li>
<li>这种方法需要额外的计算，但可以有效降低冲突率。</li>
</ul>
<p><strong>4.建立公共溢出区</strong></p>
<ul>
<li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>
</ul>
<p><strong>5.一致性hash</strong></p>
<ul>
<li>主要用于分布式系统中，如分布式缓存。它通过将数据均匀分布到多个节点上来减少冲突</li>
</ul>
]]></content>
      <categories>
        <category>常用集合</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis】深入五大数据类型</title>
    <url>/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="简单动态字符串sds">简单动态字符串（SDS）</h2>
<p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char*
字符数组来实现字符串，而是自己封装了一个名为<strong>简单动态字符串（simple
dynamic string，SDS）</strong> 的数据结构来表示字符串。</p>
<h3 id="c语言字符串">C语言字符串</h3>
<p>C 语言的字符串不足之处以及可以改进的地方：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面<strong>不能包含 “\0”
字符</strong>，因此<strong>不能保存二进制数据</strong>；</li>
<li>字符串<strong>操作函数不高效且不安全</strong>，比如有缓冲区溢出的风险，有可能会造成程序运行终止。比如函数<code>char *strcat(char *dest, const char* src);</code>，可能会超出dest字符串长度。</li>
</ul>
<h3 id="结构设计">结构设计</h3>
<p>前三个属性len、alloc和flags都是结构体的头信息，只有buf字段才真正存储数据。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408121413066.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;   <span class="comment">/* buf已保存的字符串字节数，不包含结束标示*/</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* buf申请的总的字节数，不包含结束标示*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/*不同SDS的头类型，用来控制SDS的头大小*/</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><p><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要
O（1）。</p></li>
<li><p><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过
<code>alloc - len</code>
计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将
SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用
SDS 既不需要手动修改 SDS
的空间大小，也不会出现前面所说的缓冲区溢出的问题。</p></li>
<li><p><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5
种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5
种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc
成员变量的数据类型不同</strong>。</p>
<p>除了设计不同类型的结构体，Redis
在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在
struct 声明了 <code>__attribute__ ((packed))</code>
，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p></li>
<li><p><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</p></li>
</ul>
<p><code>flags</code>字段的前3位用于表示SDS的类型：</p>
<ul>
<li><strong>SDS_TYPE_5</strong> (<code>000</code>):
使用5位存储长度信息，适用于长度较小的字符串。</li>
<li><strong>SDS_TYPE_8</strong> (<code>001</code>):
使用1个字节（8位）存储长度信息。</li>
<li><strong>SDS_TYPE_16</strong> (<code>010</code>):
使用2个字节（16位）存储长度信息。</li>
<li><strong>SDS_TYPE_32</strong> (<code>011</code>):
使用4个字节（32位）存储长度信息。</li>
<li><strong>SDS_TYPE_64</strong> (<code>100</code>):
使用8个字节（64位）存储长度信息。</li>
</ul>
<h3 id="动态扩容">动态扩容</h3>
<p>当追加的字符串超过分配的空间时，会触发扩容机制：</p>
<ul>
<li>如果新字符串小于1M，则新空间为扩展后字符串长度的<code>两倍 + 1</code>（+1是为了保存一个结束标识<code>'\0'</code>）</li>
<li>如果新字符串大于1M，则新空间为扩展后字符串长度<code>+ 1M + 1</code>。称为内存预分配。</li>
</ul>
<blockquote>
<p><strong>示例：</strong>初始有一个内容为"hi"的SDS，加上字符串",Amy"，新字符串长度小于1M，扩容为原本的2倍+1</p>
</blockquote>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408121431595.png"></p>
<h2 id="整数集合intset">整数集合（IntSet）</h2>
<p><strong>整数集合是 Set
对象的实现方式之一。</strong>具备长度可变、有序等特征，当一个 Set
对象只包含整数值元素，并且元素数量不大时，就会使用<code>Intset</code>这个数据结构作为底层实现。</p>
<h3 id="结构设计-1">结构设计</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">/* 编码方式，支持存放16位、32位、64位整数*/</span></span><br><span class="line">    <span class="type">uint32_t</span> length;   <span class="comment">/* 元素个数 */</span></span><br><span class="line">    <span class="type">int8_t</span> contents[]; <span class="comment">/* 整数数组，保存集合数据*/</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>encoding的三种模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET ENC INT16 &lt;INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16(sizeof(int16_t)) <span class="comment">/* 2字节整数，范围类似java的short*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32(sizeof(int32_t)) <span class="comment">/* 4字节整数，范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64(sizeof(int64_t)) <span class="comment">/* 8字节整数，范围类似java的long */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="编码升级">编码升级</h3>
<p>当向<code>intset</code>中插入一个新整数且该整数超过了当前编码类型的范围时，<code>intset</code>会自动进行编码升级。</p>
<p>现在，假设有一个intset，元素为{5，10，20}，采用的编码是<code>INTSET_ENC_INT16</code>，则每个整数占2字节。我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122340043.png"></p>
<p>以当前案例来说流程如下:</p>
<ol type="1">
<li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占4字节，并<strong>按照新的编码方式及元素个数扩容数组</strong></li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122339574.png"></p>
<h2 id="字典dict">字典（Dict）</h2>
<p>Redis本身就是一个键值型的数据库，其核心就是通过高效的方式来存储和检索键值对。在Redis的内部，键值对的存储和管理依赖于一种叫做<code>Dict</code>（字典）的数据结构。</p>
<h3 id="结构设计-2">结构设计</h3>
<p>Dict由三部分组成，分别是：哈希表(DictHashTable)、哈希节点(DictEntry)、字典(Dict)</p>
<p><strong>哈希表：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">	<span class="comment">// entry数组，数组中保存的是指向entry的指针</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">	<span class="comment">// 哈希表大小，即哈希表桶（bucket）的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="comment">// 哈希表大小的掩码，等于size -1</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">	<span class="comment">// 哈希表元素的个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p><strong>哈希节点：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *key;	<span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;		<span class="comment">//值</span></span><br><span class="line">    <span class="comment">//下一个Entry的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><strong>字典：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// dic类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata; <span class="comment">// 私有数据，在做特殊hash运算时用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">// rehash的进度，-1表示未进行</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;<span class="comment">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271752927.webp"></p>
<h3 id="添加元素">添加元素</h3>
<p>当利用Dict添加元素时，Redis首先会根据key计算出hash值，然后利用哈希值对长度取余<code>hash % size</code>获取哈希表的下标。</p>
<p>当<code>size</code>的长度为2的倍数时，满足公式：<code>hash % size == hash &amp; (sizemask)</code>。由于位运算可直接在内存进行操作，不需要转为十进制，所以性能更好。</p>
<blockquote>
<p><strong>公式解释：</strong>当哈希表的长度为2的倍数时，哈希表大小的掩码<code>sizemask</code>的二进制表示必然是多个1组成的<code>1111</code>，而1按位与任何数，都为数本身，所以可以达到对hash值取余的效果。</p>
</blockquote>
<p>当有元素添加进来时，采用头插法插入元素，头插法的时间复杂度为
O(1)，能够在哈希冲突发生时迅速将新元素插入到链表中。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122215101.png"></p>
<h3 id="rehash">rehash</h3>
<h4 id="动态扩容-1">动态扩容</h4>
<p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p>
<p>Dict在每次增加键值对时都会检查<strong>负载因子（哈希表中元素的数量与哈希表桶数量的比值）</strong><code>LoadFactor = used/size</code>，满足以下三
种情况时会触发<strong>哈希表扩容</strong>。</p>
<ul>
<li>负载因子<code>LoadFactor &gt;= 1</code>，并且服务器没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>等后台进程；</li>
<li>负载因子<code>LoadFactor &gt; 5</code>；</li>
</ul>
<p><strong>当Dict执行扩容时，需要扩容到第一个大于等于<code>used + 1</code>（哈希表中元素个数
+ 1）的2 ^ n。</strong></p>
<h4 id="动态缩容">动态缩容</h4>
<p>满足以下情况时，触发<strong>哈希表缩容</strong>。</p>
<ul>
<li>负载因子<code>LoadFactor &lt; 0.1</code>，会触发哈希表缩容</li>
</ul>
<p><strong>当Dict执行缩容时，需要缩容到第一个大于等于<code>used</code>（哈希表中元素个数）的2
^ n，但不能小于初始大小4。</strong></p>
<h4 id="渐进式rehash">渐进式rehash</h4>
<p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的:</p>
<ol type="1">
<li>计算新hash表的size，值取决于当前要做的是扩容还是收缩:
<ul>
<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used+1的2^n</li>
<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n(不得小于4)</li>
</ul></li>
<li>按照新的size申请内存空间，创建dictht，并赋值给dict.ht[1]</li>
<li>设置dict.rehashidx=0，标示开始rehash</li>
<li><strong>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]桶上的所有元素rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]中。</strong></li>
<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>
<li><strong>将rehashidx赋值为-1，代表rehash结束</strong></li>
<li><strong>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht{0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</strong></li>
</ol>
<h3 id="dict与hashmap">Dict与HashMap</h3>
<h4 id="dict">Dict</h4>
<ul>
<li><strong>负载因子为5时扩容</strong>：较高的负载因子可以使得哈希表桶的数据更加紧凑，提高内存利用率；较高的负载因子可以减少扩容频率，减少资源消耗；在负载因子为
5 时，哈希表桶的链表相对较短，仍能保证相对较快的查找效率。</li>
<li>在负载因子较高时扩容，字典的空间利用率更高，这对于减少内存开销很有帮助。而在负载因子为5时，哈希冲突虽然较多，但Redis通过链表等机制处理冲突，依然能够保持较高的查询速度。</li>
<li><strong>渐进式rehash</strong>：Redis在扩容时采用渐进式rehash（渐进式重新哈希），逐步将旧表中的键值对迁移到新表中，以避免扩容时阻塞Redis的正常操作。因此，Redis可以在负载因子较高时继续工作，并在扩容过程中平滑地处理大量数据。</li>
<li><strong>单线程模型</strong>：Redis
是单线程处理模型，<code>Dict</code> 不需要处理线程安全问题。这使得
<code>Dict</code>
的操作可以更加简单和高效，因为不需要复杂的锁机制来同步多线程访问。</li>
<li><strong>链地址法</strong>：</li>
</ul>
<h4 id="hashmap">HashMap</h4>
<ul>
<li><strong>负载因子为0.75时扩容</strong>：<code>HashMap</code>在设计时追求在插入和查找操作之间的平衡。负载因子为0.75时，哈希冲突率较低，查找和插入性能较高，同时又避免了内存的浪费。</li>
<li><strong>即时扩容</strong>：与Redis不同，Java的<code>HashMap</code>在达到扩容阈值时会立即进行扩容操作，重新计算哈希值并将元素放置到新表中。这样做是为了保持插入和查找的性能，避免在高负载因子下，哈希冲突过多导致查询效率大幅下降。</li>
<li><strong>多线程环境</strong>：<code>HashMap</code>
本身不是线程安全的，在多线程环境中使用时可能会出现并发修改异常或数据不一致问题。为此，Java
提供了 <code>ConcurrentHashMap</code>，它使用分段锁（Java 7 之前）或 CAS
操作（Java 8 之后）来实现线程安全的哈希表。</li>
<li><strong>红黑树：</strong></li>
</ul>
<h2 id="压缩列表ziplist">压缩列表（ZipList）</h2>
<p><code>ZipList</code>是一种特殊的“双端链表”，由一系列特殊编码的<strong>连续内存块</strong>组成。可以在任意一端进行压入/弹出操作,并且该操作的时间复杂度为
0(1)。</p>
<h3 id="结构设计-3">结构设计</h3>
<p><strong>ZipList：</strong></p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141115497.png"></p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 11%">
<col style="width: 9%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>长度</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>zlbytes</td>
<td><code>uint32_t</code></td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr class="even">
<td>zltail</td>
<td><code>uint32_t</code></td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr class="odd">
<td>zllen</td>
<td><code>uint16_t</code></td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量。最大值为 <code>UINT16_MAX</code>
(65534)，如果超过这个值，此处会记录为
<code>65535</code>，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr class="even">
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr class="odd">
<td>zlend</td>
<td><code>uint8_t</code></td>
<td>1 字节</td>
<td>特殊值 <code>0xFF</code> (十进制 255)，用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<p><strong>ZipListEntry：</strong></p>
<p><code>ZipList</code>中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用下面的结构：</p>
<table>
<thead>
<tr class="header">
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li><strong>previous_entry_length</strong>：前一节点的长度，占1个或5个字节。
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保这个长度值，第一个字节为0xfe<code>标记采用5字节</code>，后四个字节才是真实长度数据</li>
</ul></li>
<li><strong>encoding</strong>：编码属性，记录content的数据类型(字符串还是整数)以及长度，占用1个、2个或5个字节</li>
<li><strong>contents</strong>：负责保存节点的数据，可以是字符串或整数</li>
</ul>
<h3 id="encoding">encoding</h3>
<p><code>ZipListEntry</code>中的encoding编码分为字符串和整数两种，<strong>编码格式采用十六进制</strong>。</p>
<h4 id="字符串">字符串</h4>
<p>如果encoding是以"00"、"01"或者"10"开头，则证明content是字符串</p>
<table>
<colgroup>
<col style="width: 63%">
<col style="width: 15%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>字符串大小</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>|00pppppp|</code></td>
<td>1bytes</td>
<td>最大长度为2^6-1</td>
</tr>
<tr class="even">
<td><code>|01pppppp|qqqqqqqq|</code></td>
<td>2 bytes</td>
<td>最大长度为2^14-1</td>
</tr>
<tr class="odd">
<td><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</code></td>
<td>5 bytes</td>
<td>最大长度为2^32-1</td>
</tr>
</tbody>
</table>
<p>例如，如果需要保存字符串"ab"和"bc"，abc的ASCII码从<code>97</code>依次递增</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141146414.png"></p>
<h4 id="整数">整数</h4>
<p>如果encoding是以"11"开始，则证明content是整数，且encoding固定只占用1个字节</p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 14%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>编码</th>
<th><strong>编码长度</strong></th>
<th><strong>整数类型</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>11000000</code></td>
<td>1</td>
<td><code>int16_t</code> (2 bytes)</td>
</tr>
<tr class="even">
<td><code>11010000</code></td>
<td>1</td>
<td><code>int32_t</code> (4 bytes)</td>
</tr>
<tr class="odd">
<td><code>11100000</code></td>
<td>1</td>
<td><code>int64_t</code> (8 bytes)</td>
</tr>
<tr class="even">
<td><code>11110000</code></td>
<td>1</td>
<td>24位有符整数 (3 bytes)</td>
</tr>
<tr class="odd">
<td><code>11111110</code></td>
<td>1</td>
<td>8位有符整数 (1 byte)</td>
</tr>
<tr class="even">
<td><code>1111xxxx</code></td>
<td>1</td>
<td>省去content字段，直接在<code>xxxx</code>位置保存数值，范围从0001~1101，减1后结果为实际值</td>
</tr>
</tbody>
</table>
<p>例如，如果需要保存整数"2"和"6"，省去content字段直接存储。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141159233.png"></p>
<h3 id="连锁更新问题">连锁更新问题</h3>
<p><strong>previous_entry_length</strong>：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于等于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保这个长度值，第一个字节为0xfe<code>标记采用5字节</code>，后四个字节才是真实长度数据</li>
</ul>
<p>假设压缩列表有多个连续的、长度为250~253字节之间的entry，因此节点的<code>previous_entry_length</code>属性用1个字节即可表示，如图所示：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271753637.webp"></p>
<p>此时如果添加一个新的节点，长度超过了254字节，就会导致<code>e1</code>节点的<code>previous_entry_length</code>属性更新，采用5字节，从而导致后续的节点产生连锁更新的现象。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141209157.png"></p>
<h2 id="快速列表quicklist">快速列表（QuickList）</h2>
<h3 id="压缩列表">压缩列表</h3>
<p>压缩列表有以下缺点：</p>
<ul>
<li><code>ZipList</code>虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低（找不到内存碎片）。</li>
<li><code>ZipList</code>存在连锁更新问题，元素越多越可能发生连锁更新问题。</li>
</ul>
<h3 id="结构设计-4">结构设计</h3>
<p><strong>quickList：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head:</span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail.</span><br><span class="line">    <span class="comment">// 所有的压缩列表的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// 压缩列表的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271754114.webp"></p>
<h3 id="限制大小">限制大小</h3>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code>来限制，默认值为-2。</p>
<ul>
<li>如果值为正，则代表ZipList的允许的entry个数的最大值</li>
<li>如果值为负，则代表ZipList的最大内存大小，分5种情况</li>
</ul>
<h3 id="首位压缩">首位压缩</h3>
<p>除了控制ZipList的大小，<code>QuickList</code>还可以对节点的ZipList做压缩。通过配置项<code>list-compress-depth</code>来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p>
<ul>
<li>0:特殊值，代表不压缩</li>
<li>1:标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li>
<li>2:标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li>
<li>以此类推</li>
</ul>
<h2 id="跳表skiplist">跳表（SkipList）</h2>
<p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p>
<h3 id="结构设计-5">结构设计</h3>
<p><strong>zskiplist：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">//最大的索引层级，默认是1</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755442.webp"></p>
<p><strong>zskiplistNode：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;<span class="comment">// 节点存储的值</span></span><br><span class="line">    doble score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//下一个节点指针</span></span><br><span class="line">    	<span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">//索引跨度</span></span><br><span class="line">	&#125; level[];<span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode:</span><br></pre></td></tr></table></figure>
<p>ZSet 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是
sds 类型的 <strong>ele 变量</strong>和 double 类型的 <strong>score
变量</strong>。每个跳表节点都有一个后向指针（struct zskiplistNode
*backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p>
<p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel
结构体类型的 level 数组</strong>。</p>
<p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel
结构体表示，比如 leve[0] 就表示第一层，leve[1]
就表示第二层。zskiplistLevel
结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度用来记录两个节点之间的距离。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755771.webp"></p>
<p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p>
<p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点
3，查找的过程只经过了一个层（L2），并且层的跨度是 3，所以节点 3
在跳表中的排位是 3。</p>
<h3 id="查询过程">查询过程</h3>
<p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的
SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li><strong>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</strong></li>
<li><strong>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS
类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</strong></li>
<li><strong>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</strong></li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755725.webp"></p>
<p>如果需要查找「元素：abcd，权重：4」的节点，查找过程如下：</p>
<ol type="1">
<li>先从头结点最高层开始，L2指向了「元素：abc，权重：3」节点，先查询该节点</li>
<li>由于该层下一节点为NULL，所以跳到下一层，也就是「元素：abc，权重：3」节点的<code>level[1]</code>层</li>
<li><code>level[1]</code>层的下一节点是「元素：abcde，权重：4」，当前的权重等于查找的权重，但是当前的元素大于查询的元素（abcde
&gt;
abcd），所以跳转到下一层，也就是「元素：abc，权重：3」节点的<code>level[0]</code>层</li>
<li>查询到「元素：abcd，权重：4」，正是要查询的节点，直接返回。</li>
</ol>
<h3 id="插入过程">插入过程</h3>
<p><strong>跳表的相邻两层的节点数量最理想的比例是
2:1，查找复杂度可以降低到 O(logN)</strong>。</p>
<p>具体的做法是，<strong>跳表在添加节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于
0.25（相当于概率 25%），那么层数就增加 1
层，然后继续生成下一个随机数，直到随机数的结果大于 0.25
结束，最终确定该节点的层数</strong>。</p>
<p>插入一个新节点到跳表中，通常会涉及以下步骤：</p>
<ol type="1">
<li><strong>查找插入位置</strong>：
<ul>
<li>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS
类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
<li>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</li>
</ul></li>
<li><strong>随机生成层数</strong>：在跳表中，新节点的层数是随机生成的。层数越高，新节点的概率越低。</li>
<li><strong>插入新节点</strong>：
<ul>
<li>更新与新节点相关的前驱节点和后继节点的指针，以保持跳表的正确性。</li>
<li>如果插入的层数比当前跳表的最大层数要高，那么需要更新跳表的头节点层数。</li>
</ul></li>
</ol>
<h3 id="删除过程">删除过程</h3>
<ol type="1">
<li><strong>查找删除位置</strong>：
<ul>
<li>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS
类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
<li>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</li>
</ul></li>
<li><strong>删除新节点</strong>：
<ul>
<li>更新与原有节点相关的前驱节点和后继节点的指针，以保持跳表的正确性。</li>
<li>如果删除后的层数比当前跳表的最大层数要低，那么需要更新跳表的头节点层数。</li>
</ul></li>
</ol>
<h3 id="跳表与平衡树">跳表与平衡树</h3>
<ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含
2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为
1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取
p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第
1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h2 id="listpack">listpack</h2>
<p><code>listpack</code>的目的是替代压缩列表，它的最大特点是 listpack
中<strong>每个节点不再包含前一个节点的长度</strong>，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271756703.webp"></p>
<p>主要包含三个方面内容:</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码</li>
<li>data，实际存放的数据:</li>
<li>len，encoding+data的总长度:</li>
</ul>
<p>可以看到，listpack 只记录当前节点的长度，当我们向 listpack
加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p>
<h1 id="数据类型">数据类型</h1>
<h2 id="常见数据类型">常见数据类型</h2>
<p>Redis 中比较常见的数据类型有下面这些：</p>
<ul>
<li><strong>5
种基础数据类型</strong>：String（字符串）、List（列表）、Hash（散列）、Set（集合）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap
（位图）、Geospatial (地理位置)。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142246546.png"></p>
<h2 id="redisobject">RedisObject</h2>
<p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142124669.png"></p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。encoding的编码方式如下：</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>对应编码方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr class="even">
<td>OBJ_LIST</td>
<td>LinkedList + ZipList（3.2以前）、QuickList（3.2以后）</td>
</tr>
<tr class="odd">
<td>OBJ_SET</td>
<td>IntSet、HT</td>
</tr>
<tr class="even">
<td>OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr class="odd">
<td>OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody>
</table>
<h2 id="string">String</h2>
<p>String 是最基本的<code>key-value</code>结构，key 是唯一标识，value
是具体的值。value不一定是字符串，也可以是数字(整数或浮点数)，value
最多可以容纳的数据长度是 512M。</p>
<ul>
<li><strong>其基本编码方式是<code>RAW</code></strong>，基于简单动态字符串(SDS)实现，存储上限为512mb。</li>
<li><strong>如果存储的SDS长度小于44字节，则会采用<code>EMBSTR</code>编码</strong>，此时object
head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li>
<li><strong>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<code>INT</code>编码</strong>，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不再需要SDS了。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142135149.png"></p>
<h2 id="list">List</h2>
<p>List 结构类似一个双端链表，可以从首、尾操作列表中的元素。</p>
<ul>
<li>在3.2版本之前，Redis采用<code>LinkedList</code>和<code>ZipList</code>编码来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码</li>
<li>在3.2版本之后，Redis统一采用<code>QuickList</code>编码来实现List</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142147783.png"></p>
<h2 id="set">Set</h2>
<p>Set
类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<ul>
<li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用<code>IntSet</code>编码，以节省内存。</li>
<li>为了查询效率和唯一性，Set采用<code>HT</code>编码(Dict)。Dict中的key用来存储元素，value统一为null</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142155798.png"></p>
<h2 id="zset">ZSet</h2>
<p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值。ZSet底层数据结构必须满足<strong>键值存储</strong>、<strong>键必须唯一</strong>、<strong>可排序</strong>这几个需求，所以需要同时采用<code>SkipList</code>和<code>HT</code>这两种编码。</p>
<ul>
<li><code>SkipList</code>：可以排序，并且可以同时存储score和ele值(member)</li>
<li><code>HT</code>：可以键值存储，并且可以根据key找value</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142200431.png"></p>
<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此ZSet还会采用<code>ZipList</code>编码来节省内存，不过需要同时满足两个条件:</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries(默认值128)</li>
<li>每个元素都小于zset_max_ziplist_value(默认值64字节)</li>
</ul>
<p>ZipList本身没有排序功能，而且没有键值对的概念，通过编码实现:</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142204860.png"></p>
<h2 id="hash">Hash</h2>
<p>Hash结构默认采用<code>ZipList</code>编码，用以节省内存。ZipList中相邻的两个entry分别保存field和value</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142212999.png"></p>
<p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个:</p>
<ul>
<li>ZipList中的元素数量超过了hash-max-ziplist-entries(默认512)</li>
<li>ZipList中的任意entry大小超过了hash-max-ziplist-value(默认64字节)</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142213898.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【分布式】分布式锁设计与Redisson源码解析</title>
    <url>/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="分布式锁">分布式锁</h1>
<p><strong>分布式锁是一种在分布式计算环境中用于控制多个节点（或多个进程）对共享资源的访问的机制</strong>。在分布式系统中，多个节点可能需要协调对共享资源的访问，以防止数据的不一致性或冲突。分布式锁允许多个节点在竞争访问共享资源时进行同步，以确保只有一个节点能够获得锁，从而避免冲突和数据损坏。</p>
<p>设计一个分布式锁需要保证以下四大特性：</p>
<ul>
<li><strong>互斥性</strong>：在任意时刻，只能有一个进程持有锁。</li>
<li><strong>进程一致</strong>：加锁和解锁的操作必须由同一个进程执行。</li>
<li><strong>防死锁</strong>：即使有一个进程在持有锁期间崩溃而未能主动释放锁，必须有其他方式去释放锁，以保证其他进程能够获取到锁。</li>
<li><strong>锁续期</strong>：持锁线程执行的操作超出预期时间，只要持锁线程仍然在执行，锁就不应该被释放。</li>
</ul>
<h2 id="mysql实现">MySQL实现</h2>
<h3 id="结构设计">结构设计</h3>
<ul>
<li><strong>设计表结构</strong>：设计一个锁的唯一标识
<code>lock_name</code> 作为表的主键，<code>thread_id</code>
字段存储持有锁的线程ID、设置 <code>counter</code>
字段用于记录重入次数、<code>expires_at</code>
设置锁的过期时间，以防止死锁。</li>
<li><strong>设计索引</strong>：还可以在 <code>CREATE</code>
语句中建立联合索引，减少回表次数，优化查询速度，但在高并发场景下执行增删改操作效率会下降。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE distributed_locks (</span><br><span class="line">    lock_name VARCHAR(255) PRIMARY KEY,    -- 锁的唯一标识</span><br><span class="line">    thread_id VARCHAR(255),                -- 当前持有锁的线程ID</span><br><span class="line">    counter INT DEFAULT 0,                 -- 计数器，记录重入次数</span><br><span class="line">    expires_at TIMESTAMP NULL              -- 锁的过期时间</span><br><span class="line">    # INDEX idx_lock_thread_expires (lock_name, thread_id, expires_at)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="加锁过程">加锁过程</h3>
<ol type="1">
<li><p><strong>首次获取锁</strong>：通过 <code>SELECT</code> 语句，以
<code>lock_name</code> 和 <code>expires_at</code>
为查询条件，查询存在且未过期的锁。如果锁不存在，则使用
<code>INSERT</code>
语句插入锁标识、线程ID、计数器初始值一和过期时间。如果锁存在，执行下一步骤。（设置过期时间实现<strong>「防死锁」</strong>；由于
<code>INSERT</code>
语句默认使用行级锁，同一时刻只能有一个线程插入成功，因此保证了<strong>「互斥性」</strong>）</p></li>
<li><p><strong>重复获取锁</strong>：判断查询结果中的
<code>thread_id</code>
字段是否与当前线程ID相同。如果相同，说明当前线程需要重复获取锁，执行
<code>UPDATE</code> 语句将 <code>counter</code>
字段加一，并重置过期时间。如果不相同，执行下一步骤。（设置计数器实现<strong>可重入锁</strong>）</p></li>
<li><p><strong>获取锁失败</strong>：直接从查询结果返回锁的过期时间，帮助申请锁的线程得知等待锁释放的时间。</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 查询锁是否存在且未过期</span><br><span class="line">SELECT * FROM distributed_locks </span><br><span class="line">WHERE lock_name = ? AND expires_at &gt; NOW();</span><br><span class="line"></span><br><span class="line">IF 结果为空 THEN</span><br><span class="line">    -- 锁不存在，插入新锁记录</span><br><span class="line">    INSERT INTO distributed_locks (lock_name, thread_id, counter, expires_at)</span><br><span class="line">    VALUES (?, ?, 1, DATE_ADD(NOW(), INTERVAL ? SECOND));</span><br><span class="line">ELSEIF thread_id 等于当前线程ID THEN</span><br><span class="line">    -- 锁已被当前线程持有，重入锁</span><br><span class="line">    UPDATE distributed_locks </span><br><span class="line">    SET counter = counter + 1, expires_at = DATE_ADD(NOW(), INTERVAL ? SECOND)</span><br><span class="line">    WHERE lock_name = ?;</span><br><span class="line">ELSE</span><br><span class="line">    -- 锁已被其他线程持有，加锁失败</span><br><span class="line">    返回锁的剩余有效期</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<h3 id="解锁过程">解锁过程</h3>
<ol type="1">
<li><strong>检查锁持有者</strong>：通过 <code>SELECT</code> 语句，以
<code>lock_name</code> 和 <code>thread_id</code>
为查询条件，查询锁是否由当前线程持有。如果结果为空，则返回
<code>NULL</code>
表示解锁失败。如果结果不为空，执行下一步骤。（通过条件判断保证<strong>「进程一致」</strong>，即加解锁为同一线程）</li>
<li><strong>减少锁计数器</strong>：执行 <code>UPDATE</code>
语句给持有锁的线程的计数器减一，并判断计数器是否大于零。如果大于零，说明锁还没有完全释放，执行
<code>UPDATE</code> 语句重置锁的过期时间，返回 0
表示锁未完全释放；如果等于零，说明当前线程已完全释放锁，则执行
<code>DELETE</code> 语句删除整个锁，返回 1 表示锁完全释放。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 检查锁是否由当前线程持有</span><br><span class="line">SELECT * FROM distributed_locks </span><br><span class="line">WHERE lock_name = ? AND thread_id = ?;</span><br><span class="line"></span><br><span class="line">IF 结果为空 THEN</span><br><span class="line">    -- 锁不属于当前线程，解锁失败</span><br><span class="line">    返回 NULL;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 减少锁计数器</span><br><span class="line">UPDATE distributed_locks </span><br><span class="line">SET counter = counter - 1 </span><br><span class="line">WHERE lock_name = ? AND thread_id = ?;</span><br><span class="line"></span><br><span class="line">-- 检查计数器是否大于0</span><br><span class="line">IF counter &gt; 0 THEN</span><br><span class="line">    -- 锁仍然被当前线程持有（重置过期时间）</span><br><span class="line">    UPDATE distributed_locks </span><br><span class="line">    SET expires_at = DATE_ADD(NOW(), INTERVAL ? SECOND)</span><br><span class="line">    WHERE lock_name = ?;</span><br><span class="line">    返回 0;</span><br><span class="line">ELSE</span><br><span class="line">    -- 计数器为0，完全释放锁</span><br><span class="line">    DELETE FROM distributed_locks WHERE lock_name = ?;</span><br><span class="line">    返回 1;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<h2 id="redis实现">Redis实现</h2>
<h3 id="结构设计-1">结构设计</h3>
<ul>
<li><strong>选用数据结构</strong>：采用 <code>String</code>
结构。设置锁的唯一标识作为
KEY，并指定一个<strong>唯一的线程标识</strong>作为值 VALUE。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411050937549.png" style="zoom:33%;"></p>
<h3 id="加锁过程-1">加锁过程</h3>
<ol type="1">
<li><strong>设置锁</strong>：使用 SET 命令 NX（只在键不存在时设置）和
PX（设置过期时间）选项来实现一个原子操作，确保了即使持锁进程崩溃，其他进程仍然能够获取到锁，从而满足<strong>「互斥性」</strong>和<strong>「防死锁」</strong>
。</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.尝试获取锁，值为唯一的线程标识</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="string">&#x27;NX&#x27;</span>, <span class="string">&#x27;PX&#x27;</span>, ARGV[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h3 id="解锁过程-1">解锁过程</h3>
<ol type="1">
<li><strong>释放锁</strong>：通过 DEL 命令清除锁的键来释放锁。在执行 DEL
操作之前，先使用 GET
命令检查锁的值是否与持锁者的唯一标识匹配，从而满足<strong>「进程一致」</strong>
。</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2.比较线程标识与锁中的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">	<span class="comment">-- 执行del释放锁</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论是MySQL还是Redis实现的分布式，虽然都考虑到了<strong>互斥性</strong>、<strong>防死锁</strong>和<strong>进程一致</strong>问题，但是却无法解决<strong>锁续期</strong>问题。所以，Redis
官方推荐采用 Redisson 实现 Redis 的分布式锁，借助 Redisson 的
<code>WatchDog</code> 机制能够很好的解决锁续期的问题。</p>
</blockquote>
<h2 id="redisson实现">Redisson实现</h2>
<h3 id="结构设计-2">结构设计</h3>
<ul>
<li><strong>选用数据结构</strong>：采用 <code>Hash</code>
结构，设置锁的唯一标识为键，值采用 <code>field-value</code>
格式，以线程ID为 <code>field</code>，计数器为 <code>value</code>
实现可重入锁。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411041024490.png" style="zoom: 33%;"></p>
<h3 id="加锁过程-2">加锁过程</h3>
<ol type="1">
<li><strong>执行Lua脚本</strong>：整个 Lua 脚本是以事务方式在 Redis
中运行的，由于 Redis
是单线程模型，因此脚本内的所有命令是按顺序一次性执行的，不会在中途被打断或交叉执行，从而保证<strong>「互斥性」</strong>。</li>
<li><strong>首次获取锁</strong>：通过 <code>exists</code>
命令判断锁是否不存在。如果不存在，则执行 <code>hincrby</code> 命令设置
<code>Hash</code> 结构的 <code>field</code> 为线程ID，<code>value</code>
为计数器的初始值一，同时执行 <code>pexpire</code>
命令设置锁的过期时间；如果存在，执行下一步操作。</li>
<li><strong>重复获取锁</strong>：通过 <code>hexists</code>
命令判断锁中的 <code>field</code> 是否与当前线程相同。如果相同，则执行
<code>hincrby</code> 命令给 <code>field</code>
对应的计数器加一，同时执行 <code>pexpire</code>
命令重置锁的过期时间，防止锁在持有者持有期间过期；如果不相同，说明当前锁被其他线程持有。</li>
<li><strong>返回结果</strong>：如果返回 <code>nil</code>
表明获取锁成功；如果返回的数据不为 <code>null</code> 而是
<code>Long</code>，表明申请锁的线程需要等待的时间。</li>
</ol>
<p>完整代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果锁不存在，设置当前持有者，并将计数器设置为 1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 设置锁的过期时间，单位为毫秒</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 nil 表示锁成功创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断锁是否已被当前持有者持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果锁已被当前持有者持有，将持有者的计数加 1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 重置锁的过期时间，防止锁在持有者持有期间过期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 nil 表示锁成功重入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果锁已存在，但被其他持有者持有</span></span><br><span class="line"><span class="comment">-- 返回锁的剩余有效期，单位为毫秒</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="解锁过程-2">解锁过程</h3>
<ol type="1">
<li><strong>检查锁持有者</strong>：通过 <code>hexists</code>
命令查询锁中的 <code>field</code>
是否与当前线程相同。如果不相同，表明锁的持有者不是当前线程，返回
<code>nil</code>，如果相同，执行下一步操作。（通过条件判断保证<strong>「进程一致」</strong>，即加解锁为同一线程）</li>
<li><strong>减少锁计数器</strong>：执行 <code>hincrby</code>
命令给持有锁的线程的计数器减一，并判断计数器是否大于零。如果大于零，说明锁还没有完全释放，执行
<code>pexpire</code> 命令重置锁的过期时间，返回 0
表示锁未完全释放；如果等于零，说明当前线程已完全释放锁，则执行
<code>del</code> 删除整个锁，同时执行 <code>publish</code>
命令通知所有等待锁的其他线程，返回 1
表示锁完全释放。（这里执行消息发布是服务于<strong>锁等待</strong>机制，防止无意义的申请锁而浪费资源）</li>
</ol>
<p>完整代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查锁是否由当前线程持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 减少当前线程持有的锁计数器</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断计数器值是否大于 0</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果计数器大于 0，说明锁仍然被当前线程持有（多次重入）</span></span><br><span class="line">    <span class="comment">-- 重置锁的过期时间，防止锁在当前线程还未完全释放时过期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">-- 返回 0 表示锁还未完全释放（计数器还未清零）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 如果计数器等于 0，说明当前线程已完全释放锁</span></span><br><span class="line">    <span class="comment">-- 删除整个锁键</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 通过发布频道通知锁已释放（适用于等待锁的其他线程）</span></span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 返回 1 表示锁成功释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若发生意外情况，返回 nil 表示操作失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>
<h3 id="看门狗机制">看门狗机制</h3>
<p>当线程尝试执行 <code>tryLock()</code> 方法获取锁时，在内部调用了
<code>tryAcquireAsync()</code> 方法获取锁的等待时间，返回值为
<code>Long</code> 型 。如果返回结果为
<code>null</code>，表明加锁成功；返回结果不为
<code>null</code>，返回值就是需要等待锁的释放时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取加锁的返回值，如果为null则加锁成功，不为null表明加锁失败，还需等待ttl的时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 获取锁成功，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用tryAcquireAsync获取锁的等待时间的Long值</span></span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>tryAcquireAsync()</code>
方法中，首先判断锁是否设置了释放时间。</p>
<ul>
<li>如果设置了锁的释放时间，直接进行上述 <strong>lua脚本</strong>
的加锁操作，并返回结果；</li>
<li>如果没有设置锁的释放时间，将锁的过期时间设置为默认值30s并进行
<strong>lua脚本</strong>
的加锁操作，同时<strong>启用看门狗机制</strong>，不断的进行自动续约，实现<strong>「锁续期」</strong>；</li>
<li>可以看到，两种操作都最终使锁被设置了过期时间，防止持有锁的客户端异常退出后锁无法释放的问题（即<strong>「防死锁」</strong>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果设置锁的过期时间，直接进行加锁操作返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有设置锁的过期时间，同样调用tryLockInnerAsync方法进行加锁，但是将过期时间默认设置为30s</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">			commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    </span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 出现异常，返回</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁获取成功，进行自动续约</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自动续约</strong>的操作由
<code>scheduleExpirationRenewal</code>
方法实现。该方法内部首先会从成员变量的 <code>ConcurrentHashMap</code>
集合中根据当前锁的名称获取值，如果获取不到，说明当前线程任务执行完毕，无需再进行锁的自动续期；如果可以获取到值，则启动一个定时任务，通过递归调用实现每
10s 触发一次任务，在任务内部执行了如下的
<strong>lua脚本</strong>，从而重置锁的过期时间。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查锁的持有者是否与当前线程相同</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果相同，重置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 1 表示操作成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果 field 不存在，返回 0 表示操作失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>取消自动续约</strong>：当持有锁的线程的任务执行完毕后，会执行
<code>remove()</code> 方法删除 <code>ConcurrentHashMap</code>
集合中的键值，而看门狗在获取 <code>ConcurrentHashMap</code>
集合中的键值失败后，就会返回结果，结束自动续约。</p>
</blockquote>
<h3 id="锁等待机制">锁等待机制</h3>
<ol type="1">
<li><strong>尝试获取锁</strong>：
<ul>
<li>首先调用 <code>tryAcquire()</code> 方法获取锁剩余的存活时间
ttl，如果结果为 null，返回 true 表明加锁成功。</li>
<li>接着计算当前时间与获取锁之前的时间的差值，如果申请锁的耗时大于等待时间，表明申请锁失败，返回
false。</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 1.尝试获取锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 1.1.锁获取成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// x...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>订阅锁释放通知</strong>：通过 <code>subscribe</code>
方法，基于当前线程的 <code>threadId</code>
发起一个异步订阅请求，等待锁释放的通知。这一步骤的主要作用是通过订阅锁的释放事件来实现对锁的高效管理，防止无效的锁申请对系统资源造成浪费。
<ul>
<li><strong>等待锁释放超时</strong>：通过 <code>await()</code>
方法（内部使用 <code>CountDownLatch</code>
实现阻塞）在指定时间内等待失败，说明当前线程的等待时间超时，无需再获取锁，需要执行取消订阅和失败处理的逻辑。</li>
<li><strong>取消订阅</strong>：通过 <code>cancel()</code>
方法取消订阅。如果取消失败，说明订阅任务正在执行，此时无法直接取消任务。需要执行回调函数等待任务执行完毕；如果取消成功，则执行
<code>acquireFailed()</code> 方法并返回 false。</li>
<li><strong>回调函数取消订阅</strong>：通过 <code>onComplete</code>
回调，可以在任务完成后自动触发 <code>unsubscribe</code>
操作，以确保订阅状态被正确清理。</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.订阅锁释放通知，通过await方法阻塞等待锁释放，防止无效的锁申请浪费资源</span></span><br><span class="line">RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line"><span class="comment">// 2.1.如果await在规定的时间内未完成，表示订阅超时，进入if代码块，执行取消订阅和失败处理的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">        subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                unsubscribe(subscribeFuture, threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    acquireFailed(threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2.计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败.</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.x</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>轮询获取锁</strong>：
<ul>
<li><strong>再次获取锁</strong>：返回锁的剩余存活时间
<code>ttl</code>；如果 <code>ttl</code> 为空说明获取锁成功，直接返回
true，否则继续下一步。</li>
<li><strong>阻塞获取锁</strong>：取锁剩余的存活时间和线程剩余的等待时间的最小值，利用<strong>信号量</strong>
<code>Semaphore</code> 阻塞获取锁。</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.while(true)死循环，不断尝试获取锁</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 3.1.再次尝试获取锁</span></span><br><span class="line">    ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新剩余的等待时间</span></span><br><span class="line">    time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentTime = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.取锁剩余的存活时间和线程剩余的等待时间的最小值，尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">        getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新剩余的等待时间</span></span><br><span class="line">    time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>取消订阅</strong>：无论最终是否成功获取锁，在
<code>finally</code> 中都会调用 <code>unsubscribe()</code>
方法取消订阅，以确保资源释放和避免不必要的等待事件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.无论是否获取到了锁,都要取消订阅解锁消息</span></span><br><span class="line">    unsubscribe(subscribeFuture, threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Redisson</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】源码解析——启动流程</title>
    <url>/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="spring-boot启动流程">Spring Boot启动流程</h1>
<p><code>Spring Boot</code> 的入口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelGradingApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(IntelGradingApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Spring Boot</code> 的启动过程可以分为两方面，一个是
<code>new SpringApplication(primarySources)</code>
的<strong>初始化过程</strong>，一个是
<code>SpringApplication.run()</code>
的<strong>应用运行过程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入primarySources数组，构造SpringApplication</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行构造函数">执行构造函数</h2>
<p><strong>构造函数</strong>是 Spring Boot
启动过程的第一步，负责初始化各种属性、验证输入并设置必要的上下文，为后续的应用启动和上下文配置奠定基础。Spring
Boot 通过一个重载构造函数来接收 <code>null</code>
值的资源加载器和主类数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>((ResourceLoader)<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化字段">1.初始化字段</h3>
<p>重构的构造函数接收<code>ResourceLoader</code>和<code>primarySources</code>参数，并为各种字段进行初始化，比如<code>ResourceLoader</code>,
<code>bannerMode</code>, <code>headless</code>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.sources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line"><span class="built_in">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line"><span class="built_in">this</span>.logStartupInfo = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.addCommandLineProperties = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.addConversionService = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.headless = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.registerShutdownHook = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.additionalProfiles = Collections.emptySet();</span><br><span class="line"><span class="built_in">this</span>.isCustomEnvironment = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.lazyInitialization = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line"><span class="built_in">this</span>.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line"><span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br></pre></td></tr></table></figure>
<h3 id="设置主源">2.设置主源</h3>
<p>将<code>primarySources</code>转换为<code>LinkedHashSet</code>，以确保启动过程中按顺序处理，避免重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(Arrays.asList(primarySources));</span><br></pre></td></tr></table></figure>
<h3 id="推断应用类型">3.推断应用类型</h3>
<p>通过检查类路径<code>classpath</code>中的组件（如
<code>"org.springframework.web.reactive.DispatcherHandler</code>）来确定当前应用的类型：</p>
<ul>
<li><strong>REACTIVE</strong>：响应式 Web 应用（基于 Reactor 和
WebFlux）。</li>
<li><strong>SERVLET</strong>：传统的 Servlet 类型 Web 应用（如使用
Spring MVC）。</li>
<li><strong>NONE</strong>：非 Web 应用，通常是命令行应用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br></pre></td></tr></table></figure>
<h3 id="加载工厂实例">4.加载工厂实例</h3>
<p>从 <code>META-INF/spring.factories</code>
中加载配置的<strong>初始化器</strong>
<code>ApplicationContextInitializer</code>
、<code>BootstrapRegistryInitializer</code>和<strong>监听器</strong>
<code>ApplicationListener</code>。</p>
<ul>
<li><code>BootstrapRegistryInitializer</code> 允许<strong>在
<code>Spring Boot</code> 启动时</strong>自定义初始化
<code>Bootstrap</code> 注册表。<code>Bootstrap</code>
注册表是一个支持应用上下文的初始化过程的机制，通常用于配置与应用启动相关的共享资源。</li>
<li><code>ApplicationContextInitializer</code> 允许用户<strong>在
<code>ApplicationContext</code>
刷新前</strong>进行进一步的初始化配置操作。这包括但不限于添加属性源、修改环境变量、设置
Bean 定义等。</li>
<li><code>ApplicationListener</code>，用于监听 Spring Boot
的生命周期事件。这些监听器会在应用启动过程中响应不同的事件，如应用启动事件、环境准备事件、上下文刷新事件等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Bootstrap注册表初始化器</span></span><br><span class="line"><span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="built_in">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line"><span class="comment">// 加载应用上下文初始化器</span></span><br><span class="line"><span class="built_in">this</span>.setInitializers(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">// 加载监听器</span></span><br><span class="line"><span class="built_in">this</span>.setListeners(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure>
<p><code>getSpringFactoriesInstances()</code>
方法的<strong>核心方法</strong>：</p>
<ul>
<li><code>loadFactoryNames()</code>：利用 <a href="#load">SpringFactoriesLoader</a> 获取指定工厂的实现类的 Set
集合</li>
<li><code>createSpringFactoriesInstances</code>：通过<strong>反射机制</strong>实例化每个工厂的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Spring工厂加载器获取指定工厂的实现类的set集合</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line"><span class="comment">// 通过反射机制实例化每个工厂的实现类</span></span><br><span class="line">List&lt;T&gt; instances = <span class="built_in">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br></pre></td></tr></table></figure>
<h3 id="推断主类">5.推断主类</h3>
<p>通过 <code>StackTraceElement</code> 找到 <code>main</code>
方法，确定应用程序的入口类。这通常是标记了
<code>@SpringBootApplication</code> 注解的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.mainApplicationClass = <span class="built_in">this</span>.deduceMainApplicationClass();</span><br></pre></td></tr></table></figure>
<h2 id="执行run方法">执行run方法</h2>
<h3 id="启动计时器并初始化">1.启动计时器并初始化</h3>
<ul>
<li><p>在执行<code>run</code>方法的开头，首先启动一个计时器以记录应用启动的总时长。</p></li>
<li><p>接着，创建一个<code>DefaultBootstrapContext</code>，它会遍历并执行在<code>Bootstrap</code>注册表中的所有初始化器，以确保启动过程中的必要资源和设置得到正确配置。</p></li>
<li><p>然后，<code>ConfigurableApplicationContext</code>的引用被声明为<code>null</code>，并配置无头属性，以便在没有用户界面的环境中正常运行。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1.启动计时器</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="comment">// 1.2.初始化bootstrapContext上下文，该方法会遍历并执行BootStrap注册表中的初始化器</span></span><br><span class="line"><span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext();</span><br><span class="line"><span class="comment">// 1.3.声明ApplicationContext为null</span></span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 1.4.设置无头属性</span></span><br><span class="line"><span class="built_in">this</span>.configureHeadlessProperty();</span><br></pre></td></tr></table></figure>
<h3 id="获取并启动监听器">2.获取并启动监听器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1.获取监听器</span></span><br><span class="line"><span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line"><span class="comment">// 2.2.通知监听器，应用程序即将启动</span></span><br><span class="line">listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br></pre></td></tr></table></figure>
<p>在获取监听器的方法 <code>getRunListeners()</code>
中，将所有的监听器封装为一个 <a href="#listener">SpringApplicationRunListeners</a>
对象，由于在构造函数执行阶段已经加载了监听器对象，在调用方法
<code>getSpringFactoriesInstances</code> 时会直接查询缓存获取对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1.获取监听器</span></span><br><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringApplication.class, String[].class&#125;;</span><br><span class="line">    <span class="comment">// 封装从getSpringFactoriesInstances()方法中获得工厂的所有实现类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger, <span class="built_in">this</span>.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args), <span class="built_in">this</span>.applicationStartup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知监听器<strong>应用即将启动</strong>。这一步骤确保所有监听器能够在应用启动的早期阶段参与并进行必要的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.2.通知监听器</span></span><br><span class="line">listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass)</span><br></pre></td></tr></table></figure>
<h3 id="装配环境参数">3.装配环境参数</h3>
<ul>
<li>将环境参数与<strong>「引导上下文」</strong>绑定，<code>prepareEnvironment()</code>
方法会加载应用的外部配置。这包括 <code>application.properties</code> 或
<code>application.yml</code> 文件中的属性，环境变量，系统属性等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.1.创建命令行参数对象</span></span><br><span class="line"><span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"><span class="comment">// 3.2.加载应用的外部配置</span></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"><span class="comment">// 3.3.配置忽略 Bean 信息</span></span><br><span class="line"><span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br></pre></td></tr></table></figure>
<p>在<code>prepareEnvironment()</code>
方法中，首先会进行环境配置，还会执行监听器的
<code>environmentPrepared()</code>
方法，表明应用程序的环境已经准备好，最后再将环境绑定到应用程序中。</p>
<h3 id="打印横幅">4.打印横幅</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br></pre></td></tr></table></figure>
<h3 id="创建应用上下文">5.创建应用上下文</h3>
<p>根据构造阶段推断出的 Web 应用类型，创建Spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.调用createApplicationContext方法创建Spring容器</span></span><br><span class="line">context = <span class="built_in">this</span>.createApplicationContext();</span><br></pre></td></tr></table></figure>
<h3 id="应用上下文准备阶段">6.应用上下文准备阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>
<p>进入 <code>prepareContext()</code>方法，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">    <span class="comment">// 6.1.将传入的环境参数应用到上下文中，并调用后处理方法</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    <span class="built_in">this</span>.postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// 6.2.遍历并执行所有注册的初始化器，进一步配置应用上下文</span></span><br><span class="line">    <span class="built_in">this</span>.applyInitializers(context);</span><br><span class="line">    <span class="comment">// 6.3.通知监听器，上下文准备完毕</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="comment">// 6.4.关闭启动阶段的引导上下文，释放与启动相关的资源</span></span><br><span class="line">    bootstrapContext.close(context);</span><br><span class="line">    <span class="comment">// 6.5.打印日志启动信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 6.6.将命令行参数和横幅注册为Bean，存放到应用上下文中</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 6.7.根据Bean工厂，允许配置循环引用和 bean 定义覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractAutowireCapableBeanFactory) &#123;</span><br><span class="line">    ((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 6.8.设置懒初始化配置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">        context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">PropertySourceOrderingBeanFactoryPostProcessor</span>(context));</span><br><span class="line">    <span class="comment">// 6.9.加载源，确保应用上下文中定义的 bean 被正确创建。</span></span><br><span class="line">    Set&lt;Object&gt; sources = <span class="built_in">this</span>.getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 6.10.通知监听器，所有的Bean都已经加载但未进行实例化</span></span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用上下文刷新阶段">7.应用上下文刷新阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.refreshContext(context);</span><br></pre></td></tr></table></figure>
<ul>
<li>首先通过加锁确保线程安全，创建并配置
<code>BeanFactory</code>，这一过程包括注册 Bean
后处理器和事件监听器。</li>
<li>在 <code>onRefresh()</code> 方法中，还会启动 Web 服务器。</li>
<li>最后，通过配置好的 <code>BeanFactory</code>
<strong>实例化</strong>所有的
<code>Beans</code>。在这个过程中，<code>BeanFactory</code>
会根据定义的元数据创建和初始化
<code>Beans</code>，并根据需求进行<strong>依赖注入</strong>，确保整个应用的组件能够顺利协作。</li>
</ul>
<h3 id="应用上下文收尾阶段">8.应用上下文收尾阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8.1.afterRefresh()无实际内容，后续版本被移除</span></span><br><span class="line"><span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line"><span class="comment">// 8.2.计算应用启动时间</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8.3.通知监听器，应用程序启动完成</span></span><br><span class="line">listeners.started(context, timeTakenToStartup);</span><br></pre></td></tr></table></figure>
<h3 id="回调运行器">9.回调运行器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 9.1.回调运行器</span></span><br><span class="line"><span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line"><span class="comment">// 9.2.通知监听器</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">listeners.ready(context, timeTakenToReady);</span><br></pre></td></tr></table></figure>
<p>该方法从上下文 <code>context</code> 中获取所有已注册的
<code>ApplicationRunner</code> 和
<code>CommandLineRunner</code>，并结合传入的应用参数
<code>args</code>执行这些运行器。</p>
<p>这些运行器允许<strong>开发者在应用程序启动后执行特定的逻辑</strong>，例如初始化数据、设置应用状态或执行启动任务，提供了灵活性和扩展性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">    List&lt;Object&gt; runners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 9.1.1.从上下文中获取运行器</span></span><br><span class="line">    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">    AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(runners)).iterator();</span><br><span class="line">	<span class="comment">// 9.1.2.结合应用参数执行运行器</span></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">runner</span> <span class="operator">=</span> var4.next();</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">            <span class="built_in">this</span>.callRunner((ApplicationRunner)runner, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">            <span class="built_in">this</span>.callRunner((CommandLineRunner)runner, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理">10.异常处理</h3>
<p>在整个启动过程中，如果出现任何异常，都会被捕获并通过<code>handleRunFailure()</code>方法进行处理，在该方法中，会通知监听器应用程序启动时出现异常。</p>
<p>该方法会记录错误信息，并通过监听器通知失败事件。最终，抛出<code>IllegalStateException</code>来中止应用启动，确保调用者能够识别到启动失败的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">    ex = var12;</span><br><span class="line">    <span class="built_in">this</span>.handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="listener"></span></p>
<h2 id="springapplicationrunlisteners监听器">SpringApplicationRunListeners监听器</h2>
<p><code>SpringApplicationRunListeners</code> 是一个具体的类。它实现了
Spring Boot
中的监听器机制，用于在应用程序的不同启动阶段通知注册的监听器（<code>SpringApplicationRunListener</code>
接口的实现类）。通过这个类，Spring Boot
可以在应用启动过程中管理多个监听器，处理各种生命周期事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplicationRunListeners(Log log, Collection&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplicationRunListener</span>&gt; listeners, ApplicationStartup applicationStartup) &#123;</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    <span class="built_in">this</span>.log = log;</span><br><span class="line">    <span class="comment">// 保存已注册的监听器列表，这些监听器会对应用程序生命周期事件做出响应</span></span><br><span class="line">    <span class="built_in">this</span>.listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(listeners);</span><br><span class="line">    <span class="comment">// 跟踪启动步骤，以便进行性能监控</span></span><br><span class="line">    <span class="built_in">this</span>.applicationStartup = applicationStartup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SpringApplicationRunListener</code> 是 Spring Boot
中的一个接口，用于<strong>在应用启动过程的不同阶段提供回调</strong>。实现这个接口<strong>允许监听并响应应用生命周期中的关键事件</strong>。该接口定义了多个方法，每个方法对应启动过程中的特定阶段，包括：</p>
<ol type="1">
<li><strong>starting()</strong>:
在运行开始时调用，此时尚未开始任何处理，可以用于初始化在启动过程中需要的资源。</li>
<li><strong>environmentPrepared()</strong>: 当
<code>SpringApplication</code> 准备好 <code>Environment</code> 但在创建
<code>ApplicationContext</code>
之前调用，这是修改应用环境属性的好时机。</li>
<li><strong>contextPrepared()</strong>: 当
<code>ApplicationContext</code>
准备好但在加载之前调用，可以用于对上下文进行预处理。</li>
<li><strong>contextLoaded()</strong>: 当 <code>ApplicationContext</code>
被加载但在刷新之前调用，此时所有的 Bean
定义都已加载，但尚未实例化。</li>
<li><strong>started()</strong>: 在 <code>ApplicationContext</code>
刷新之后、任何应用运行器和命令行运行器被调用之前调用，此时应用已经准备好接收请求。</li>
<li><strong>running()</strong>:
在运行器被调用之后、应用启动完成之前调用，这是在应用启动并准备好服务请求时执行某些动作的好时机。</li>
<li><strong>failed()</strong>:
如果启动过程中出现异常，则调用此方法。</li>
</ol>
<h1 id="springfactoriesloader原理">SpringFactoriesLoader原理</h1>
<p><code>SpringFactoriesLoader</code>方法会根据传入的<strong>工厂类</strong>和<strong>类加载器</strong>，从
<code>META-INF/spring.factories</code>
文件中加载<strong>「指定类型对应的工厂类名称」</strong>。<span id="load"></span></p>
<h2 id="loadfactorynames">loadFactoryNames()</h2>
<p><code>loadFactoryNames</code> 方法是一个高级
API，它通过获取入参中的<strong>全限定类名</strong>
<code>factoryTypeName</code>，在内部调用
<code>loadSpringFactories()</code> 方法获取返回的 Map 集合，并根据
<code>factoryTypeName</code> 获取了 Map 中的<strong>实现类的 List
集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取工厂类的全限定名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">    <span class="comment">// 从 loadSpringFactories 返回的 Map 中获取指定类型工厂的实现类</span></span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoaderToUse)</span><br><span class="line">        .getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadspringfactories">loadSpringFactories()</h2>
<p><code>loadSpringFactories</code>
方法是更加底层的方法，通过<strong>缓存机制</strong>和<strong>类加载器</strong>获取
<code>spring.factories</code>
文件中所有配置的工厂及其实现类，将这些信息封装为 <code>Map</code>
集合后返回给上游的 API。</p>
<h3 id="缓存机制">缓存机制</h3>
<p>方法会检查是否已经通过当前类加载器加载过
<code>spring.factories</code> 文件。如果缓存 (<code>cache</code>)
中已经存在相应的工厂信息，直接返回缓存的
<code>Map&lt;String, List&lt;String&gt;&gt;</code>，避免重复加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载-meta-infspring.factories">加载
META-INF/spring.factories</h3>
<p>方法会通过<strong>类加载器</strong>查找<strong>所有路径</strong>下名为
<code>META-INF/spring.factories</code> 的文件。由于每个 JAR
包都可能包含一个 <code>META-INF/spring.factories</code>
文件，方法会返回一个 <code>Enumeration&lt;URL&gt;</code>
对象，表示找到的所有相关资源文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="解析spring.factories文件">解析spring.factories文件</h3>
<p>通过迭代逐个读取每个找到的 <code>spring.factories</code>
文件。对于每个文件，使用
<code>PropertiesLoaderUtils.loadProperties()</code> 将文件内容解析为
<code>Properties</code> 对象。</p>
<p>每个 <code>Properties</code> 对象对应一个
<code>spring.factories</code> 文件的内容，其中 key 是工厂类型（例如
<code>org.springframework.context.ApplicationContextInitializer</code>），value
是逗号分隔的工厂实现类列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> (URL)urls.nextElement();</span><br><span class="line">    <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br></pre></td></tr></table></figure>
<h3 id="将工厂类型和实现类存入map">将工厂类型和实现类存入Map</h3>
<p>遍历 <code>Properties</code> 的 <code>entrySet()</code>。对于每个
<code>entry</code>，<code>key</code>
是工厂类型的全限定类名，<code>value</code>
是对应的工厂实现类名（逗号分隔）。</p>
<p>工厂类型名称通过 <code>entry.getKey()</code> 获取，并使用
<code>String.trim()</code>
去除可能的空白字符。工厂实现类则将逗号分隔的字符串转换为实现类的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String)entry.getKey()).trim();</span><br><span class="line">    String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">    String[] var10 = factoryImplementationNames;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> factoryImplementationNames.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryImplementationName</span> <span class="operator">=</span> var10[var12];</span><br><span class="line">        ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;)).add(factoryImplementationName.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>SpringBoot启动流程</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】源码解析——自动装配与starter机制</title>
    <url>/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%8Estarter%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="自动装配机制">自动装配机制</h1>
<p>在传统的 Spring 框架中，开发者需要通过 <code>XML</code> 文件或
<code>Java</code> 配置类显式地声明 Bean
和各种配置项（例如数据源、事务管理、视图解析器等）。Spring Boot
的自动装配旨在减少这些繁琐的配置，通过默认的配置和条件装配，自动完成很多配置工作，从而减少开发者的配置量。</p>
<h2 id="springbootapplication注解"><span class="citation" data-cites="SpringBootApplication注解">@SpringBootApplication注解</span></h2>
<p>可以把 <code>@SpringBootApplication</code> 注解看作是
<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>
注解的集合。</p>
<ul>
<li><strong><code>@EnableAutoConfiguration</code></strong>：自动配置机制的核心注解。</li>
<li><strong><code>@SpringBootConfiguration</code></strong>：作为
<code>@Configuration</code> 注解的扩展，它标识该类为 Spring
的配置类。在该类中可以定义 <code>@Bean</code>
方法，这些方法返回的对象将被注册到 Spring
容器中，由容器管理其生命周期。</li>
<li><strong><code>@ComponentScan</code></strong>：从声明
<code>@SpringBootApplication</code> 的类所在的包开始，自动扫描并注册
<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>
等注解的类到 Spring
容器中。它确保应用程序的组件、服务、控制器等能够被自动发现和注入。</li>
</ul>
<h2 id="enableautoconfiguration核心注解"><span class="citation" data-cites="EnableAutoConfiguration核心注解">@EnableAutoConfiguration核心注解</span></h2>
<p><code>@EnableAutoConfiguration</code> 通过 <code>@Import</code>
注解导入了 <code>AutoConfigurationImportSelector</code> 类。</p>
<p><code>@Import</code> 注解的作用是将指定的配置类或
<code>ImportSelector</code> 导入到当前的配置类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autoconfigurationimportselector核心类">AutoConfigurationImportSelector核心类</h2>
<p><code>AutoConfigurationImportSelector</code>
是自动装配的核心类，其实现了<code>ImportSelector</code>接口的
<strong><code>selectImports</code></strong>方法。</p>
<h2 id="selectimports方法">selectImports()方法</h2>
<p>该方法主要有两个作用：</p>
<ol type="1">
<li>判断自动装配开关是否打开，检查 yml 文件是否修改了
<code>spring.boot.enableautoconfiguration=false</code></li>
<li>调用
<code>getAutoConfigurationEntry()</code>方法，获取需要自动装配的
bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">// 1.判断自动装配开关是否打开</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.获取所有需要自动装配的bean</span></span><br><span class="line">        <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getautoconfigurationentry">getAutoConfigurationEntry()</h2>
<p><code>getAutoConfigurationEntry()</code> 方法的核心作用是在 Spring
启动时，对当前应用中的自动配置类进行<strong>去重</strong>和<strong>筛选</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断自动装配开关是否打开</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.获取@EnableAutoConfiguration注解中的exclude和excludeName属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// *3.获取位于META-INF/spring.factories下候选的所有配置类</span></span><br><span class="line">        List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">// 4.1.移除重复的类</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">// 4.2.排除exclude和excludeName数组中包含的配置类</span></span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        <span class="comment">// 4.3.根据当前应用环境进一步筛选配置类</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="comment">// 5.触发自动配置事件</span></span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getcandidateconfigurations核心方法">getCandidateConfigurations()核心方法</h3>
<p>跟进到 <code>getCandidateConfigurations()</code> 方法，主要通过
<code>SpringFactoriesLoader</code> 和 <code>ImportCandidates</code>
来加载自动配置的候选类。</p>
<ul>
<li>使用 <a href="#load">SpringFactoriesLoader</a> 加载
<code>META-INF/spring.factories</code> 文件中定义的与
<code>EnableAutoConfiguration.class</code> 相关的实现类。</li>
<li>通过 <code>ImportCandidates</code> 加载与
<code>AutoConfiguration.class</code>
相关的其他候选实现类，并将这些类添加到 <code>configurations</code>
列表中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用SpringFactoriesLoader获取工厂的实现类</span></span><br><span class="line">    List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(SpringFactoriesLoader.loadFactoryNames(<span class="built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="built_in">this</span>.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 2.使用ImportCandidates加载工厂的实现类</span></span><br><span class="line">    ImportCandidates.load(AutoConfiguration.class, <span class="built_in">this</span>.getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;xxx.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，使用 <code>Assert.notEmpty()</code> 方法确保
<code>configurations</code> 列表中至少有一个候选类后，返回候选类。</p>
<h2 id="条件化装配">条件化装配</h2>
<h3 id="常见注解">常见注解</h3>
<ul>
<li><strong>Bean 条件注解</strong>：
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean
的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean
在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
</ul></li>
<li><strong>Class 条件注解</strong>：
<ul>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
</ul></li>
<li><strong>属性条件注解</strong>：<code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><strong>Web 应用条件注解</strong>：
<ul>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web
项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项
目的条件下</li>
</ul></li>
<li><strong>其他条件注解</strong>：
<ul>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL
表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI
存在的条件下差在指定的位置</li>
</ul></li>
</ul>
<h1 id="springfactoriesloader原理">SpringFactoriesLoader原理</h1>
<p><code>SpringFactoriesLoader</code>方法会根据传入的<strong>工厂类</strong>和<strong>类加载器</strong>，从
<code>META-INF/spring.factories</code>
文件中加载<strong>「指定类型对应的工厂类名称」</strong>。<span id="load"></span></p>
<h2 id="loadfactorynames">loadFactoryNames()</h2>
<p><code>loadFactoryNames</code> 方法是一个高级
API，它通过获取入参中的<strong>全限定类名</strong>
<code>factoryTypeName</code>，在内部调用
<code>loadSpringFactories()</code> 方法获取返回的 Map 集合，并根据
<code>factoryTypeName</code> 获取了 Map 中的<strong>实现类的 List
集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取工厂类的全限定名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">    <span class="comment">// 从 loadSpringFactories 返回的 Map 中获取指定类型工厂的实现类</span></span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoaderToUse)</span><br><span class="line">        .getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadspringfactories">loadSpringFactories()</h2>
<p><code>loadSpringFactories</code>
方法是更加底层的方法，通过<strong>缓存机制</strong>和<strong>类加载器</strong>获取
<code>spring.factories</code>
文件中所有配置的工厂及其实现类，将这些信息封装为 <code>Map</code>
集合后返回给上游的 API。</p>
<h3 id="缓存机制">缓存机制</h3>
<p>方法会检查是否已经通过当前类加载器加载过
<code>spring.factories</code> 文件。如果缓存 (<code>cache</code>)
中已经存在相应的工厂信息，直接返回缓存的
<code>Map&lt;String, List&lt;String&gt;&gt;</code>，避免重复加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载-meta-infspring.factories">加载
META-INF/spring.factories</h3>
<p>方法会通过<strong>类加载器</strong>查找<strong>所有路径</strong>下名为
<code>META-INF/spring.factories</code> 的文件。由于每个 JAR
包都可能包含一个 <code>META-INF/spring.factories</code>
文件，方法会返回一个 <code>Enumeration&lt;URL&gt;</code>
对象，表示找到的所有相关资源文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="解析spring.factories文件">解析spring.factories文件</h3>
<p>通过迭代逐个读取每个找到的 <code>spring.factories</code>
文件。对于每个文件，使用
<code>PropertiesLoaderUtils.loadProperties()</code> 将文件内容解析为
<code>Properties</code> 对象。</p>
<p>每个 <code>Properties</code> 对象对应一个
<code>spring.factories</code> 文件的内容，其中 key 是工厂类型（例如
<code>org.springframework.context.ApplicationContextInitializer</code>），value
是逗号分隔的工厂实现类列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> (URL)urls.nextElement();</span><br><span class="line">    <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br></pre></td></tr></table></figure>
<h3 id="将工厂类型和实现类存入map">将工厂类型和实现类存入Map</h3>
<p>遍历 <code>Properties</code> 的 <code>entrySet()</code>。对于每个
<code>entry</code>，<code>key</code>
是工厂类型的全限定类名，<code>value</code>
是对应的工厂实现类名（逗号分隔）。</p>
<p>工厂类型名称通过 <code>entry.getKey()</code> 获取，并使用
<code>String.trim()</code>
去除可能的空白字符。工厂实现类则将逗号分隔的字符串转换为实现类的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String)entry.getKey()).trim();</span><br><span class="line">    String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">    String[] var10 = factoryImplementationNames;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> factoryImplementationNames.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryImplementationName</span> <span class="operator">=</span> var10[var12];</span><br><span class="line">        ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;)).add(factoryImplementationName.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spring-boot-starter机制">Spring Boot Starter机制</h1>
<p>Spring Boot Starter 是一组方便的依赖描述符，旨在简化 Maven 和 Gradle
项目的依赖管理。每个 <code>Starter</code>
通常包含与某种功能或库相关的依赖，开发者只需引入相应的
<code>Starter</code>，就可以自动获得这些依赖及其配置。</p>
<h2 id="实现原理">实现原理</h2>
<h3 id="依赖管理">依赖管理</h3>
<p>Spring Boot
Starter本质上是一个Maven或Gradle依赖，包含了一组已配置好的常用库。例如，<code>spring-boot-starter-web</code>包含了Spring
MVC、Jackson（用于JSON处理）、Tomcat（作为默认的嵌入式Web服务器）等依赖。</p>
<p>通过在项目中添加Starter依赖，开发者无需逐个添加这些库。Starter通常命名为
<code>spring-boot-starter-xxx</code>，其中<code>xxx</code>表示特定的功能模块。例如：</p>
<ul>
<li><code>spring-boot-starter-data-jpa</code>：包含Spring Data
JPA和Hibernate依赖。</li>
<li><code>spring-boot-starter-security</code>：包含Spring
Security依赖。</li>
<li><code>spring-boot-starter-web</code>：用于开发Web应用，包含Spring
MVC及相关依赖。</li>
</ul>
<h3 id="自动装配机制-1">自动装配机制</h3>
<p>Spring
Boot在启动时会自动扫描类路径下的资源文件和<code>META-INF/spring.factories</code>，从中找到定义的自动配置类。每个自动配置类根据一组条件（如类路径中是否存在特定类或是否有某些配置属性）来决定是否启用。</p>
<p>自动装配机制基于<code>@EnableAutoConfiguration</code>注解，它通过读取所有路径下
<code>spring.factories</code>
文件中的配置，加载与项目相关的自动配置类。例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.autoconfigure.MyAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="加载配置文件">加载配置文件</h3>
<p>Spring
Boot默认会从<code>classpath</code>下加载<code>application.properties</code>或<code>application.yml</code>配置文件，开发者可以通过这些文件提供自定义的配置属性，来覆盖自动配置中的默认值。此外，Spring
Boot还支持通过命令行参数、环境变量等方式注入配置，以便在不同环境中灵活调整应用配置。</p>
<h2 id="自定义starter">自定义Starter</h2>
<h3 id="创建工程">创建工程</h3>
<p>创建一个名为 <code>thread-spring-boot-starter</code> 的工程，使用
<code>Maven</code> 添加所需的基本依赖。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202410221527664.png" style="zoom: 80%;"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编写配置类">编写配置类</h3>
<p>创建自动配置类，使用 <code>@Configuration</code>
注解，并结合条件注解（如
<code>@ConditionalOnClass</code>）来定义自动装配逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>,</span><br><span class="line">                TimeUnit.MICROSECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册配置类">注册配置类</h3>
<p>在<code>src/main/resources/META-INF</code>目录下创建一个<code>spring.factories</code>文件，并添加以下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.example.config.ThreadPoolAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="添加starter依赖">添加Starter依赖</h3>
<p>将其打包并安装到本地Maven仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>
<p>一旦安装完成，其他项目就可以通过在其<code>pom.xml</code>文件中添加以下依赖来使用这个Starter了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入手写的starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thread-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用starter">使用Starter</h3>
<p>在其他项目中，可以通过<code>@Autowired</code>注解获取<code>ThreadPoolExecutor</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = ProjectApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarterTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadPoolTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;核心线程数：&quot;</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;最大线程数：&quot;</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>自动装配</tag>
        <tag>starter机制</tag>
      </tags>
  </entry>
  <entry>
    <title>【分布式】万字图文解析——深入七大分布式事务解决方案</title>
    <url>/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="分布式事务">分布式事务</h1>
<p>分布式事务是指跨多个独立服务或系统的事务管理，以确保这些服务中的数据变更要么全部成功，要么全部回滚，从而<strong>保证数据的一致性</strong>。在微服务架构和分布式系统中，由于业务逻辑往往会跨多个服务，传统的单体事务无法覆盖，因此需要通过分布式事务来保障一致性。</p>
<p>三种数据一致性模型：</p>
<ul>
<li><strong>强一致性</strong>：系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。</li>
<li><strong>弱一致性</strong>：放宽了一致性保证，允许在不同节点之间的数据访问之间存在一定程度的不一致性，以换取更高的性能和可用性。</li>
<li><strong>最终一致性</strong>：允许在系统发生分区或网络故障后，经过一段时间，系统将最终达到一致状态。</li>
</ul>
<h1 id="刚性事务">刚性事务</h1>
<p>刚性事务（Rigid
Transaction）也称为<strong>强一致性事务</strong>，遵循严格的ACID特性（原子性、一致性、隔离性、持久性），确保所有操作都严格按照要求执行，要么全部成功，要么全部回滚。刚性事务常用于金融系统、银行转账等场景，要求数据高度一致，不能有任何误差。</p>
<p>在分布式系统中，实现刚性事务通常采用<strong>2PC</strong>或<strong>3PC协议</strong>，但这些协议会带来较高的性能开销，同时存在同步阻塞等问题。因此，刚性事务适合对数据一致性要求极高、但允许较高事务延迟的场景。</p>
<p><strong>2PC</strong>或<strong>3PC协议</strong>根据 <code>XA</code>
规范衍生而来，<code>XA</code>
规范将分布式事务处理模型中涉及到了角色主要分为了应用程序（AP）、事务管理器（TM）和资源管理器（RM）</p>
<ul>
<li><code>AP(Application Program)</code>：应用程序本身。</li>
<li><code>RM(Resource Manager)</code>：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库，一个分布式事务往往涉及到多个资源管理器。</li>
<li><code>TM(Transaction Manager)</code>：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li>
</ul>
<h2 id="两阶段提交">两阶段提交</h2>
<p>2PC（Two-Phase Commit
Protocol，两阶段提交协议）是分布式系统中广泛使用的一种协议，用于保证事务跨多个节点（参与者）一致地提交或回滚。</p>
<p>两阶段提交协议分为两个阶段：<strong>准备阶段</strong>和<strong>提交阶段</strong>。</p>
<h3 id="准备阶段">准备阶段</h3>
<ol type="1">
<li><strong>事务管理器（TM）</strong>向所有<strong>事务参与者（资源管理器，RM）</strong>发送<strong>准备提交（prepare）</strong>的请求。</li>
<li>每个事务参与者在收到请求后执行以下操作：
<ul>
<li>执行<strong>本地数据库事务预操作</strong>，比如写
<code>redo log / undo log</code>
日志，保留修改（如将数据写入暂存区域或进行日志记录），但不提交。</li>
<li>若该操作能够成功完成并保证后续提交，则返回<strong>同意消息</strong>。</li>
<li>若遇到错误或不能确保事务提交成功，则返回<strong>拒绝消息</strong>。</li>
</ul></li>
<li>在准备阶段，事务参与者只是准备提交，尚未实际提交事务。这使得系统仍然处于一致性状态。</li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131025662.png" style="zoom:25%;"></p>
<h3 id="提交阶段">提交阶段</h3>
<ol type="1">
<li>如果所有事务参与者都返回了<strong>同意消息</strong>，事务管理器向所有参与者发送<strong>提交（Commit）请求</strong>。
<ul>
<li>各参与者收到提交消息后，正式提交事务操作，释放锁，清除临时数据，并通知事务管理器提交成功。</li>
</ul></li>
<li>如果任何一个事务参与者返回<strong>拒绝消息</strong>，事务管理器向所有参与者发送<strong>回滚（Rollback）请求</strong>。
<ul>
<li>各参与者收到回滚消息后，撤销预操作，将状态恢复到事务开始之前。</li>
</ul></li>
<li>在提交阶段，如果某个参与者出现故障，事务管理器会根据超时或故障检测机制来决定事务状态，尽量使所有节点最终保持一致。</li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131039069.png" style="zoom:25%;"></p>
<h3 id="存在的问题">存在的问题</h3>
<ul>
<li><strong>同步阻塞</strong>：在事务提交的过程中，如果事务管理者出现故障，所有的事务参与者会进入阻塞状态，等待事务管理者的进一步指令，导致整个系统的事务处理停滞，不能继续执行其他事务。</li>
<li><strong>单点故障</strong>：事务管理器是单点故障，如果事务管理器在提交阶段崩溃，系统将无法知道事务的最终状态，容易导致数据不一致。</li>
<li><strong>数据不一致风险</strong>：在提交阶段，若事务管理器在发送提交或回滚请求后崩溃，可能导致部分参与者收到提交请求，而部分未收到，从而造成数据不一致。</li>
</ul>
<h2 id="三阶段提交">三阶段提交</h2>
<p>3PC（Three-Phase Commit
Protocol，三阶段提交协议）是在两阶段提交协议的基础上进一步改进的分布式事务一致性协议，通过增加<strong>预提交阶段</strong>，增强了系统的容错能力和处理网络分区的能力，以解决2PC的同步阻塞问题和单点故障风险。</p>
<h3 id="准备阶段-1">准备阶段</h3>
<ol type="1">
<li><strong>事务管理器（TM）</strong>向所有<strong>事务参与者（资源管理器，RM）</strong>发送「准备请求」，询问它们是否能够完成事务提交操作。</li>
<li>每个事务参与者收到「准备请求」后，如果认为自己可以完成事务，则返回<strong>同意消息</strong>；如果认为无法完成，则返回<strong>拒绝消息</strong>。</li>
<li>事务管理器收集所有参与者的响应：
<ul>
<li>若所有事务参与者都返回<strong>同意消息</strong>，则进入预提交阶段。</li>
<li>若任何一个事务参与者返回<strong>拒绝消息</strong>，则进入终止阶段并通知所有参与者回滚事务。</li>
</ul></li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131049007.png" style="zoom:25%;"></p>
<h3 id="预提交阶段">预提交阶段</h3>
<ol type="1">
<li>如果所有事务参与者在第一阶段都返回了<strong>同意消息</strong>，事务管理器向所有参与者发送「预提交请求」。</li>
<li>每个事务参与者收到「预提交请求」后，执行<strong>本地数据库事务预操作</strong>，记录日志，保存即将提交的事务信息，以确保即使事务管理器故障也能恢复状态。如果事务参与者成功执行了事务预操作，发送<strong>预提交成功</strong>给事务管理器；如果执行失败，返回<strong>预提交失败</strong>给事务管理器。</li>
<li>预提交阶段通过提前记录事务信息，保证即使事务管理器故障，事务参与者也能够通过日志记录自我恢复。</li>
<li>事务管理器<strong>在等待一段时间后</strong>收集所有参与者的响应：
<ul>
<li>若所有参与者都返回<strong>预提交成功</strong>，事务管理器进入提交阶段。</li>
<li>若任意一个参与者返回<strong>预提交失败</strong>，则事务管理器进入终止阶段并通知所有参与者回滚事务。</li>
</ul></li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131054246.png" style="zoom:25%;"></p>
<h3 id="提交阶段-1">提交阶段</h3>
<ol type="1">
<li>若事务管理器在预提交阶段收到所有参与者的<strong>预提交成功</strong>，则向所有参与者发送「事务提交请求」。
<ul>
<li>各参与者收到提交请求后，正式提交事务操作，释放锁，清除临时数据，并返回<strong>提交完成</strong>。</li>
</ul></li>
<li>若事务管理器在预提交阶段未收到所有参与者的响应，或检测到参与者或事务管理器自身出现故障，则事务管理器向所有参与者发送「事务回滚请求」。
<ul>
<li>各参与者收到回滚请求后，撤销事务，并返回<strong>回滚完成</strong>。</li>
</ul></li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131039069.png" style="zoom:25%;"></p>
<h3 id="优缺点">优缺点</h3>
<p>虽然 3PC
通过引入<strong>超时机制</strong>和<strong>预提交阶段</strong>一定程度上解决了
2PC
的同步阻塞和单点故障的问题，但是依然存在数据不一致的问题，同时也引入了一些新问题比如性能糟糕。</p>
<ul>
<li><strong>解决同步阻塞</strong>：在3PC中，通过<strong>预提交阶段</strong>参与者在实际提交前达成共识状态，具备了超时控制和独立决策的条件。即使协调者故障，参与者也能在超时后依据自身状态决定提交或回滚，从而有效避免了因协调者故障导致的长时间同步阻塞问题。</li>
<li><strong>解决单点故障</strong>：在3PC中，事务参与者引入了<strong>超时机制</strong>，当事务管理者挂掉后，事务参与者在等待超时后可以根据自身的状态来进行决策（如提交或回滚），不必依赖事务管理者的指令，从而降低了事务管理者的单点故障风险。</li>
</ul>
<p>存在的问题：</p>
<ul>
<li><strong>网络分区风险</strong>：3PC试图通过在预提交阶段前引入准备阶段来减少阻塞问题，但如果在该阶段发生网络分区，事务管理器和参与者之间的通信可能会断开。此时，部分参与者可能会继续提交事务，而其他未收到指令的参与者则可能回滚，从而导致数据不一致。</li>
<li><strong>性能降低</strong>：3PC虽然解决了一些2PC的阻塞问题，但增加的确认阶段和处理步骤使得事务处理的整体延迟变高。在高并发环境下，系统性能和响应速度可能会受到影响，导致事务处理效率较低。</li>
<li><strong>数据不一致风险</strong>：虽然3PC引入了超时机制，但当事务管理器在预提交阶段（准备提交）崩溃且没有及时恢复时，参与者可能会依据超时策略决定提交或回滚，导致不同参与者采取了不同的事务状态，从而产生数据不一致。</li>
</ul>
<h1 id="柔性事务">柔性事务</h1>
<p>柔性事务（Flexible
Transaction）也称为<strong>最终一致性事务</strong>，放宽了对事务的严格性要求，允许系统在短期内出现不一致，只要在一段时间后达成<strong>最终一致性</strong>即可。柔性事务通常不完全遵循ACID特性，而采用<strong>BASE理论</strong>（基本可用、软状态、最终一致），在保证系统可用性的同时降低了对一致性的强制要求。</p>
<p>柔性事务广泛应用于电商订单处理、社交应用等对实时性和高可用性要求高，但数据一致性可延迟的场景。</p>
<p>柔性事务常见的实现方式包括：</p>
<ul>
<li><strong>TCC（Try-Confirm-Cancel）</strong>：将事务分解为三个步骤，先尝试（Try），再确认（Confirm）或取消（Cancel）。</li>
<li><strong>可靠消息事务</strong>：利用消息队列确保最终一致性，通过消息重试机制来保证事务操作的最终完成。</li>
<li><strong>补偿事务</strong>：通过补偿机制在出现错误时对事务进行回滚。</li>
</ul>
<h2 id="tcc">TCC</h2>
<p><strong>TCC</strong>（Try-Confirm-Cancel）是一种分布式事务解决方案，特别适用于柔性事务场景。TCC通过将事务分解为三个步骤来确保最终一致性，提供对事务操作的更加灵活的控制。</p>
<h3 id="执行流程">执行流程</h3>
<ul>
<li><strong>Try（尝试）阶段</strong>：事务参与者尝试执行本地事务，并对全局事务预留业务资源。如果
<code>try</code>
阶段执行成功，参与者会返回一个成功标识，否则会返回一个失败标识。</li>
<li><strong>Confirm（确认）阶段</strong>：如果所有参与者的
<code>try</code> 阶段都执行成功，则协调者通知所有参与者提交事务，执行
<code>confirm</code>
阶段。这时参与者将在本地提交事务，并处理全局事务预留的资源。</li>
<li><strong>Cancel（取消）阶段</strong>：如果任意参与者在
<code>try</code> 阶段或 <code>Confirm</code>
阶段执行失败，则协调者通知所有参与者回滚事务，执行 <code>cancel</code>
阶段。这时参与者将释放预留的业务资源。</li>
</ul>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131127522.png" style="zoom:25%;"></p>
<blockquote>
<p>如果<strong>Confirm</strong>或者<strong>Cancel</strong>执行失败，可以采用重试的方式减少因为网络问题导致TM没有接收到消息的情况，此外，还可以采用异常监控、日志记录和人工干预的方式来保证事务的一致性。</p>
<p>对于<strong>Confirm</strong>执行失败，还可以采用执行<strong>Cancel</strong>操作的方式，撤销在<strong>Try</strong>阶段预留的事务资源。</p>
</blockquote>
<h3 id="典型示例">典型示例</h3>
<p>假设我们有一个转账服务，需要从 A 账户转账 100 元到 B 账户，同时从 A
账户转账 200 元到 C 账户，总计从 A 账户中扣减 300 元。整个事务流程分为
Try、Confirm 和 Cancel 三个阶段：</p>
<ol type="1">
<li><strong>Try 阶段</strong>：转账服务首先冻结 A 账户的 300
元，以确保后续转账的可用性和一致性。</li>
<li><strong>Confirm 阶段</strong>：如果所有 Try
操作都成功执行，转账服务进入 Confirm 阶段，实际执行转账操作。此时，A
账户的冻结金额解冻，系统将 100 元转入 B 账户，200 元转入 C
账户，完成资金划转。</li>
<li><strong>Cancel 阶段</strong>：如果在 Try 阶段某一步失败，则系统进入
Cancel 阶段，对 A 账户的冻结金额进行解冻处理，保证资金不受影响；如果
Confirm 阶段中某步转账失败，例如 A 到 B 的转账失败，而 A 到 C
的转账已完成，则需要通过 C 到 A 的逆向转账操作将金额退回，保证 A
账户资金最终一致。</li>
</ol>
<p>通过这种方式，TCC
模式确保了分布式事务的最终一致性，即使在部分失败的情况下，系统也能通过回滚或补偿机制恢复到一致状态。</p>
<h3 id="存在的问题-1">存在的问题</h3>
<ul>
<li><strong>空回滚</strong>：在TCC协议中，如果某些参与者在<strong>Try</strong>阶段成功，而其他参与者失败，此时所有参与者需要执行<strong>Cancel</strong>操作。对于那些在<strong>Try</strong>阶段没有成功的参与者来说，执行<strong>Cancel</strong>操作就成为一次<strong>空回滚</strong>。如果业务没有有效地识别和处理空回滚，可能会导致异常错误，甚至可能导致<strong>Cancel</strong>一直失败，最终使整个分布式事务失败。</li>
<li><strong>悬挂事务</strong>：在TCC执行一阶段的<strong>Try</strong>操作阶段时，可能出现网络拥堵导致超时，事务协调器会触发二阶段的<strong>Cancel</strong>操作。而下游的节点由于网络延迟先接收到了<strong>Cancel</strong>，网络恢复后会在<strong>Cancel</strong>后再次接收到<strong>Try</strong>请求，这就导致该节点<strong>Try</strong>操作占用的资源无法释放，造成事务悬挂。</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<p>通过引入<strong>分布式事务记录表</strong>，可以解决上述两个问题。该表中两个关键字段，一个是
<code>tx_id</code> 字段用于保存本次处理的事务ID，另一个是
<code>state</code> 字段用于记录本次事务的执行状态。</p>
<p>当后续在进行<strong>Try</strong>、<strong>Confirm</strong>和<strong>Cancel</strong>操作时，都需要在本地事务中创建或修改这条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#x27;distribute_transaction&#x27; (</span><br><span class="line">	&#x27;tx_id&#x27; varchar(128) NOT NULL COMMENT &#x27;事务id&#x27;,</span><br><span class="line">	&#x27;state&#x27; int(1) DEFAULT NULL COMMENT &#x27;事务状态，0:try，1:confirm，2:cancel&#x27;,</span><br><span class="line">	PRIMARY KEY (&#x27;tx_id&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解决空回滚</strong>：当一个事务参与者接受到<strong>Cancel</strong>请求时，先去事务记录表中查询是否存在当前事务
<code>trx_id</code>
的<strong>Try</strong>操作的记录，如果记录不存在，则说明<strong>Try</strong>操作并未成功，此时可以直接跳过<strong>Cancel</strong>，避免执行空回滚。</li>
<li><strong>解决悬挂事务</strong>：当一个事务参与者接收到<strong>Try</strong>请求时，先去事务记录表中查询是否存在当前事务
<code>trx_id</code>
的<strong>Cancel</strong>操作的记录，如果存在，说明执行<strong>Try</strong>操作会导致事务悬挂，无法释放资源，拒绝本次<strong>Try</strong>请求。</li>
</ul>
<h2 id="mq事务消息">MQ事务消息</h2>
<p>RocketMQ
事务消息是一种可靠的消息传输机制，用于保证分布式事务的最终一致性。事务消息允许<strong>将消息的发送与本地事务绑定在一起</strong>，使得即使在网络异常或系统故障情况下，消息也能最终达到一致状态。</p>
<h3 id="执行流程-1">执行流程</h3>
<p>下图为MQ事务消息的总体执行流程：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411121502693.png"></p>
<p>RocketMQ 的事务消息通过 <code>TransactionListener</code>
接口实现，其执行流程总体上可以分为四个步骤：</p>
<ol type="1">
<li><strong>发送半消息</strong>：消息发送方给 <code>MQ Broker</code>
发送一条 <code>Half</code> 消息，即半消息。半消息会存储在
<code>Broker</code>
的<strong>事务消息日志</strong>中，且该半消息暂时无法被消费。</li>
<li><strong>执行本地事务</strong>：半消息发送成功后，<code>Broker</code>
会通知消息发送方执行本地事务，消息发送方可以根据本地事务的执行情况，判断是否需要提交该事务消息。</li>
<li><strong>发送提交或回滚消息</strong>：如果本地事务执行成功，发送方会通知
<code>Broker</code>
提交该事务消息，使得消息被消费者消费；如果本地事务执行失败，发送方会通知
<code>Broker</code>
回滚该事务消息，并将该半消息从<strong>事务消息日志</strong>中删除，不会被消费者消费。</li>
<li><strong>回查事务状态</strong>：如果 <code>Broker</code>
在规定时间内没有收到 <code>COMMIT</code> 和 <code>ROLLBACK</code>
消息，会向消息发送方发送一个<strong>回查请求</strong>，根据请求的回调结果判断是否需要提交或回滚事务消息。</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<blockquote>
<p><strong>半消息发送失败了，如何处理？</strong></p>
</blockquote>
<p>在 <strong>RocketMQ
事务消息</strong>的一致性解决方案中，应用程序（即消息发送方）是先发送半消息，后执行的本地事务。因此如果半消息发送失败了，直接进行消息重发即可，不会造成数据不一致的问题。</p>
<blockquote>
<p><strong>为什么需要先发送半消息？</strong></p>
</blockquote>
<p>主要原因是：<strong>本地事务执行完成后再发送消息，如果消息发送失败，那么
<code>Broker</code> 将无法感知本地事务的执行状态</strong>。</p>
<p>如果先执行完本地事务消息，再发送消息，当发送消息失败时，消费者没有半消息提供的本地事务的任何信息，因此
<code>Broker</code> 无法去回查本地事务的状态。</p>
<p>通过先发送半消息，<code>Broker</code>
可以在日志中记录该半消息，进而获知该事务的“初步状态”。如果半消息在超时内没有完成提交或回滚，<code>Broker</code>
就可以发起回查，以此来确保事务消息的最终一致性。因此，半消息为
<code>Broker</code> 提供了识别和查询特定事务状态的依据。</p>
<h2 id="本地消息表">本地消息表</h2>
<p>本地消息表（Local Message
Table）同样也是一种分布式系统中常用的可靠消息传递方案。其核心思想是在发送消息的业务系统中，在消息发送方创建一个<strong>本地消息表</strong>，用于记录每一条需要发送的消息，并通过<strong>定时任务</strong>确保消息的可靠传递。</p>
<h3 id="执行流程-2">执行流程</h3>
<p>一个典型的本地消息表结构如下：</p>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>VARCHAR(36)</td>
<td>消息ID，唯一标识</td>
</tr>
<tr class="even">
<td>content</td>
<td>TEXT</td>
<td>消息内容</td>
</tr>
<tr class="odd">
<td>status</td>
<td>INT</td>
<td>消息状态（0: 待发送，1: 已发送，2: 已完成）</td>
</tr>
<tr class="even">
<td>retry_count</td>
<td>INT</td>
<td>重试次数</td>
</tr>
<tr class="odd">
<td>create_time</td>
<td>TIMESTAMP</td>
<td>创建时间</td>
</tr>
<tr class="even">
<td>update_time</td>
<td>TIMESTAMP</td>
<td>最后更新时间</td>
</tr>
</tbody>
</table>
<p>该方案主要将<strong>分布式事务</strong>拆分成了<strong>本地事务</strong>和<strong>消息事务</strong>两个部分，具体执行流程如下：</p>
<ol type="1">
<li><strong>执行本地事务</strong>：首先由消息发送方开启本地事务，在本地事务中执行具体的业务操作。业务操作执行成功后，发送方将需要通知到其他服务的消息记录在<strong>本地消息表</strong>中，并设置消息状态为<strong>「待发送」</strong>。</li>
<li><strong>定时任务发送消息</strong>：在<strong>本地消息表</strong>中，消息初始状态为<strong>「待发送」</strong>。业务系统通过定时任务周期性地扫描本地消息表，找到所有<strong>「待发送」</strong>状态的消息，将其发送到消息队列，并将状态设置为<strong>「已发送」</strong>。定时任务的时间间隔可以根据业务需求设置。</li>
<li><strong>保证消息一致性</strong>：消息发送到消息队列后，可以通过<strong>消息重试机制</strong>，防止因网络问题导致传递的消息丢失问题；消息传递到消费者后，可以通过<strong>消费者确认机制</strong>、<strong>消息幂等处理</strong>来保证消息的一致性。</li>
<li><strong>返回消费结果</strong>：消费者消费完毕后，返回消费结果给生产者。生产者接收到消费者的消费确认后，根据消息的唯一ID，将<strong>本地消息表</strong>中对应消息的状态更新为<strong>「已完成」</strong>。</li>
</ol>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411140911116.png"></p>
<h3 id="相关问题-1">相关问题</h3>
<blockquote>
<p><strong>如果步骤1和2失败，如何处理？</strong></p>
</blockquote>
<p>当本地事务执行失败时，由于此阶段将业务操作和消息表写入放在了同一个事务中，即使步骤1和2执行失败，事务也可以通过回滚恢复数据，保证业务操作和消息表写入的一致性。</p>
<blockquote>
<p><strong>如果步骤3中的消息发送失败，如何处理？</strong></p>
</blockquote>
<p>需要在消息发送方开启一个定时任务，不断的扫描<strong>本地消息表</strong>中状态为<strong>「待发送」</strong>的消息，对于未发送成功的消息重新投递。</p>
<blockquote>
<p><strong>如果步骤4和5失败，如何处理？</strong></p>
</blockquote>
<p>依靠消费者的确认机制和重试机制，如果消息丢失或者处理失败，则重新进行投递。此外，还可以借助死信队列进行额外处理。</p>
<blockquote>
<p><strong>如果步骤6和7失败，即本地消息表更新失败，如何处理？</strong></p>
</blockquote>
<p>执行到这里时，已经可以保证消息发送方和消息接收方的业务数据保持一致了，但是本地消息表的数据还未更新。消息接收方可以设置定时任务，定期扫描<strong>本地消息表</strong>中的消息，如果消息为<strong>「已发送」</strong>而不是<strong>「已完成」</strong>，可以通过重试来再次尝试更新本地消息的状态。此外，消息发送方可以设置定时任务，主动查询消费者的业务状态，如果消息被正常消费，可以直接更新<strong>本地消息表</strong>。</p>
<h2 id="saga">Saga</h2>
<p>Saga
是一种分布式事务管理模式，主要用于解决微服务架构中跨多个服务的事务一致性问题。Saga模式通过将一个大事务分解成一系列小的局部事务，并通过<strong>补偿机制</strong>来保证最终一致性，从而避免了传统的分布式事务（如2PC或3PC）带来的性能瓶颈和复杂性。</p>
<h3 id="协调式">协调式</h3>
<p>编排式Saga是由一个<strong>中央协调者</strong>来控制整个Saga事务的执行流程。协调者负责决定每个局部事务的执行顺序，处理每个局部事务的成功或失败，并在必要时触发补偿操作。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411141038197.png" style="zoom: 80%;"></p>
<h3 id="编排式">编排式</h3>
<p>编排式<strong>没有中央协调者</strong>，而是通过<strong>事件驱动</strong>的方式来协调各个局部事务的执行。每个服务通过发布事件来通知其他服务，其他服务根据事件决定是否执行后续操作或进行补偿。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411141038297.png" style="zoom: 67%;"></p>
<h3 id="对比">对比</h3>
<p><strong>编排式Saga</strong>适用于事务流程较为清晰、需要集中控制的场景，尤其是在业务流程复杂且需要监控和调度时。它具有较强的控制能力，但可能会带来单点故障问题。</p>
<p><strong>事件驱动式Saga</strong>适用于高可扩展性、去中心化的分布式系统，适合松耦合的微服务架构。它更加灵活，但在实现上需要处理更复杂的事件和状态管理。</p>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 41%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>编排式（Orchestration）</th>
<th>事件驱动式（Choreography）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>控制方式</strong></td>
<td>中央协调者控制事务执行</td>
<td>各个服务通过事件进行事务协作</td>
</tr>
<tr class="even">
<td><strong>事务执行顺序</strong></td>
<td>顺序执行，协调者决定后续事务的执行</td>
<td>各个服务根据事件决定执行顺序</td>
</tr>
<tr class="odd">
<td><strong>补偿操作</strong></td>
<td>由协调者决定是否进行补偿操作</td>
<td>由各服务根据事件决定补偿操作</td>
</tr>
<tr class="even">
<td><strong>扩展性</strong></td>
<td>较差，协调者可能成为瓶颈</td>
<td>高，服务间解耦，易于扩展</td>
</tr>
<tr class="odd">
<td><strong>耦合度</strong></td>
<td>高，服务需要与协调者交互</td>
<td>低，服务间解耦，事件驱动</td>
</tr>
<tr class="even">
<td><strong>单点故障问题</strong></td>
<td>是，协调者故障会影响整个事务</td>
<td>否，没有单点故障问题</td>
</tr>
<tr class="odd">
<td><strong>监控与调试</strong></td>
<td>相对简单，所有操作由协调者管理</td>
<td>较为复杂，需要事件追踪和状态管理</td>
</tr>
</tbody>
</table>
<h2 id="最大努力通知">最大努力通知</h2>
<p>在最大努力通知机制中，发送方会尽最大可能确保通知送达目标，通常通过<strong>重试机制</strong>提高通知的到达率。在此过程中，若出现网络通信故障或消息队列异常，就可能导致消息传递失败，<strong>即消息可能会丢失</strong>。因此，最大努力通知机制不能完全保证接收方一定能收到每条消息，但会尽最大努力确保消息通知的完成。</p>
<p>最大努力通知常见实现：生产者重试机制、消费者重试机制、死信队列、定时任务重试</p>
<p>最大努力通知适合在以下场景中使用：</p>
<ul>
<li><strong>日志记录</strong>：日志记录的发送可以采用最大努力通知的方式，保证不影响主业务流程。</li>
<li><strong>非核心业务流程</strong>：例如积分更新、通知消息推送等，在用户体验上容错性较高的场景。</li>
</ul>
<h1 id="事务对比">事务对比</h1>
<h2 id="tcc和2pc3pc">TCC和2PC/3PC</h2>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>TCC</strong>：提供<strong>最终一致性</strong>，允许短时间内的数据不一致，通过补偿机制在失败后恢复状态。适合对响应速度要求高、允许一定延迟一致性的场景，如电商订单处理、支付等需要预留资源的业务。</li>
<li><strong>2PC</strong>：提供<strong>强一致性</strong>，确保所有参与者最终的状态保持一致，要么全部成功提交，要么全部回滚。适合对一致性要求高的场景，如金融系统、银行转账等场景，要求数据高度一致，不能有任何误差。</li>
</ul>
<p><strong>执行流程</strong>：</p>
<ul>
<li><strong>TCC</strong>：三阶段模型，主要包括<strong>Try（预留资源）</strong>、<strong>Confirm（提交）</strong>、<strong>Cancel（补偿/撤销）</strong>，在<strong>Try</strong>或<strong>Confirm</strong>阶段执行失败可以进行<strong>Cancel</strong>补偿。</li>
<li><strong>2PC</strong>：两阶段模型，主要包括<strong>Prepare（准备）</strong>和<strong>Commit（提交）</strong>，无独立的回滚机制。</li>
</ul>
<p><strong>容错和恢复机制</strong>：</p>
<ul>
<li><strong>TCC</strong>：每个阶段都有独立的失败处理，通过Cancel阶段的补偿操作可以回滚已预留的资源。</li>
<li><strong>2PC</strong>：容错能力较弱，尤其在协调者宕机的情况下易发生资源锁死，恢复依赖协调者的重启和日志记录。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li><strong>TCC</strong>：是业务层面的分布式事务，不会一直持有资源的锁，性能较好。TCC
方案允许各个参与者自定义Try、Confirm和Cancel事务逻辑，对业务侵入性较高，但具有较好的灵活性和可恢复性。</li>
<li><strong>2PC</strong>：是资源层面的分布式事务，需要数据库支持XA协议，在两阶段提交的整个过程中，会一直持有资源的锁，一般高并发性能会比较差。2PC
方案由协调者统一管理事务状态，能确保强一致性，但在分布式系统中较为耗时，且在网络中断或协调者失败时可能会出现阻塞问题。</li>
</ul>
<hr>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 36%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>特点</th>
<th>TCC</th>
<th>2PC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>事务管理</strong></td>
<td>由业务逻辑分阶段管理</td>
<td>由协调者统一管理</td>
</tr>
<tr class="even">
<td><strong>阶段划分</strong></td>
<td>Try、Confirm、Cancel</td>
<td>准备阶段、提交阶段</td>
</tr>
<tr class="odd">
<td><strong>执行方式</strong></td>
<td>预留资源+确认/取消业务执行</td>
<td>准备阶段锁定资源+正式提交/回滚</td>
</tr>
<tr class="even">
<td><strong>一致性</strong></td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
<tr class="odd">
<td><strong>资源锁定时间</strong></td>
<td>较短</td>
<td>较长，可能导致阻塞</td>
</tr>
<tr class="even">
<td><strong>容错机制</strong></td>
<td>允许自定义重试和补偿</td>
<td>协调者故障会阻塞事务</td>
</tr>
<tr class="odd">
<td><strong>性能</strong></td>
<td>较高，灵活性好</td>
<td>较低，且有单点故障风险</td>
</tr>
</tbody>
</table>
<h2 id="mq事务消息本地消息表最大努力通知">MQ事务消息&amp;本地消息表&amp;最大努力通知</h2>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>MQ事务消息</strong>：适用于金融交易、订单支付等场景，尤其适合对系统一致性和事务可靠性要求较高的场景。事务消息能确保在消息发送和本地事务之间的一致性。</li>
<li><strong>本地消息表</strong>：适用于异步处理或延迟处理，尤其是在高并发、大流量场景中，可以通过本地消息表和定时任务确保消息可靠性。</li>
<li><strong>最大努力通知</strong>：适用于容忍一定消息丢失的场景，例如日志记录、通知推送等业务，这类业务的容错性较高，不需要完全保证每条消息的送达，只要尽最大努力确保通知的到达即可。</li>
</ul>
<p><strong>执行流程</strong>：</p>
<ul>
<li><strong>MQ事务消息</strong>：消息发送方先发送半消息到
<code>Broker</code>，此时消息不可消费，但 <code>Broker</code>
会记录该消息状态。接着执行本地事务，根据执行结果，发送方通知
<code>Broker</code> 提交或回滚消息，决定消息是否可消费。如果
<code>Broker</code>
在规定时间内未收到确认，会向发送方发起回查请求，以确保消息状态和事务最终一致。</li>
<li><strong>本地消息表</strong>：发送方在本地事务中记录消息到<strong>本地消息表</strong>，确保消息与业务操作同步执行且一致。记录的消息状态为“待发送”，定时任务定期扫描表中待发送的消息，将其发送至消息队列。消息成功消费后，消费者通过确认机制通知发送方，发送方将消息状态更新为“已完成”。</li>
<li><strong>最大努力通知</strong>：发送方在消息发送过程中尽量保证消息成功传递给接收方，即使遇到网络问题也会进行多次重试。发送失败的消息会进入重试队列或死信队列，以便后续重发或进一步处理。尽管此机制不能保证百分百的消息送达，但通过多层次的重试和降级措施，努力减少消息丢失。</li>
</ul>
<p><strong>容错和恢复机制</strong>：</p>
<ul>
<li><strong>MQ事务消息</strong>：消息发送方先发送半消息到
<code>Broker</code>
并记录状态，接着执行本地事务。根据事务结果决定提交或回滚该消息；如果
<code>Broker</code>
未收到确认，将回查事务状态，确保消息最终一致性。</li>
<li><strong>本地消息表</strong>：本地事务中将消息记录到<strong>本地消息表</strong>并设为“待发送”，由定时任务扫描发送至消息队列。消息消费成功后更新状态为“已完成”，保证业务和消息的最终一致。</li>
<li><strong>最大努力通知</strong>：发送方通过多次重试确保消息尽量传递成功，遇到异常则进入重试或死信队列处理。尽管不能确保百分百送达，通过重试和降级机制尽量减少消息丢失。</li>
</ul>
<p><strong>性能与复杂度</strong>：</p>
<ul>
<li><strong>MQ事务消息</strong>：性能较低，因为每次发送消息都需要和本地事务进行绑定，并且涉及到消息提交或回滚的操作。系统复杂度较高，需要处理回查等操作。</li>
<li><strong>本地消息表</strong>：性能相对较好，通过定时任务和本地消息表机制，不需要等待事务的回查，但需要额外的定时任务和表管理，且数据库的存储压力较大。</li>
<li><strong>最大努力通知</strong>：性能最好，消息的发送与本地事务并不绑定，只需要通过重试机制和死信队列保证尽最大努力将消息送达。适用于容忍一定丢失的业务场景。</li>
</ul>
<hr>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>特点</th>
<th style="text-align: left;">MQ事务消息</th>
<th>本地消息表</th>
<th>最大努力通知</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>适用场景</strong></td>
<td style="text-align: left;">需要保证分布式事务一致性的场景</td>
<td>不要求强一致性，确保消息最终送达</td>
<td>容忍一定消息丢失的场景</td>
</tr>
<tr class="even">
<td><strong>执行流程</strong></td>
<td style="text-align: left;">发送半消息 -&gt; 执行本地事务 -&gt;
提交/回滚消息 -&gt; 回查事务状态</td>
<td>执行本地事务 -&gt; 记录消息 -&gt; 定时任务发送消息 -&gt;
消费者确认</td>
<td>尽最大努力发送消息 -&gt; 重试机制/死信队列</td>
</tr>
<tr class="odd">
<td><strong>容错机制</strong></td>
<td style="text-align: left;">通过回查机制保证最终一致性</td>
<td>通过定时任务和重试机制保证消息可靠性</td>
<td>重试机制和死信队列，无法完全保证送达</td>
</tr>
<tr class="even">
<td><strong>一致性</strong></td>
<td style="text-align: left;">强一致性，消息与事务绑定</td>
<td>最终一致性，依赖重试机制和确认机制</td>
<td>无法保证一致性，只能最大努力保证送达</td>
</tr>
<tr class="odd">
<td><strong>性能</strong></td>
<td style="text-align: left;">较低，涉及事务回查等操作</td>
<td>较高，通过定时任务和重试机制管理</td>
<td>较高，适合对性能要求高但不要求严格一致性的场景</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>TCC</tag>
        <tag>Saga</tag>
        <tag>2PC/3PC</tag>
        <tag>MQ事务消息</tag>
        <tag>本地消息表</tag>
        <tag>最大努力通知</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析</title>
    <url>/2024/11/17/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<p>策略模式是一种<strong>行为型设计模式</strong>，它定义了一系列算法，并将每一个算法封装起来，使它们可以互相替换，并且使算法的变化不会影响使用算法的客户端。策略模式通过将具体的业务逻辑从上下文（Context）中剥离出来，独立为策略类，动态地将所需的行为注入上下文对象中，从而避免代码中充斥条件判断逻辑。</p>
<p>策略模式的核心由以下三部分组成：</p>
<ul>
<li><strong>策略接口（Strategy
Interface）</strong>：定义所有具体策略类的公共接口，用于约束具体策略的实现。</li>
<li><strong>具体策略类（Concrete
Strategy）</strong>：实现策略接口，在内部封装具体的算法和业务逻辑。</li>
<li><strong>上下文类（Context）</strong>：持有一个具体策略对象的引用，用来调用具体策略类的方法。也可以使用<strong>工厂模式</strong>，将创建具体策略类的动作交给工厂类执行，实现业务逻辑、创建逻辑与应用程序的解耦合。</li>
</ul>
<p>在下面的文章中，我将给策略模式的实现分为三步，从<strong>业务逻辑解耦</strong>、<strong>创建逻辑解耦</strong>到<strong>满足开闭原则</strong>，一步步实现策略模式的<strong>最佳实践</strong>。</p>
<h1 id="策略模式业务逻辑解耦">1.策略模式（业务逻辑解耦）</h1>
<p>设计一个支付系统，支持多种支付方式，包括支付宝（Alipay）、微信支付（WeChatPay）和银行卡支付（BankCardPay）。不同支付方式的逻辑独立，同时系统可以根据需求动态切换支付方式。</p>
<h2 id="定义策略接口">定义策略接口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义支付策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>; <span class="comment">// 支付方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义具体策略类">定义具体策略类</h2>
<p>不同的具体策略类都统一继承策略接口，在类中重写策略接口定义的方法，编写具体的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支付宝支付策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用支付宝支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用微信支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡支付策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankCardStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用银行卡支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义上下文类">定义上下文类</h2>
<p>在上下文中定义策略类的引用，使用 <code>set</code>
方法注入具体策略类，通过方法调用执行具体策略类的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支付上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy strategy; <span class="comment">// 策略引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态设置支付策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentStrategy</span><span class="params">(PaymentStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行支付</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;未设置支付策略！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strategy.pay(amount); <span class="comment">// 委托给具体策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用上下文类">使用上下文类</h2>
<p>在用户选用具体的支付方式时，需要给上下文 <code>context</code>
传入具体策略的对象，才可使用该策略的支付方法。（这种方式需要应用程序自己手动
<code>new</code> 出具体策略的对象，并且通过 <code>set</code>
方法传入给上下文类）</p>
<p>虽然通过这种方式，可以使得<strong>具体的支付业务逻辑与应用程序解耦合</strong>。但是依然存在两个问题：</p>
<ol type="1">
<li>具体策略类的创建逻辑仍然由应用程序执行，<strong>即策略类创建逻辑仍然与应用程序耦合</strong>。</li>
<li>如果需要添加新的策略，就需要再添加一个新的 <code>if-else</code>
分支，<strong>因此不符合开闭原则</strong>。（开闭原则通俗点说就是在添加新的功能时，不能修改现有的代码，这里添加一个新的分支就属于修改了现有的代码）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;Alipay&quot;</span>;</span><br><span class="line">        <span class="type">PaymentContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;Alipay&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 用户使用支付宝支付</span></span><br><span class="line">            context.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">AlipayStrategy</span>());</span><br><span class="line">            context.pay(<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;Wechat&quot;</span>)) &#123;</span><br><span class="line">            context.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">WeChatPayStrategy</span>());</span><br><span class="line">            context.pay(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">BankCardStrategy</span>());</span><br><span class="line">            context.pay(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411161845157.png"></p>
<blockquote>
<p><strong>开闭原则：</strong>
软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</p>
<p><strong>对扩展开放（Open for
extension）</strong>：软件实体应该允许在不改变其现有代码的情况下，通过增加新功能来对其进行扩展。也就是说，当软件的需求发生变化时，我们应该能够通过添加新代码来满足这些需求，而不需要修改已有的代码。</p>
<p><strong>对修改关闭（Closed for
modification）</strong>：一旦软件实体被开发完成并投入使用，其源代码就不应该再被修改。这可以防止对现有功能的破坏，减少引入新的错误的风险，并使软件更加稳定和可维护。</p>
</blockquote>
<h1 id="引入工厂模式创建逻辑解耦">2.引入工厂模式（创建逻辑解耦）</h1>
<p>通过引入工厂模式，可以将创建具体策略类的动作转移给工厂类执行，将<strong>策略类的创建逻辑与应用程序解耦合</strong>。</p>
<h2 id="定义工厂类">定义工厂类</h2>
<p>由工厂类负责策略类的创建逻辑，根据传入的不同参数，创建不同的具体策略类。这一步骤也就实现了策略类的创建逻辑与应用程序的解耦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PaymentStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Alipay&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AlipayStrategy</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;WeChatPay&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeChatPayStrategy</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;BankCard&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BankCardStrategy</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的支付类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改造工厂类">改造工厂类</h2>
<p>可以发现，如果需要使用大量的具体策略类的话，应用程序就需要编写大量的
<code>if-else</code>、<code>switch</code> 分支。我们可以使用
<code>Map</code> 存储具体策略类，从而取消分支判断的设计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 定义Map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, PaymentStrategy&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;Alipay&quot;</span>, <span class="keyword">new</span> <span class="title class_">AlipayStrategy</span>());</span><br><span class="line">        map.put(<span class="string">&quot;WeChatPay&quot;</span>, <span class="keyword">new</span> <span class="title class_">WeChatPayStrategy</span>());</span><br><span class="line">        map.put(<span class="string">&quot;BankCard&quot;</span>, <span class="keyword">new</span> <span class="title class_">BankCardStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PaymentStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果存在该支付类型，返回对应的策略类</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(type)) <span class="keyword">return</span> map.get(type);</span><br><span class="line">        <span class="comment">// 如果不存在该支付类型，抛出异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的支付类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述的改造，虽然解决了创建逻辑与应用程序耦合的问题，但是<strong>不符合开闭原则的问题仍然没有解决</strong>（如果需要添加新的具体策略类，还是需要修改工厂类的代码，在
<code>Map</code> 集合中 <code>put</code> 一个新的键值对）。</p>
<p>比如，如果要添加一个苹果支付的业务逻辑，就需要在 <code>static</code>
中添加这个代码，从而打破了开闭原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;ApplePay&quot;</span>, <span class="keyword">new</span> <span class="title class_">ApplePayStrategy</span>());</span><br></pre></td></tr></table></figure>
<p>下文我们将使用 <code>Spring IoC</code> 解决这个问题。</p>
<h2 id="使用工厂类">使用工厂类</h2>
<p>直接使用 <code>PaymentStrategyFactory</code> 工厂类的静态方法
<code>getStrategy()</code> 获取策略对象，调用策略对象的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">alipay</span> <span class="operator">=</span> PaymentStrategyFactory.getStrategy(<span class="string">&quot;Alipay&quot;</span>);</span><br><span class="line">        alipay.pay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411161845157.png"></p>
<h1 id="引入spring-ioc满足开闭原则">3.引入Spring
IoC（满足开闭原则）</h1>
<h2 id="改造策略接口">改造策略接口</h2>
<p>需要在策略接口 <code>PaymentStrategy</code> 添加一个新的
<code>mark</code> 方法，用于标识每个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>; <span class="comment">// 支付方法</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">mark</span><span class="params">()</span>;	<span class="comment">// 标识方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改造具体策略类">改造具体策略类</h2>
<p>具体策略类由于实现了策略接口，因此需要重写标识方法，这里直接返回<strong>对应策略的标识</strong>即可。（这一步骤很重要，应用程序通过工厂类获取策略类，就是通过这个标识获取的）</p>
<p>此外，我们还需要给每个具体策略类添加 <code>@Component</code>
注解，方便 <code>Spring</code> 容器管理具体策略类的生命周期。</p>
<p>通过 <code>@Component</code> 注解，实际上是通过 <code>Spring</code>
容器来执行 <code>new</code>
的步骤，也就是<strong>将具体策略类的创建逻辑由工厂类交给了 Spring
容器</strong>。</p>
<blockquote>
<p><strong><span class="citation" data-cites="Component">@Component</span></strong>：可以标记任意类为
<code>Spring Bean</code>，Spring 容器会自动扫描和管理使用
<code>@Component</code> 注解标注的类。</p>
</blockquote>
<p>支付宝支付策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用支付宝支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回策略的标识</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alipay&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>微信支付策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用微信支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WeChatPay&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>银行卡支付策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankCardStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用银行卡支付了: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BankCard&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改造工厂类-1">改造工厂类</h2>
<p>下面开始重头戏，我们将对工厂类进行改造，通过 <code>Spring</code>
容器帮我们管理策略类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyFactory</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">// 注入IoC容器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义Map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, PaymentStrategy&gt; strategyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应标识的策略类</span></span><br><span class="line">    <span class="keyword">public</span> PaymentStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strategyMap.containsKey(type)) <span class="keyword">return</span> strategyMap.get(type);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的支付类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 从IoC容器中获取所有策略接口 PaymentStrategy 的实现类，即具体策略类</span></span><br><span class="line">        Map&lt;String, PaymentStrategy&gt; beansOfType = context.getBeansOfType(PaymentStrategy.class);</span><br><span class="line"></span><br><span class="line">        beansOfType.forEach((key, value) -&gt; strategyMap.put(value.mark(), value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>添加注解</strong>：首先需要给工厂类添加
<code>@Component</code>
注解，后续我们将通过依赖注入的方式使用该工厂类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>实现 <code>InitializingBean</code>
接口</strong>：通过重写该接口的 <code>afterPropertiesSet</code>
方法，可以在 <code>Bean</code> 的初始化阶段将 <code>Spring</code>
容器创建好的具体策略类写入到工厂类的 <code>strategyMap</code>
集合中。</li>
</ol>
<blockquote>
<p><strong>Spring Bean
的生命周期</strong>：整体上可以简单分为四步：实例化 —&gt; 属性赋值 —&gt;
初始化 —&gt; 销毁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategyFactory</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>注入 IoC 容器</strong>：使用 <code>@Autowired</code>
注解注入 <code>ApplicationContext</code>，即 <strong>IoC</strong>
容器。方便后续从容器中获取 Bean 名称和策略接口实现类的 <code>Map</code>
集合。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext context;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>定义 Map 集合</strong>：这个 <code>Map</code>
是工厂类存放策略类的集合，应用程序将从这个集合中获取对应的策略类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Map集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, PaymentStrategy&gt; strategyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li><strong>编写 <code>afterPropertiesSet</code>
方法逻辑</strong>：这里我们需要将 <strong>Bean
名称和策略类的键值对</strong>转化为<strong>标识和策略类的键值对</strong>，方便我们根据传入的标识直接获取策略类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 4.1.从IoC容器中获取所有策略接口 PaymentStrategy 的实现类，即具体策略类</span></span><br><span class="line">    Map&lt;String, PaymentStrategy&gt; beansOfType = context.getBeansOfType(PaymentStrategy.class);</span><br><span class="line">    <span class="comment">// 4.2.利用lambda表达式，将Spring容器中的策略类转移到工厂类的Map集合中</span></span><br><span class="line">    beansOfType.forEach((key, value) -&gt; strategyMap.put(value.mark(), value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步先从注入的 <code>Spring</code> 容器中获取容器创建好策略类的
<code>Map</code> 集合，该集合存储的是 Bean
名称和策略类的键值对，如下图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411162029364.png"></p>
<p>第二步使用了 <code>lambda</code> 表达式（如果不熟练的话使用普通
<code>for</code>
循环也行），将Spring容器中的策略类转移到工厂类的Map集合中，其实这一步也就是将
<code>key</code>
值简化，方便根据<strong>标识字符串</strong>获取策略类。如下图：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411162034333.png"></p>
<ol start="6" type="1">
<li><strong>编写 <code>getStrategy</code>
方法逻辑</strong>：最后一步，可以从 <code>strategyMap</code>
集合中获取对应的策略类了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对应标识的策略类</span></span><br><span class="line"><span class="keyword">public</span> PaymentStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strategyMap.containsKey(type)) <span class="keyword">return</span> strategyMap.get(type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效的支付类型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类到这里就彻底改造完毕了，我们通过将每个具体策略类都添加了
<code>@Component</code> 注解，<strong>在 <code>Spring</code>
启动时就会将这些使用了 <code>@Component</code> 注解的类创建出来并添加到
<code>Spring IoC</code>
容器中</strong>。这样，在添加新的策略类时就无需修改原有的工厂类，满足了开闭原则。</p>
<h2 id="使用工厂类-1">使用工厂类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrateTest</span> &#123;</span><br><span class="line">	<span class="comment">// 注入工厂类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentStrategyFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">alipay</span> <span class="operator">=</span> factory.getStrategy(<span class="string">&quot;Alipay&quot;</span>);</span><br><span class="line">        alipay.pay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411162041911.png"></p>
<h1 id="总结">总结</h1>
<h2 id="最佳实践小结">最佳实践小结</h2>
<p>通过上文的三个步骤，我们一步步将策略模式改造为了最佳实践，实现了业务逻辑、创建逻辑与应用程序的解耦以及满足了开闭原则。在<code>Spring IoC</code>
的策略模式实现中，主要做了这三件事情：</p>
<ol type="1">
<li><strong>业务逻辑与应用程序解耦</strong>：通过定义策略接口，规范不同具体策略类的统一实现，将算法的业务逻辑交给了策略类实现。</li>
<li><strong>创建逻辑与应用程序解耦</strong>：通过给策略类添加
<code>@Component</code> 注解，由 <code>Spring</code>
扫描并注册具体策略类的对象到 <code>Spring</code>
容器中，从而将策略类的创建逻辑转移到了 <code>Spring</code> 容器。</li>
<li><strong>满足开闭原则</strong>： 由于添加了 <code>@Component</code>
注解的策略类在 <code>Spring</code> 启动后都被注册到了
<code>Spring</code>
容器中，无需开发者手动硬编码到工厂类。在需要添加新的策略类时，<code>Spring</code>
容器可以帮助开发者自动注入。</li>
</ol>
<h2 id="对比其他模式">对比其他模式</h2>
<p><strong>策略模式</strong></p>
<ul>
<li><strong>定义</strong>：定义一系列算法，将每种算法封装在独立的策略类中，使得这些算法可以互相替换，且算法的变化不会影响使用算法的上下文对象。</li>
<li><strong>核心思想</strong>：<strong>动态选择算法</strong>，运行时可以替换策略对象。</li>
</ul>
<p><strong>模板方法模式</strong></p>
<ul>
<li><strong>定义</strong>：定义一个算法的框架，将算法的某些步骤延迟到子类中实现，使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</li>
<li><strong>核心思想</strong>：<strong>固定流程</strong>，子类负责填充或改写部分步骤。</li>
</ul>
<p><strong>工厂模式</strong></p>
<ul>
<li><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个具体类。工厂模式将对象的创建过程与具体类的逻辑解耦。</li>
<li><strong>核心思想</strong>：<strong>对象的创建</strong>，由工厂负责生产特定对象。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【分布式】一文详解五大分布式ID实现方案</title>
    <url>/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h1 id="分布式id">分布式ID</h1>
<p><strong>分布式 ID</strong>
是在分布式环境中生成全局唯一标识符的技术，确保在不同节点生成的 ID
不会冲突。常用于<strong>数据库主键</strong>、<strong>订单号</strong>等场景。</p>
<p>分布式 ID
是分布式系统中不可或缺的一环，其设计直接影响系统的性能和稳定性。在实际应用中，可以根据业务需求选择合适的生成方案，如高并发场景优先选择雪花算法，有序性需求可选
Redis 或号段模式。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211113892.png" style="zoom: 25%;"></p>
<p><strong>分布式 ID</strong> 需要满足下面几个特性：</p>
<ul>
<li><p><strong>全局唯一</strong>：每个ID在整个分布式系统中必须是全局唯一的，不能出现重复。</p></li>
<li><p><strong>高性能&amp;高可用</strong>：在高并发的情况下，分布式ID生成系统需要具备高可用性和低延迟，能够快速生成ID。</p></li>
<li><p><strong>有序性</strong>：ID
的有序性可以提升数据库的写入效率，以便排序或提高数据库性能。</p></li>
<li><p><strong>安全性</strong>：需要保证 ID
无法被轻易猜测，避免数据库信息被泄露。</p></li>
</ul>
<h1 id="数据库自增主键">数据库自增主键</h1>
<p><strong>数据库的自增主键</strong>（<code>AUTO_INCREMENT</code>）是数据库层面提供的一种功能，能够自动为新插入的记录生成一个递增的整数主键。利用这种特性，应用程序可以通过插入一条记录获取唯一的
ID。</p>
<h2 id="实现方法">实现方法</h2>
<p><strong>1. 创建数据库表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sequence_id` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stub` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `stub` (`stub`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code> 字段：作为主键，保证 <code>id</code>
字段全局唯一，并通过
<code>AUTO_INCREMENT</code>，自增生成唯一的<strong>分布式
ID</strong>。</li>
<li><code>stub</code>
字段：设为唯一索引（<code>UNIQUE KEY</code>），无实际业务意义，仅用于支持
<code>REPLACE INTO</code> 操作。强制插入数据时不能有重复值。</li>
</ul>
<p><strong>2. 执行事务生成并获取唯一ID</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">REPLACE <span class="keyword">INTO</span> sequence_id (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;stub&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>开启事务：利用事务的隔离性，防止其他线程获取到当前的分布式ID，破坏分布式ID的唯一性。</li>
<li><code>REPLACE INTO</code> 语义：如果 <code>stub</code>
值已经存在，则删除该行并插入新行；如果 <code>stub</code>
值不存在，则直接插入新行。通过 <code>REPLACE INTO</code>
插入元素，生成自增主键ID。</li>
<li><code>SELECT LAST_INSERT_ID()</code>
作用：返回当前会话最后一次生成的自增主键值。</li>
</ul>
<p>通过执行事务，可以获取到数据库生成的唯一ID：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211941941.png"></p>
<p>此时 <code>sequence_id</code> 表的数据如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211941301.png"></p>
<h2 id="优缺点">优缺点</h2>
<p>使用数据库自增主键生成分布式ID的方案实现简单，适合中小型系统，以下是优缺点：</p>
<blockquote>
<p><strong>优点</strong>：</p>
</blockquote>
<ul>
<li><strong>唯一性</strong>：在同一个数据库实例内是唯一的，天然保证了 ID
不会重复；在数据库集群模式下，需要额外设计步长+偏移量的方案，保证唯一性。</li>
<li><strong>有序性</strong>：在数据库存储时，自增 ID 的有序性可以减少 B+
树索引的分裂，提高写入性能；但在数据库集群模式下，不能保证分布式ID严格有序。</li>
</ul>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ul>
<li><strong>性能问题</strong>：频繁的 <code>INSERT</code>
操作会引发锁的竞争，降低数据库性能；每次获取分布式 ID
都要访问数据库，查询受到磁盘I/O的限制。</li>
<li><strong>可用性问题</strong>：存在单点故障问题，如果负责生成 ID
的数据库实例宕机，整个系统将无法生成新 ID。</li>
<li><strong>数据膨胀问题</strong>：频繁的写操作会导致数据库的二进制日志快速膨胀，影响复制和备份效率。</li>
<li><strong>信息泄露问题</strong>：自增 ID
直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li>
</ul>
<h1 id="数据库号段模式">数据库号段模式</h1>
<p><strong>号段模式</strong>是一种高效生成分布式唯一ID的方案，适用于分布式系统中需要高性能、全局唯一ID的场景。号段模式通常依赖于数据库，通过将分配到的号段缓存到内存中，直接从号段中取值生成ID，避免频繁访问数据库。</p>
<blockquote>
<p><strong>号段</strong>：将一批连续的数字ID作为一个号段，例如
<code>[1001, 2000]</code>。客户端从号段中依次分配ID，直到用完，再申请新的号段。</p>
</blockquote>
<h2 id="实现方法-1">实现方法</h2>
<p><strong>1. 创建数据库表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sequence_id_generator (</span><br><span class="line">    biz_type <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,      <span class="comment">-- 业务类型，如订单ID、用户ID等</span></span><br><span class="line">    max_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,            <span class="comment">-- 当前号段的最大值</span></span><br><span class="line">    step <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                 <span class="comment">-- 步长（每次分配的号段大小）</span></span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,              <span class="comment">-- 乐观锁版本号，防止并发问题</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (biz_type)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表中各个字段的含义如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">biz_type</td>
<td>业务类型，用于区分不同业务的ID生成规则</td>
</tr>
<tr class="even">
<td style="text-align: left;">max_id</td>
<td>当前号段的最大值，表示分配的ID范围上限</td>
</tr>
<tr class="odd">
<td style="text-align: left;">step</td>
<td>每次申请号段时的步长，为实际可用的ID数量</td>
</tr>
<tr class="even">
<td style="text-align: left;">version</td>
<td>版本号，申请新的号段时根据版本号进行并发控制</td>
</tr>
</tbody>
</table>
<p><strong>2. 初始化数据</strong></p>
<p>在使用号段模式分配ID之前，需要先在数据库中初始化数据，方便后续客户端的取用号段。</p>
<p>这里将初始的号段最大值 <code>max_id</code> 设置为 0，步长
<code>step</code> 设置为 100，版本号 <code>version</code> 设置为 0。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sequence_id_generator`(`biz_type`, `max_id`, `step`, `version`) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>3. 获取分布式ID</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `max_id`, `step`,`version` </span><br><span class="line"><span class="keyword">FROM</span> `sequence_id_generator` </span><br><span class="line"><span class="keyword">WHERE</span> `biz_type` <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure>
<p>返回结果如下：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212052736.png" style="zoom: 67%;"></p>
<p>分配的号段 <code>[max_id + 1, max_id + step]</code>
为分布式ID的可用范围。申请到号段的线程会将该号段缓存起来，直接在内存中取用号段中的数据作为分布式ID，从而避免访问数据库。（如果使用的是数据库自增主键的方案，就需要查询
<code>step</code> 次数据库，影响性能）</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212101483.png" style="zoom:25%;"></p>
<p><strong>4. 生成分布式ID</strong></p>
<p>如果某一业务类型的号段用尽时，需要从数据库中申请新的号段。在应用层执行
<code>UPDATE</code>
语句时需要使用乐观锁，防止并发情况下多个线程申请到相同的号段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sequence_id_generator </span><br><span class="line"><span class="keyword">SET</span> max_id <span class="operator">=</span> max_id <span class="operator">+</span> step, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> biz_type <span class="operator">=</span> <span class="number">101</span> <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;version&#125;;</span><br></pre></td></tr></table></figure>
<p>数据库更新结果：</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212120632.png"></p>
<h2 id="优缺点-1">优缺点</h2>
<blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<ul>
<li><strong>唯一性</strong>：依靠 <code>MySQL</code>
数据库的行级锁和应用层的乐观锁，保证相同业务类型
<code>biz_type</code>下号段分配的唯一性。</li>
<li><strong>有序性</strong>：每个号段分配的 ID
都是单调递增的，这对于某些需要有序 ID
的场景（如订单号、时间戳排序等）非常适用。</li>
<li><strong>高性能</strong>：相较于<strong>数据库自增主键</strong>的方案，ID
分配主要在内存中完成，只有在号段用尽时才访问数据库申请新的号段，大大提高了生成效率。</li>
</ul>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ul>
<li><strong>乐观锁重试问题</strong>：在高并发情况下，客户端申请号段时，乐观锁可能频繁失败，需要多次重试才能成功获取号段，增加了分配延迟。</li>
<li><strong>可用性问题</strong>：存在单点故障问题，如果负责生成号段的数据库实例宕机，整个系统将无法生成新
ID。</li>
<li><strong>信息泄露问题</strong>：自增 ID
直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li>
</ul>
<h1 id="redis的incr命令">Redis的incr命令</h1>
<p><code>Redis</code> 的 <code>INCR</code> 命令是一种简单高效的分布式 ID
生成方案。通过 <code>Redis</code>
的<strong>单线程模型</strong>来保证分布式 ID 的唯一性，而
<code>INCR</code> 命令则保证了分布式 ID 的有序性。</p>
<blockquote>
<p><strong>单线程模型</strong>：<code>Redis</code>
的单线程模型保证多个客户端执行 <code>INCR</code>
命令时，同一时刻只会有一个线程执行 <code>INCR</code>
命令，因此避免了并发安全问题。</p>
</blockquote>
<h2 id="实现方法-2">实现方法</h2>
<p><strong>1. 初始化数据</strong></p>
<p>首先设置分布式 ID 的初始结构，后续直接取用 <code>seq_id</code> 对应的
<code>value</code>值作为分布式 ID。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET seq_id 1</span><br></pre></td></tr></table></figure>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411231606213.png" style="zoom: 33%;"></p>
<p><strong>2. 生成分布式ID</strong></p>
<p>对于单机模式下的 <code>Redis</code>，由于只存在一个
<code>Redis</code> 节点，直接使用 <code>INCR</code>
命令即可保证有序性。</p>
<p>对于集群模式下的 <code>Redis</code>，由于存在多个 <code>Redis</code>
节点，因此需要给每个节点设置<strong>不同的初始偏移量</strong>，并使用
<code>INCRBY</code>
命令<strong>指定集群中所有节点数量的步长</strong>来保证全局唯一性。（也可以使用<strong>哈希插槽</strong>将生成的分布式
ID 的键固定到同一个节点，将问题转化单机模式，<code>Redis</code>
集群模式讲解<a href="https://blog.csdn.net/k123456kah/article/details/141125941?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229c435857282114ad3fa5bddcb8d72d10%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=9c435857282114ad3fa5bddcb8d72d10&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-141125941-null-null.nonecase&amp;utm_term=Redis&amp;spm=1018.2226.3001.4450">详见此处</a>）</p>
<p>比如集群中共存在3个节点A、B、C，可以指定A的初始值为0，B的初始值为1，C的初始值为2，步长设置为3。这样每个节点生成的分布式ID为
<code>初始偏移量 + 访问次数 * 步长</code>，防止不同节点生成重复的分布式ID，保证
ID 的全局唯一性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自增命令</span></span><br><span class="line">INCR seq_id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定步长自增</span></span><br><span class="line">INCRBY seq_id 3</span><br></pre></td></tr></table></figure>
<p><strong>3. 获取分布式ID</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET seq_id</span><br></pre></td></tr></table></figure>
<h2 id="优缺点-2">优缺点</h2>
<blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<ul>
<li><strong>唯一性</strong>：单机模式下依赖于 <code>Redis</code>
的单线程模型，可以保证
ID的唯一性；在集群模式，可以通过<strong>哈希插槽</strong>固定键到某个节点，或者通过<strong>步长+偏移量</strong>实现分布式
ID 的生成。</li>
<li><strong>有序性</strong>：在 <code>Redis</code>
单机模式或者在集群模式使用<strong>哈希插槽</strong>固定键到某个节点时，可以保证
ID 是严格有序的。</li>
<li><strong>高性能</strong>：<code>Redis</code>
是内存数据库，<code>INCR</code> 操作非常快，延迟一般在微秒级，单节点 QPS
可达十万级别。</li>
<li><strong>高可用</strong>：通过部署 <code>Redis</code>
分片集群，可以解决单点故障问题，保证某些节点故障后分布式 ID
生成服务依旧可用。</li>
</ul>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ul>
<li><strong>非严格有序</strong>：在分布式场景下，为了保证ID
的唯一性，通常通过<strong>步长+偏移量</strong>生成 ID，但这导致生成的 ID
不是严格有序的。</li>
<li><strong>信息泄露问题</strong>：自增 ID
直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li>
</ul>
<h1 id="uuid">UUID</h1>
<p><strong>UUID (Universally Unique Identifier)</strong>
是一种通用唯一标识符，其目的是为分布式系统中的所有元素生成唯一的标识符，在大多数情况下具有全球唯一性。UUID
的长度为 <code>128</code> 位（<code>16</code> 字节 ），通常用
<code>32</code> 个十六进制数字表示。</p>
<p>按照十六进制的数字个数划分，UUID的长度构成为
<code>8-4-4-4-12</code>，一共 32 个数字。以下为 UUID 的示例：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>
<p>UUID 的内部结构分为 5 个主要部分，每部分基于不同的位数：</p>
<ol type="1">
<li><strong>时间低位</strong>（前 8 个字符）：共 32
位，表示时间戳的地位部分。</li>
<li><strong>时间中位</strong>（占 4 个字符）：共 16
位，表示时间戳的中间部分。</li>
<li><strong>时间高位及版本号</strong>（占 4 个字符）：共 16 位，由前 4
位版本号和后 12 位的时间戳高位部分组成。</li>
<li><strong>变体及序列号</strong>（占 4 个字符）：共 16 位，前 3
位表示变体，后 13 位表示序列号。</li>
<li><strong>节点</strong>（占 12 个字符）：共 48
位，表示节点信息，通常是设备的 MAC 地址或随机数。</li>
</ol>
<p>UUID 的生成方式由其 <strong>版本号（Version）</strong> 和
<strong>变体（Variant）</strong> 决定，本文主要关注不同版本下 UUID。</p>
<h2 id="uuid版本">UUID版本</h2>
<p>UUID
的五个版本各有用途，但最常用的是<strong>版本一</strong>和<strong>版本四</strong>。<strong>版本三</strong>和<strong>版本五</strong>更适合生成基于命名空间的确定性标识符，而<strong>版本二</strong>因适用范围窄，在现代系统中已很少使用。</p>
<ul>
<li><p><strong>版本一：基于时间戳和节点地址的 UUID</strong></p>
<p>通过计算当前时间戳、时钟序列号和机器的 MAC 地址生成。</p>
<ul>
<li>由于使用了 MAC 地址，可以保证在全球范围内唯一性。</li>
<li>包含生成时间信息，时间戳可以用作生成时间的标识。</li>
<li>依赖硬件 MAC 地址，可能会暴露设备信息，存在隐私风险。</li>
</ul></li>
<li><p><strong>版本二：DCE 安全的 UUID</strong></p>
<p>类似于版本一，但是依赖于早期的 DCE
（分布式计算环境）环境，增加了一些安全特性，在现代系统中很少使用。</p></li>
<li><p><strong>版本三：基于命名空间的UUID（MD5）</strong></p>
<p>通过对名字（如字符串）和命名空间（如 URL）的组合计算 MD5 哈希值，并将
MD5 哈希值的部分位替换为版本号和变体标志生成。</p>
<ul>
<li>相同命名空间中相同名字生成的 UUID 保持一致。</li>
<li>哈希算法确定性强，适用于需要固定标识符的场景。</li>
<li>使用 MD5 算法，安全性较弱。</li>
</ul></li>
<li><p><strong>版本四：基于随机数的UUID</strong></p>
<p>UUID 的 128 位数据大部分由随机数生成。</p>
<ul>
<li>无需依赖硬件或时间信息，生成速度快。</li>
<li>碰撞概率极低，即使生成 10¹² 个 UUID，也几乎不会发生冲突。</li>
<li>不包含设备或时间信息，隐私性较好。</li>
</ul></li>
<li><p><strong>版本五：基于命名空间的UUID（SHA1）</strong></p>
<p>与版本三类似，但使用更安全的 SHA-1 哈希算法代替 MD5。</p>
<ul>
<li><p>同样的命名空间和名字生成的 UUID 一致。</p></li>
<li><p>SHA-1 比 MD5 更安全，但仍然存在一定的碰撞风险（对于 UUID
应用影响有限）。</p></li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 72%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>UUID版本</th>
<th>重复条件</th>
<th>重复概率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>版本1</strong></td>
<td>如果两个设备具有相同的 MAC
地址、相同的时钟序列，并在同一时刻生成，则可能重复。</td>
<td><strong>几乎不可能</strong></td>
</tr>
<tr class="even">
<td><strong>版本2</strong></td>
<td>如果两个设备使用相同的本地标识符（UID/GID）和相同时间戳，可能重复（需要运行在
DCE 环境）。</td>
<td><strong>几乎不可能</strong></td>
</tr>
<tr class="odd">
<td><strong>版本3</strong></td>
<td><strong>相同命名空间</strong>和<strong>相同名字</strong>才会重复；不同命名空间或名字不会重复。</td>
<td><strong>确定性重复</strong></td>
</tr>
<tr class="even">
<td><strong>版本5</strong></td>
<td><strong>相同命名空间</strong>和<strong>相同名字</strong>才会重复；不同命名空间或名字不会重复。</td>
<td><strong>确定性重复</strong></td>
</tr>
<tr class="odd">
<td><strong>版本4</strong></td>
<td>由于随机数生成碰撞（在生成量极大时，如接近 <span class="math inline">\(2^{64}\)</span> 时可能发生）。</td>
<td><strong>极低概率</strong></td>
</tr>
</tbody>
</table>
<h2 id="优缺点-3">优缺点</h2>
<blockquote>
<p><strong>优点</strong>：</p>
</blockquote>
<ul>
<li><strong>唯一性</strong>：使用不同的算法生成，<strong>几乎可以保证</strong>在全球范围内唯一，避免了多台机器之间主键冲突的问题。</li>
<li><strong>无需网络请求</strong>：UUID
生成过程完全依赖本地算法，无需访问数据库或其他第三方服务，不依赖于网络请求，降低了延迟。</li>
<li><strong>高可用</strong>：UID
生成过程完全依赖本地算法，无需依赖于第三方服务。</li>
<li><strong>不可预测</strong>：UUID
没有明确的序列信息，能够在一定程度上保护数据隐私，不易被外界推测业务数据规模或增长趋势。</li>
</ul>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ul>
<li><strong>存储开销大</strong>：UUID的长度为128位（16字节），存储时会占用较多空间，尤其是在数据库中作为主键时，会增加索引的存储成本。</li>
<li><strong>不具体有序性</strong>：UUID生成通常是随机的（如版本四），插入数据库时会导致索引频繁分裂或重排，降低写入性能。</li>
</ul>
<h1 id="雪花算法">雪花算法</h1>
<p><strong>雪花算法（Snowflake 算法）</strong>是 Twitter
开源的分布式唯一 ID 生成算法，主要用于分布式系统中生成全球唯一的、有序的
64 位长整型 ID。它能够在高并发环境下快速生成高效、唯一的
ID，并确保生成的 ID 大致有序。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411231700176.png"></p>
<ul>
<li><strong>符号位(1bit)</strong>：预留的符号位，始终为0，占用1位。</li>
<li><strong>时间戳(41bit)</strong>：记录生成 ID
时的时间戳，精确到毫秒级别，可以容纳的毫秒数是2的41次幂，可以支持大约 69
年的时间跨度。</li>
<li><strong>数据中心标识(5bit)</strong>：可以用来区分不同的数据中心。</li>
<li><strong>机器标识(5bit)</strong>：可以用来区分不同的机器。</li>
<li><strong>序列号(12bit)</strong>：表示同一毫秒内生成的 ID
的序号，单台机器每毫秒可以生成 4096 个唯一ID。</li>
</ul>
<p>默认的雪花算法是 64
bit，具体的长度可以自行配置。如果希望运行更久，增加<strong>时间戳</strong>的位数；如果需要支持更多节点部署，增加<strong>标识位</strong>的长度；如果并发很高，增加<strong>序列号</strong>的位数。</p>
<h2 id="防止时钟回拨">防止时钟回拨</h2>
<p><strong>雪花算法生成的唯一ID依赖于当前系统时间戳。</strong>如果发生<strong>时钟回拨</strong>（系统时间向后调整），导致新的时间戳与之前生成
ID 时的时间戳重复，可能会造成分布式 ID 不唯一的问题。</p>
<ol type="1">
<li><strong>等待策略</strong>：使用一个变量 <code>lastTimestamp</code>
记录上次生成 ID
的时间戳。当检测到时钟回拨时，服务可以暂时拒绝生成新的ID，等待系统时钟恢复到正常状态（至少大于或等于上次生成ID时的时间戳）。这种策略可以确保ID的严格递增性，但可能会在时钟调整期间暂停服务，对系统性能造成一定的影响。</li>
<li><strong>序列号持久化</strong>：雪花算法原本设计中序列号是在内存中自增的，为了避免时钟回拨导致的序列号重置问题，可以将序列号持久化存储到磁盘上。这样即使服务重启或时钟回拨，服务也能继续从上次持久化的序列号开始自增，从而避免ID重复。这种策略可以在一定程度上容忍时钟回拨，但可能会影响ID的绝对时间戳准确性。</li>
</ol>
<h2 id="保证标识位唯一">保证标识位唯一</h2>
<p><strong>雪花算法生成的唯一ID依赖于标识位</strong>。在集群模式下产生重复
ID，需要以下两个前提条件：</p>
<ol type="1">
<li>服务通过集群的方式部署，其中部分机器标识位一致。（比如在 K8s
中，多个 Pod 使用相同的配置镜像启动，而镜像中未动态生成唯一标识）</li>
<li>在高并发场景下，不同实例或业务在同一毫秒内生成了相同的序列号，由于机器标识位一致，导致生成的
ID 出现冲突。</li>
</ol>
<p>由此可知，<strong>只要能够保证标识位不重复，那么雪花算法生成的分布式ID也不会重复。</strong></p>
<h3 id="预分配">预分配</h3>
<p>在应用启动之前，统计当前服务的节点数量，人工去申请标识位。</p>
<p>这种方案适合服务节点数量基本不变或者服务节点数量少的情况，但是如果服务节点较多，或者经常需要扩缩容时，预分配是无法满足ID不重复的要求的。</p>
<h3 id="动态分配">动态分配</h3>
<p>将标识位存放在
Redis、Zookeeper、MySQL等中间件中，在服务启动时动态的请求标识位。</p>
<p>如果要保证分布式ID在<strong>服务内唯一</strong>，将标识位直接存放在服务所使用的
Redis
节点即可；如果要保证分布式ID的<strong>全局唯一</strong>，则多个服务需要使用同一个
Redis 节点保证唯一性。</p>
<p>数据中心标识和机器标识的组合为 <code>32 * 32</code>，即可以存储
<code>1024</code>
个服务节点，如果节点数超过了这个数量，则可以扩展标识位，或者选用其他开源的分布式ID框架。</p>
<h3 id="具体方案">具体方案</h3>
<p>下面将用 <code>Redis</code>
展示<strong>服务内唯一</strong>的标识号分配实现方案</p>
<p><strong>1. 设计键值结构</strong></p>
<p>使用 <code>Redis</code> 中的 <code>Hash</code> 结构，<code>KEY</code>
为，键值对为 <code>datacenterId</code> 、<code>workerId</code>
及其对应生成的标识号。</p>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202412221308554.png" style="zoom: 25%;"></p>
<p><strong>2.标识号自增逻辑</strong></p>
<p>通过 <code>Lua</code> 脚本从 <code>Redis</code>
中获取标识位，具体的执行逻辑为：</p>
<ol type="1">
<li><strong>检查 Hash 是否存在</strong>：如果 Redis 中不存在
<code>id_key</code> 这个 Hash，则初始化 <code>id_key</code>，并将
<code>dataCenterId</code> 和 <code>workerId</code> 设置为 0。</li>
<li><strong>判断 Hash 是否已存在</strong>：
<ul>
<li>如果 <code>id_key</code> 已存在，检查 <code>dataCenterId</code> 和
<code>workerId</code> 是否都达到最大值（31）。</li>
<li>若条件满足，则将 <code>dataCenterId</code> 和 <code>workerId</code>
都重置为 0，并返回。</li>
</ul></li>
<li><strong>分配策略</strong>：<code>dataCenterId</code> 和
<code>workerId</code> 的排列组合一共有 1024 种可能性，在分配时优先分配
<code>workerId</code>。</li>
<li><strong>分配逻辑</strong>：
<ul>
<li>检查 <code>workerId</code> 是否小于 31。若满足条件，则对
<code>workerId</code> 自增并返回。</li>
<li>如果 <code>workerId</code> 等于 31，则将 <code>dataCenterId</code>
自增，同时将 <code>workerId</code> 重置为 0，并返回。</li>
</ul></li>
</ol>
<h2 id="优缺点-4">优缺点</h2>
<blockquote>
<p><strong>优点</strong>：</p>
</blockquote>
<ul>
<li><strong>高性能高可用</strong>：生成时不依赖于数据库，完全在内存中生成，每秒钟能生成数百万的自增ID。</li>
<li><strong>ID自增</strong>：在单个进程中，生成的ID是自增的，可以用作数据库主键做范围查询。但是需要注意的是，在集群中是没办法保证顺序一定是递增的。</li>
</ul>
<blockquote>
<p><strong>缺点</strong>：</p>
</blockquote>
<ul>
<li><strong>重复ID问题</strong>：雪花算法依赖于时间戳，在获取时间的时候，如果出现时间回拨问题，服务器上的时间突然倒退到之前的时间，会造成
ID 重复的问题。</li>
<li><strong>依赖机器ID不灵活</strong>：每个节点的机器ID和数据中心ID都是硬编码在代码中的，在分布式环境如果节点出现故障或者需要扩容，更改机器ID和数据中心ID需要重新编译代码。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>雪花算法</tag>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册</title>
    <url>/2025/01/25/%E3%80%90Linux%E6%89%AB%E7%9B%B2%E3%80%91Vim%E5%91%BD%E4%BB%A4%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%9F%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%AF%B9%E4%BA%86%EF%BC%81Vim%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="概览">概览</h1>
<p>Vim
是一种高度可配置的文本编辑器，广泛用于程序开发以及其他文本编辑任务。它是
Unix 系统上 Vi 编辑器的增强版，提供了许多强大的功能。</p>
<p>在 Linux 系统上执行 <code>vim [文件名]</code> 命令，即可进入到 vim
编辑器，开始编辑指定的文件。 # 常用模式 vim 共有以下常用的五种模式： -
<strong>普通模式（normal
mode)</strong>：默认的模式，主要用于浏览文件，使用各种快捷键进行导航、复制、粘贴、删除等操作。在任意模式下按
<code>Esc</code> 键返回到普通模式。 - <strong>插入模式（Insert
mode)</strong>：用于输入和编辑文本。普通模式按下 <code>i</code>
键可进入。 - <strong>命令模式（command
mode)</strong>：用于执行命令，如保存、退出、查找。普通模式按下
<code>:</code> 键可进入。 - 可视模式（visual
mode）：用于选择文本块，进行批量操作。普通模式按 <code>v</code>
键可进入字符模式，逐字符选择；按 <code>V</code> 进入行模式，逐行选择；按
<code>Ctrl+v</code> 进入块模式，选择矩形块。 - 替换模式（replace
mode）：用于替换已有文本，输入的每个字符都会替换光标所在位置的字符。普通模式按下
<code>R</code> 键可进入。 <img src="https://i-blog.csdnimg.cn/direct/5bf5479510aa45f4828e760f0a2b5dd8.png" alt="在这里插入图片描述"></p>
<p>对于初学者，应该重点掌握普通模式、插入模式和命令模式，养成不需要输入时立即返回普通模式、多使用快捷键和经常保存文件的习惯。
## 普通模式 <strong>普通模式</strong>是默认的模式，启动 Vim
后就进入到普通模式中，主要用于浏览文件，使用各种快捷键进行导航、复制、粘贴、删除等操作。在任意模式下按
<code>Esc</code> 键返回到普通模式。 ### 移动光标 | 快捷键 | 作用 | |
------ | ------ | | 向左箭头键(←) | 光标向左移动一个字符 | |
向右箭头键(→) | 光标向右移动一个字符 | | 向上箭头键(↑) |
光标向上移动一个字符 | | 向下箭头键(↓) | 光标向下移动一个字符 | |
组合按键(数字+方向键) | 按下(30↓)，向下移动30行 | | ctrl + f |
forward，向上移动一页 | | ctrl + b | backward，向下移动一页 | | ctrl + u
| up，向上移动半页 | | ctrl + d | down，向下移动半页 | | 0 或 Home |
光标移动到本行第一个字符 | | $ 或 End | 光标移动到本行最后一个字符 | | G
| Go，移动到文本最后一行 | | 数字+G | 移动到指定行数 | | gg |
移动到文本第一行，相当于1G | | 数字+回车| 向下移动指定行数| ### 删除操作
| 快捷键 | 作用 | | ------ | ------ | | d0 |
删除从本行首个字符到光标之间的文本 | | d$ |
删除从光标到本行最后字符之间的文本 | | dG |
删除光标所在行到最后一行的所有文本 | | d+数字+G |
删除光标所在行到指定数字行的所有文本 | | dd（常用） |
删除光标所在的一整行 | | 数字+dd | 向后删除指定数量的行 | ### 复制粘贴 |
快捷键 | 作用 | | ------ | ------ | | y0 |
复制从本行首个字符到光标之间的文本 | | y$ |
复制从光标到本行最后字符之间的文本 | | yG |
复制光标所在行到最后一行的所有文本 | | y+数字+G |
复制光标所在行到指定数字行的所有文本 | | yy（常用） |
复制光标所在的一整行 | | 数字+yy | 向后复制指定数量的行 | | p |
将已复制的文本粘贴到光标下一行 | | P | 将已复制的文本粘贴到光标上一行 |
### 查询操作 | 快捷键 | 作用 | | ------ | ------ | | /word |
从光标之下搜索 "word" 字符串 | | ?word | 从光标之上搜索 "word" 字符串 |
| n | 搜索下一个匹配的字符串 | | N | 与 n 的搜索方向相反 | ### 撤销复原
| 快捷键 | 作用 | | ------ | ------ | | u（常用）| 撤销操作，相当于
Windows 中的 ctrl + z | | ctrl+r（常用） | 恢复操作，相当于 Windows 中的
ctrl + y | ## 插入模式
<strong>插入模式</strong>用于输入和编辑文本。在普通模式下按下
<code>i</code> 键可以进入插入模式。在插入模式下，Vim
的行为类似于其他文本编辑器，用户可以直接输入文本。 ### 常用快捷键 |
快捷键 | 作用 | | ------ | ------ | | ctrl+t | 增加光标所在行的整行缩进
| | ctrl+d | 减少光标所在行的整行缩进 | ## 命令模式
<strong>命令模式</strong>用于执行命令，如保存、退出、查找。在普通模式按下
<code>:</code> 键可进入插入模式。 ### 常用快捷键 | 快捷键 | 作用 | |
------ | ------ | | :w | write，保存编辑的文本 | | :w! |
如果文件为只读文件，强制保存 | | :q | quit，退出 | | :q! |
如果修改过文件，强制退出不保存 | | :wq | 保存文件并退出 | | :wq! |
如果文件为只读文件，强制保存并退出 | | :set nu | 显示每一行的行号 | |
:set nonu | 取消显示行号 | | :%d（常用） | 全文删除，删除全部文本 | |
:%s/old/new/g | 全文替换，将old替换为new | # 最佳实践 ## 界面示意
在普通模式下，输入一个32G，定位到第32行。 <img src="https://i-blog.csdnimg.cn/direct/b39d823e7e324a1eb18df6e7e25650c8.png" alt="在这里插入图片描述"></p>
<p>当前所处模式均可以在底行查看，如命令模式： <img src="https://i-blog.csdnimg.cn/direct/d44bd0ae588e4d759db09330ed253cb0.png" alt="在这里插入图片描述"></p>
<h2 id="常见场景">常见场景</h2>
<p>以下案例仅为简单场景，实际的场景往往更加复杂，在实际开发中可以利用
vim 的快捷键灵活处理。 ### 直接创建并编辑文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vim命令创建一个start.sh脚本并进入编辑，无需使用<span class="built_in">touch</span>命令创建</span></span><br><span class="line">vim start.sh</span><br></pre></td></tr></table></figure> ###
误操作，文本需要全部复原 <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 一直按u，直到全部恢复</span><br><span class="line">u</span><br></pre></td></tr></table></figure> 底行显示
<code>Already at oldest change</code>，表明已经撤销了全部的更改操作。
<img src="https://i-blog.csdnimg.cn/direct/11afc4dfce084b0e8c1ba71fa2aa2d47.png" alt="在这里插入图片描述"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 在命令模式下按:q!，强制退出不保存</span><br><span class="line">:q!</span><br></pre></td></tr></table></figure>
<h3 id="代码执行报错需要定位指定行号的代码">代码执行报错，需要定位指定行号的代码</h3>
<p>运行py脚本时，第6行报错 <img src="https://i-blog.csdnimg.cn/direct/a1835cda15834459a8aa66439445cf81.png" alt="在这里插入图片描述"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 在普通模式下使用32G，移动到第32行查看问题</span><br><span class="line">32G</span><br></pre></td></tr></table></figure>
<h3 id="查找文件中所有匹配的字符串在第几行">查找文件中所有匹配的字符串在第几行</h3>
<p>查找全文中的"word"字符串 <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 使用 : 进入命令模式，使用 :set nu 显示所有行号</span><br><span class="line">:set nu</span><br><span class="line"># 普通模式下使用 gg 或 1G 回到第一行</span><br><span class="line">gg</span><br><span class="line"># 按下 /word，并按多次 n 查找匹配的 word 及其行号</span><br><span class="line">/word</span><br><span class="line">n</span><br></pre></td></tr></table></figure> ###
删除全部文本，替换新内容进去 <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 在命令模式下执行:%d，</span><br><span class="line">:%d</span><br><span class="line"># 按下 i 进入编辑模式，使用 p 键粘贴内容</span><br><span class="line">p</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot】最佳实践——JWT结合Redis实现双Token无感刷新</title>
    <url>/2025/03/15/%E3%80%90SpringBoot%E3%80%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94JWT%E7%BB%93%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E5%8F%8CToken%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h1 id="jwt概览">JWT概览</h1>
<h2 id="jwt概念">JWT概念</h2>
<p><code>JWT</code><font style="color:rgba(0, 0, 0, 0.9);">是全称是</font><code>JSON WEB TOKEN</code><font style="color:rgba(0, 0, 0, 0.9);">，是一个开放标准，用于将各方数据信息作为JSON格式进行对象传递，可以对数据进行可选的数字加密，可使用</font><code>RSA</code><font style="color:rgba(0, 0, 0, 0.9);">或</font><code>ECDSA</code><font style="color:rgba(0, 0, 0, 0.9);">进行公钥/私钥签名。</font><code>JWT</code><font style="color:rgba(0, 0, 0, 0.9);">最常见的使用场景就是缓存当前用户登录信息，当用户登录成功之后，拿到</font><code>JWT</code><font style="color:rgba(0, 0, 0, 0.9);">，之后用户的每一个请求在请求头携带上</font><code>Authorization</code><font style="color:rgba(0, 0, 0, 0.9);">字段来辨别区分请求的用户信息。且不需要额外的资源开销。</font></p>
<h2 id="jwt组成部分">JWT组成部分</h2>
<p>JWT通常由一个头部（Header）、一个负载（Payload）和一个签名（Signature）三部分组成，这三部分之间用点（.）分隔。所以，一个完整的JWT看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure>
<p>下面我们来详细解析每一部分：</p>
<h3 id="头部header">头部(header)</h3>
<p>头部用于<strong>描述令牌的元数据</strong>，通常包含令牌的类型（即JWT）和所使用的签名算法（如HMAC
SHA256）。</p>
<ul>
<li><code>typ</code>：表示令牌的类型，JWT令牌统一写为"JWT"。</li>
<li><code>alg</code>：表示签名使用的算法，例如HMAC SHA256或RSA。</li>
</ul>
<p>头部信息会被进行Base64编码，形成JWT的第一部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="负载payload">负载(payload)</h3>
<p>负载包含了JWT的声明，<strong>即传递的数据，这些数据通常包括用户信息和其他相关数据</strong>。声明有三种类型：注册的声明、公共的声明和私有的声明。</p>
<ul>
<li><strong>注册的声明</strong>：这是一组预定义的声明，它们不是强制的，但是推荐使用，以提供一组有用的、可互操作的声明。如：<code>iat</code>（签发时间）、<code>exp</code>（过期时间）、<code>aud</code>（接收方）、<code>sub</code>（用户唯一标识）、<code>jti</code>（JWT唯一标识）等。</li>
<li><strong>公共的声明</strong>：可以定义任何名称，但应避免与注册的声明名称冲突。</li>
<li><strong>私有的声明</strong>：是提供者和消费者之间共同定义的声明。</li>
</ul>
<p>负载同样会被Base64编码，形成JWT的第二部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unique-jwt-id&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="签名signature">签名(signature)</h3>
<p>签名将头部和负载用指定的算法进行签名，<strong>验证JWT的真实性和完整性</strong>。当接收者收到JWT时，他们可以使用相同的算法和密钥（对于HMAC算法）或使用公钥（对于RSA或ECDSA算法）验证签名。如果两个签名匹配，那么JWT就是有效的。</p>
<p>签名的过程如下：</p>
<ul>
<li>先将Base64编码后的头部和负载数据用点号（<code>.</code>）连接起来。</li>
<li>使用指定的签名算法（例如，HMAC
SHA256、RSA、ECDSA）和密钥对连接后的字符串进行签名。</li>
<li>将生成的签名部分进行Base64Url编码，形成JWT的第三部分。</li>
</ul>
<p>签名部分也是经过Base64Url编码的，形成JWT的第三部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">    base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">    secret)</span><br></pre></td></tr></table></figure>
<p>注意：虽然Base64Url编码不是加密方式，但它可以确保JWT的字符串格式是紧凑的，并且容易在URL、POST参数或HTTP头部中传输。</p>
<h1 id="技术方案设计">技术方案设计</h1>
<h2 id="单点登录sso">单点登录(SSO)</h2>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">单点登录（Single
Sign-On,
SSO）</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">
是一种身份认证机制，允许用户通过</font><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">一次登录</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">即可访问多个相互信任的应用系统，而无需重复输入认证信息。</font></li>
</ul>
<h2 id="双token机制"><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">双Token机制</font></h2>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">AccessToken</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">短期有效（如30分钟），用于接口访问。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">客户端每次请求API时携带。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不持久化存储，仅通过签名验证合法性。</font></li>
</ul></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">RefreshToken</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">用于获取新的Access
Token，有效期长（如3天）。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">仅在刷新令牌时传输，不直接访问业务API。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">必须持久化存储（如Redis）</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，服务端可主动使其失效。</font></li>
</ul></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">签名算法</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：使用RSA非对称加密算法，减少内存占用，防止篡改，并方便后续拓展子系统。</font></li>
</ul>
<h2 id="无感刷新token">无感刷新Token</h2>
<ul>
<li>客户端将由于AccesssToken过期失败的请求存储起来，携带RefreshToken成功刷新Token后，将存储的失败请求重新发起，以此达到用户无感的体验。</li>
<li>服务端根据RefreshToken解析出userId和deviceId后，去Redis中查询存储的RefreshToken并进行比对，成功后生成新的AT和RT并返回</li>
</ul>
<h2 id="多端会话管理">多端会话管理</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">同一账号在不同设备登录时，为每个设备生成独立的RefreshToken。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Redis中以
</font><code>userId:deviceId</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">为键存储RefreshToken，过期时间设置为RefreshToken的过期时间。</font></li>
</ul>
<h2 id="废弃令牌移除">废弃令牌移除</h2>
<ul>
<li>Redis中以<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">
</font><code>blacklist:token</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">
为键存储</font>AccessToken黑名单，键值对的过期时间设置为AccessToken的剩余有效期。</li>
<li>直接删除Redis中的<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">RefreshToken。</font></li>
</ul>
<h1 id="最佳实践">最佳实践</h1>
<h2 id="总体流程">总体流程</h2>
<p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202503151628723.png"></p>
<h2 id="jwt工具类">JWT工具类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JWT工具类</span></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.access.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> accessExpiration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.refresh.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> refreshExpiration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">        .setSubject(username)</span><br><span class="line">        .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + accessExpiration))</span><br><span class="line">        .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">        .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateRefreshToken</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">        .setSubject(username)</span><br><span class="line">        .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + refreshExpiration))</span><br><span class="line">        .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">        .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsernameFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getSubject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redis服务类">Redis服务类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redis服务类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisService</span><span class="params">(StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveRefreshToken</span><span class="params">(String refreshToken, String username)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;refresh_token:&quot;</span> + refreshToken, username, <span class="number">7</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRefreshTokenValid</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(<span class="string">&quot;refresh_token:&quot;</span> + refreshToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteRefreshToken</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;refresh_token:&quot;</span> + refreshToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToBlacklist</span><span class="params">(String accessToken, <span class="type">long</span> expirationMs)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;blacklist:&quot;</span> + accessToken, <span class="string">&quot;invalid&quot;</span>, expirationMs, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInBlacklist</span><span class="params">(String accessToken)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(redisTemplate.hasKey(<span class="string">&quot;blacklist:&quot;</span> + accessToken));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filter过滤器">Filter过滤器</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JWT过滤器</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtFilter</span><span class="params">(JwtUtil jwtUtil, RedisService redisService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">        <span class="built_in">this</span>.redisService = redisService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> </span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> resolveToken(request);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redisService.isInBlacklist(token)) &#123;</span><br><span class="line">            sendError(response, <span class="string">&quot;Token invalid&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jwtUtil.validateToken(token)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtUtil.getUsernameFromToken(token);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendError(response, <span class="string">&quot;Token expired or invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">resolveToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bearerToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bearerToken != <span class="literal">null</span> &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(HttpServletResponse response, String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        response.getWriter().write(message);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller类">Controller类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制器类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthController</span><span class="params">(JwtUtil jwtUtil, RedisService redisService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">        <span class="built_in">this</span>.redisService = redisService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">        <span class="comment">// 这里应添加用户认证逻辑（如数据库验证）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getUsername();</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> jwtUtil.generateAccessToken(username);</span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> jwtUtil.generateRefreshToken(username);</span><br><span class="line">        </span><br><span class="line">        redisService.saveRefreshToken(refreshToken, username);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> <span class="title class_">TokenResponse</span>(accessToken, refreshToken));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/refresh&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; refreshToken(<span class="meta">@RequestBody</span> RefreshRequest request) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> request.getRefreshToken();</span><br><span class="line">        <span class="keyword">if</span> (!redisService.isRefreshTokenValid(refreshToken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(<span class="number">401</span>).body(<span class="string">&quot;Invalid refresh token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtUtil.getUsernameFromToken(refreshToken);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newAccessToken</span> <span class="operator">=</span> jwtUtil.generateAccessToken(username);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newRefreshToken</span> <span class="operator">=</span> jwtUtil.generateRefreshToken(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换旧refreshToken</span></span><br><span class="line">        redisService.deleteRefreshToken(refreshToken);</span><br><span class="line">        redisService.saveRefreshToken(newRefreshToken, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将旧accessToken加入黑名单（可选）</span></span><br><span class="line">        <span class="comment">// long expiration = jwtUtil.getExpirationFromToken(refreshToken).getTime() - System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">// redisService.addToBlacklist(refreshToken, expiration);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> <span class="title class_">TokenResponse</span>(newAccessToken, newRefreshToken));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DTO类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="comment">// getters/setters</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RefreshRequest</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String refreshToken;</span><br><span class="line">        <span class="comment">// getters/setters</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TokenResponse</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String accessToken;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String refreshToken;</span><br><span class="line">        <span class="comment">// constructor/getters</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题解析">问题解析</h1>
<h2 id="相比单token的优势">相比单Token的优势</h2>
<ul>
<li><strong>高安全性</strong>：用户请求仅携带过期时间较短的AccessToken，即使令牌泄露，风险时间窗口也较小；用户仅在请求刷新Token时携带RefreshToken</li>
<li><strong>长会话</strong>：RefreshToken一般设置较长的过期时间，只要RT不过期用户就无需重复登录</li>
</ul>
<h2 id="引入redis的作用">引入Redis的作用</h2>
<ul>
<li><strong>方便状态管理</strong>：如果不存在Redis，用户登出后只能等待Token过期才能被动失效，增加Token暴露风险；通过在Redis中引入黑名单blacklist，可以使得Token主动失效</li>
<li><strong>多端会话管理</strong>：通过<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">以
</font><code>userId:deviceId</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">为键存储不同设备的Token，实现同用户多端登录。通过删除对应设备的键并加上黑名单，可以主动剔出对应设备</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分布式一致性</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：若使用本地内存存储
RT，在分布式多节点架构中，各节点无法共享 RT
状态，导致用户在一个节点退出后，其他节点仍认为 RT
有效。Redis作为</font><strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">集中式存储</font></strong><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，确保所有服务节点访问同一份
RT 数据，状态一致。</font></li>
</ul>
<h2 id="保证token安全性">保证Token安全性</h2>
<ul>
<li><strong>存储安全性</strong>：AT存于内存或
SessionStorage（页面关闭失效），而RT通过 HttpOnly; Secure;
SameSite=Strict Cookie 存储（XSS攻击无效）。</li>
<li><strong>传输安全性</strong>：开启HTTPS，防止中间人攻击（篡改、伪造和窃听）；AT<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通过
</font><code>Authorization: Bearer &#123;token&#125;</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">
请求头传递，避免 URL 参数（防日志泄露），而RT通过
</font><code>Cookie</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（标记
</font><code>HttpOnly; Secure</code><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）传输。</font></li>
</ul>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
</search>
