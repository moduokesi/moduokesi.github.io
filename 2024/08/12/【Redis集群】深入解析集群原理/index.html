<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" href="/images/logo.png"><title>【Redis集群】集群原理最全解析 | Modox&#39;s blog</title><meta name="author" content="Modox"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="format-detection" content="telphone=no, email=no"><meta name="keywords" content="主从集群, 分片集群, 哨兵机制"><meta name="description" content="主从集群 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。  数据同步概念 Replication Id和offset 在从节点发起数据同步的请求中，有两个重要的属性：  Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承ma"><meta property="og:type" content="article"><meta property="og:title" content="【Redis集群】集群原理最全解析"><meta property="og:url" content="https://moduokesi.top/2024/08/12/%E3%80%90Redis%E9%9B%86%E7%BE%A4%E3%80%91%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Modox&#39;s blog"><meta property="og:description" content="主从集群 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。  数据同步概念 Replication Id和offset 在从节点发起数据同步的请求中，有两个重要的属性：  Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承ma"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moduokesi.top/images/logo.png"><meta property="article:published_time" content="2024-08-12T03:00:01.000Z"><meta property="article:modified_time" content="2024-08-14T06:48:38.617Z"><meta property="article:author" content="Modox"><meta property="article:tag" content="主从集群"><meta property="article:tag" content="哨兵机制"><meta property="article:tag" content="分片集群"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://moduokesi.top/images/logo.png"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"><link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme:dark)"><script src="/js/kr-dark.min.js"></script><link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"><link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"><link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"><link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script><script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script><style>.kratos-cover.kratos-cover-2{background-image:url(/images/banner.webp)}@media(min-width:768px){body.custom-background{background-image:url(/images/bg.webp)}}</style><meta name="generator" content="Hexo 6.2.0"></head><body class="custom-background"><div id="kratos-wrapper"><div id="kratos-page"><div id="kratos-header"><header id="kratos-desktop-topnav" class="kratos-topnav"><div class="container"><div class="nav-header"><nav id="kratos-menu-wrap"><ul id="kratos-primary-menu" class="sf-menu"><li><a href="/"><i class="fa fa-home"></i> 首页</a></li><li><a href="/archives/"><i class="fa fa-file"></i> 档案馆</a></li><li><a><i class="fa fa-paw"></i> 友站</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://penty7710.github.io/">pety's blog</a></li></ul></li><li><a><i class="fa fa-link"></i> 链接</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah?type=blog">CSDN</a></li><li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/community/usersnew/id_1670078149364456">华为云</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/moduokesi_admin">Gitee</a></li><li><a target="_blank" rel="noopener" href="https://github.com/moduokesi">GitHub</a></li></ul></li></ul></nav></div></div></header><header id="kratos-mobile-topnav" class="kratos-topnav"><div class="container"><div class="color-logo"><a href="/">Modox&#39;s blog</a></div><div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div></div></header></div><div class="kratos-start kratos-hero-2"><div class="kratos-cover kratos-cover-2 text-center"><div class="desc desc2 animate-box"><a href="/"><h2>Modox&#39;s blog</h2><br><span></span></a></div></div></div><div id="kratos-blog-post"><div class="container"><div id="main" class="row"><section class="col-md-8"><article itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://moduokesi.top/2024/08/12/%E3%80%90Redis%E9%9B%86%E7%BE%A4%E3%80%91%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/"><div class="kratos-hentry kratos-post-inner clearfix"><header class="kratos-entry-header"><h1 class="kratos-entry-title text-center" itemprop="name headline">【Redis集群】集群原理最全解析</h1><ul class="kratos-post-meta text-center"><li><time datetime="2024-08-12T03:00:01.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-08-12</time></li><li itemprop="author" itemscope itemtype="https://schema.org/Person"><i class="fa fa-user"></i> 作者 <span itemprop="name">Modox</span></li><li><i class="fa fa-edit"></i> ~8.75K 字</li></ul></header><div class="kratos-post-content"><div id="expire-alert" class="alert alert-warning hidden" role="alert"><div class="icon"><i class="fa fa-warning"></i></div><div class="text"><p>本文最后编辑于 <time datetime="1723618118617"></time> 前，其中的内容可能需要更新。</p></div></div><div class="kratos-post-inner-toc toc-div-class"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">1.</span> <span class="toc-text">主从集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">数据同步概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replication-id%E5%92%8Coffset"><span class="toc-number">1.1.1.</span> <span class="toc-text">Replication Id和offset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repl_baklog%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">repl_baklog缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.</span> <span class="toc-text">第一次数据同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.</span> <span class="toc-text">增量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.</span> <span class="toc-text">优化策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">哨兵机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-number">2.1.</span> <span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">2.2.</span> <span class="toc-text">自动故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0master%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">选举新master节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">进行故障转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.3.</span> <span class="toc-text">通知Redis客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.</span> <span class="toc-text">分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">重要概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">散列插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%AA%E5%85%83"><span class="toc-number">3.1.2.</span> <span class="toc-text">配置纪元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-1"><span class="toc-number">3.2.</span> <span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">3.3.</span> <span class="toc-text">故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.1.</span> <span class="toc-text">选举新的master节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">进行故障转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5redis%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">3.4.</span> <span class="toc-text">通知Redis客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="toc-number">3.5.</span> <span class="toc-text">集群伸缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">集群扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="toc-number">3.5.2.</span> <span class="toc-text">集群缩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.6.</span> <span class="toc-text">手动故障转移</span></a></li></ol></li></ol></div><hr><div itemprop="articleBody"><h2 id="主从集群">主从集群</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7734b070a0abf4ca05aea435d026df9a.png"></p><h3 id="数据同步概念">数据同步概念</h3><h4 id="replication-id和offset">Replication Id和offset</h4><p>在从节点发起数据同步的请求中，有两个重要的属性：</p><ul><li><code>Replication Id</code>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid。</li><li><code>offset</code>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p><strong>因此slave做数据同步，必须向master声明自己的replication id和offset，master才可以判断到底需要同步哪些数据。</strong> 当从节点发起主从同步请求时，主节点会判断从节点的replid是否一致，如果不一致，说明是第一次请求数据同步。</p><h4 id="repl_baklog缓冲区">repl_baklog缓冲区</h4><p><code>repl_baklog</code>缓冲区是主从同步的重要机制，主节点在生成RDB文件期间会将命令记录到这个<strong>环形缓冲区</strong>中。</p><p>该缓冲区用于<strong>增量同步</strong>，确保从节点的偏移量与主节点保持一致。然而，如果从节点宕机且重启时缓冲区的数据已被覆盖，从节点就无法通过缓冲区恢复全部数据，导致数据不一致。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6d8fcd0ed32eda58948be44ea1fd27fb.png"></p><h3 id="第一次数据同步">第一次数据同步</h3><ol type="1"><li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li><li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点。由于生成RDB文件的过程是异步的，主节点同时会持续记录在生成RDB文件期间产生的所有命令。</li><li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。加载完成后，从节点获取缓存区的命令，执行命令同步数据。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/a1849c13d12ab6d2255cf864a1fb3862.png"></p><h3 id="全量同步">全量同步</h3><p><strong>全量同步</strong>：是指主节点生成RDB文件并发送给从节点，从节点清空本地数据并加载RDB文件的过程。它通常发生在从节点首次连接到主节点或数据不一致的情况下。</p><p>全量同步的发生场景有两种：</p><ol type="1"><li><strong>从节点首次连接主节点：</strong> 当一个新的从节点第一次连接到主节点时，它没有任何数据副本。因此，需要进行全量同步来获取主节点的完整数据集。<strong>全量同步过程：</strong><ol type="1"><li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li><li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点</li><li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。</li></ol></li><li><strong>主节点缓冲区超出容量：</strong> 主节点的<code>repl_baklog</code>缓冲区大小有上限，写满后会覆盖最早的数据。如果从节点断开时间过久，导致尚未备份的数据被覆盖，则主节点不能基于缓冲区做数据同步，只能再次使用全量同步获取RDB的完整数据集。</li></ol><p><strong>全量同步过程：</strong></p><ol type="1"><li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li><li>主节点需要判断<code>replid</code>是否与自己一致，如果不一致，说明从节点是第一次申请数据同步，主节点需要生成RDB文件并将RDB文件发送给从节点</li><li>从节点获取RDB文件后，清空本地数据并加载RDB文件进行数据同步。</li></ol><h3 id="增量同步">增量同步</h3><p><strong>增量同步</strong>：是指主节点在RDB文件生成期间记录的所有命令（写操作）被存储在<code>replication backlog</code>缓冲区中，并在全量同步完成后发送给从节点，从节点执行这些命令的过程。增量同步用于保持主从节点之间的数据一致性。</p><p>增量同步的发生场景有两种：</p><ol type="1"><li><p><strong>全量同步后的持续增量同步：</strong> 在从节点完成初次的全量同步之后，主节点和从节点之间需要保持数据一致性。从节点会不断接收主节点的增量数据以更新其自身的数据状态。</p></li><li><p><strong>从节点宕机重启后的增量同步：</strong> 当从节点因为故障、宕机或其他原因暂时失联，然后重新启动并重新连接到主节点时，主节点会尝试通过增量同步来恢复数据同步的状态。</p></li></ol><p><strong>增量同步过程：</strong></p><ol type="1"><li>从节点发起数据同步请求，请求中携带<code>replid</code>和<code>offset</code>两个属性。</li><li>主节点需要判断<code>replid</code>是否与自己一致，如果一致，说明从节点不是第一次申请数据同步了（即从节点之前进行了全量同步），主节点返回continue，允许从节点获取<code>repl_baklog</code>缓冲区的命令</li><li>从节点持续获取缓存区的命令，执行命令同步数据。</li></ol><h3 id="优化策略">优化策略</h3><p>可以从以下几个方面来优化Redis主从集群：</p><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘I/O</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘I/O</li><li>适当提高<code>repl_baklog</code>缓存区的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><h2 id="哨兵机制">哨兵机制</h2><p>在主从集群中，slave节点即使宕机，也可以从master节点上恢复数据。然而，如果master节点宕机，即使master节点做了持久化处理，在其重启后虽然能够恢复部分数据，但在重启和故障恢复的过程中，<strong>仍然可能会丢失大量数据</strong>，这对系统来说是不可接受的。</p><p>因此，为了解决上述问题，在主从集群的基础上引入了哨兵机制。<strong>哨兵机制的核心作用是监控主从集群中的各个节点，并在检测到master节点宕机时，自动从slave节点中选举一个新的master节点。</strong></p><p><strong>哨兵（Sentinel）机制的作用：</strong></p><ul><li><strong>服务状态监控：</strong> Sentinel会不断检查集群中的master和slave节点是否按预期工作</li><li><strong>自动故障恢复：</strong> 如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知Redis客户端：</strong> Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/8051a5eb45d945414477798804c9d068.png"></p><h3 id="服务状态监控">服务状态监控</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><strong>主观下线：</strong> 如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li><li><strong>客观下线：</strong> 若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。</li></ul><h3 id="自动故障恢复">自动故障恢复</h3><h4 id="选举新master节点">选举新master节点</h4><p>当sentinel检测到master节点客观下线时，需要在集群中选择一个slave节点作为新的master，选择依据是这样的：</p><ul><li><strong>节点断开时间长短</strong>：首先会判断slave节点与master节点断开时间长短，如果超过指定值<code>down-after-milliseconds * 10</code>则会排除该slave节点</li><li><strong>优先级判断</strong>：slave从节点有<code>slave-priority</code>参数，越小优先级越高，如果是0则永不参与选举</li><li><strong>数据同步状态</strong>：如果从节点优先级一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li><strong>节点 ID 大小</strong>：最后是判断slave节点的运行id大小，越小优先级越高，</li></ul><h4 id="进行故障转移">进行故障转移</h4><p>当节点2（master节点）故障后，sentinel选举节点1为新的master节点，故障转移步骤如下:</p><ul><li>sentinel给备选的节点1发送slaveof no one命令，让节点1成为master</li><li>sentinel给其它所有的slave节点发送slaveof 192.168.150.101 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当节点2恢复后会自动成为新的master的slave节点</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/412dea73ace8d948e1a84f01c3febdfe.png"></p><h3 id="通知redis客户端">通知Redis客户端</h3><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化及时更新连接信息。Spring的RedisTemplate底层利用<code>lettuce</code>实现了节点的感知和自动切换。</p><ol type="1"><li>在pom文件中引入redis的starter依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>然后在配置文件application.yml中指定sentinel相关信息</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment">#指定master名称</span></span><br><span class="line">   <span class="attr">nodes:</span> <span class="comment">#指定redis-sentinel集群信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>配置读写分离</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configBuilder -&gt; configBuilder.readFrom(ReadFroM.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ReadFrom是配置Redis的读取策略，是一个枚举，包括下面选择:</p><ul><li><strong>MASTER：</strong> 从主节点读取</li><li><strong>MASTER_PREFERRED：</strong> 优先从master节点读取，master不可用才读取replica</li><li><strong>REPLICA：</strong> 从slave(replica)节点读取</li><li><strong>REPLICA_PREFERRED：</strong> 优先从slave(replica)节点读取，所有的slave都不可用才读取master</li></ul><h2 id="分片集群">分片集群</h2><p>主从复制和哨兵机制虽然解决了Redis的高可用性和高并发读的问题，但仍然面临以下两个挑战：</p><ol type="1"><li><strong>海量数据存储的问题</strong>：单个Redis实例的内存和存储容量有限，无法处理海量数据。</li><li><strong>高并发写入的问题</strong>：单个主节点在高并发写入的场景下容易成为性能瓶颈。</li></ol><p>Redis中的分片集群（Sharded Cluster）是一种将数据分布在多个Redis节点上的方式。通过将数据水平分片，分片集群能够在数据量增加时提升集群的存储容量，同时将写入压力分散到多个master节点上，提升整体性能。</p><p><strong>Redis 分片集群的核心作用：</strong></p><ul><li><strong>数据水平扩展：</strong> 通过将数据分片存储在多个节点上，Redis 集群能够扩展到多个实例，以应对大规模数据存储和高并发请求。</li><li><strong>负载均衡：</strong> 将请求均匀分布到不同的分片节点上，避免单点压力过大，确保系统性能的稳定性。</li><li><strong>高可用性：</strong> 通过主从复制和自动故障恢复机制，Redis 集群能够在某个节点发生故障时，继续提供服务，确保系统的高可用性。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9dceb428c1f7304d335bca94e42c4fb1.png"></p><h3 id="重要概念">重要概念</h3><h4 id="散列插槽">散列插槽</h4><p>Redis 集群通过<strong>哈希槽</strong>（Hash Slot）机制来分配数据到不同的分片节点上。整个哈希空间分为 16384 个槽，每个键根据其哈希值被分配到一个特定的槽中，而槽则由集群中的各个matser节点持有。</p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>如果key中包含<code>&#123;&#125;</code>，且<code>&#123;&#125;</code>中至少包含1个字符，<code>&#123;&#125;</code>中的部分是有效部分</li><li>如果key中不包含<code>&#123;&#125;</code>，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{modox}num，则根据modox计算。计算方式是利用<code>CRC16</code>算法得到一个hash值，然后对16384取余，得到的结果就是插槽的slot值。</p><blockquote><p><strong>Redis客户端如何进行数据访问？</strong> 根据键的哈希值确定数据所在的分片节点，然后直接与该节点通信。</p><p><strong>如何将同一类数据保存在同一个Redis节点上？</strong> 只需设置一个统一的有效部分，如{shopId}</p></blockquote><h4 id="配置纪元">配置纪元</h4><p>配置纪元的作用是标识和跟踪集群配置的版本，<strong>确保集群中的所有节点在主节点故障转移和配置变更时保持一致</strong>。</p><p><strong>1.配置纪元是只增不减的整数</strong>：</p><ul><li>每个主节点都有一个自身维护的配置纪元 (<code>clusterNode.configEpoch</code>)，表示该主节点的版本。这个配置纪元是集群变更时用于标识和协调的关键因素。</li><li>每个主节点的配置纪元都不同，以确保集群内的节点可以正确识别和处理最新的配置变更。</li></ul><p><strong>2.从节点会复制主节点的配置纪元</strong>：</p><ul><li>当从节点与其对应的主节点同步时，它会复制该主节点的配置纪元。这样在主节点发生故障时，从节点可以使用这个配置纪元参与选举并成为新的主节点。</li></ul><p><strong>3.全局配置纪元</strong>：</p><ul><li>整个集群维护一个全局的配置纪元 (<code>clusterState.currentEpoch</code>)，记录集群内所有主节点的配置纪元中的最大版本号。这个全局纪元会在集群发生关键事件（如故障转移、添加/删除节点）时增加，以确保集群状态的一致性。</li></ul><p><strong>4.选举时选择纪元数最大的从节点</strong>：</p><ul><li>在故障转移过程中，集群会优先选择配置纪元最大的从节点作为新的主节点。因为这个从节点的数据更可能是最新的，并且它在选举中更有可能获得其他主节点的支持。</li></ul><h3 id="服务状态监控-1">服务状态监控</h3><p>Redis分片集群的各个节点通过<code>ping/pong</code>进行消息通信，转播槽的信息和节点状态信息，故障发现也是通过这个动作实现的，类似于<code>sentinel</code>，有主观下线和客观下线。</p><ul><li><strong>主观下线（PFAIL）：</strong> 集群中的每个节点都会定期通过 PING-PONG 消息与其他节点通信。如果一个节点在指定时间内没有响应其他节点的 PING 请求，该节点会被标记为主观下线。</li><li><strong>客观下线（FAIL）：</strong> 如果多个节点都将同一个节点标记为 PFAIL，那么通过投票机制，该节点将被标记为客观下线（FAIL）。这个状态会在集群中广播，所有节点都认同该节点已不可用。</li></ul><h3 id="故障恢复">故障恢复</h3><h4 id="选举新的master节点">选举新的master节点</h4><p>Redis 分片集群和 Sentinel 机制在选举新的 master 节点时规则基本相同，唯一的区别在于节点断开时间的处理方式不同。</p><ul><li><strong>节点断开时间长短</strong>：每个从节点检查与故障主节点的断线时间，断开时间超过<code>cluster-node-timeout * cluster-slave-validity-factor</code>则取消资格。cluster-slave-validity-factor : 默认是10</li><li><strong>优先级判断</strong>：slave从节点有<code>slave-priority</code>参数，越小优先级越高，如果是0则永不参与选举</li><li><strong>数据同步状态</strong>：如果从节点优先级一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li><strong>配置纪元：</strong> 在故障转移过程中，集群会优先选择配置纪元最大的从节点作为新的主节点。因为配置纪元越大的从节点，数据更可能是新的。</li></ul><h4 id="进行故障转移-1">进行故障转移</h4><p>当新的 master 节点选举完成后，Redis 集群会自动进行故障转移，具体包括以下步骤：</p><ol type="1"><li><strong>提升新的 master 节点</strong>：Redis 集群通过内部命令 <code>SLAVEOF NO ONE</code> 将选中的从节点提升为新的 master 节点。</li><li><strong>更新哈希槽映射</strong>：Redis 集群会自动更新哈希槽与节点的映射关系，新的 master 节点将执行 <code>CLUSTER DELSLOTS</code> 操作撤销故障主节点负责的槽，并执行 <code>CLUSTER ADDSLOTS</code> 把这些槽委派给自己。</li><li><strong>重新配置和广播</strong>：Redis 集群将剩余的从节点重新配置为新 master 节点的从节点，并广播新的 master 信息给所有节点，确保集群内所有节点都更新哈希槽映射，并将新 master 的信息同步到其他节点。</li><li><strong>节点重连</strong>：如果故障的 master 节点恢复上线，它通常会被重新配置为新的 master 的从节点，并同步数据以确保与新 master 保持数据一致性。</li></ol><h3 id="通知redis客户端-1">通知Redis客户端</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致。</p><ol type="1"><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li></ol><p>与哨兵模式相比，只有yaml配置文件的配置方式存在差异，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">   <span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure><h3 id="集群伸缩">集群伸缩</h3><p>Redis 集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容，对节点进行灵活上下线控制，原理可抽象为<strong>槽和对应数据在不同节点之间灵活移动。</strong></p><h4 id="集群扩容">集群扩容</h4><p><strong>1.添加节点：</strong></p><p>Redis分片集群提供了为现有集群添加新节点的，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node new_host:new_port existing_host:existing_port</span><br><span class="line">--cluster-slave</span><br><span class="line">--cluster-master-id &lt;arg&gt;</span><br></pre></td></tr></table></figure><p>如果需要直接指定新节点为某一master的从节点，可使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node &lt;新节点IP&gt;:&lt;端口&gt; &lt;现有节点IP&gt;:&lt;端口&gt; --cluster-slave --cluster-master-id &lt;主节点ID&gt;</span><br></pre></td></tr></table></figure><p><strong>2.迁移插槽：</strong></p><p>可通过<code>reshard</code>命令将当前节点的散列插槽分配给其他节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;当前节点IP&gt;:&lt;端口&gt;</span><br></pre></td></tr></table></figure><p>接着Redis会提示需要移动多少插槽，自行输入即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">How many slots do you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure><p>然后需要输入接收插槽的节点ID，确认后即可实现插槽的迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What is the receiving node ID?</span><br></pre></td></tr></table></figure><p><strong>3.添加从节点：</strong></p><p>由于新的master节点相比其他主节点目前还没有从节点，因此该节点不具备故障转移的能力。</p><p>可以在从节点下使用<code>cluster replicate</code>命令为主节点添加对应从节点（在分片集群下slaveof命令添加从节点的操作不再支持）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;主节点ID&gt;</span><br></pre></td></tr></table></figure><p>从节点内部除了对主节点发起全量复制之外，还需要更新本地节点的集群相关状态。</p><h4 id="集群缩容">集群缩容</h4><p><strong>1.迁移插槽：</strong></p><p>缩容操作需要非常谨慎，因为如果下线的节点持有插槽，直接删除可能会引起数据一致性问题，因此需要将槽迁移给其他节点后才能安全下线，流程同上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;当前节点IP&gt;:&lt;端口&gt;</span><br></pre></td></tr></table></figure><p>接着Redis会提示需要移动多少插槽，自行输入即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">How many slots do you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure><p>然后需要输入接收插槽的节点ID，确认后即可实现插槽的迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What is the receiving node ID?</span><br></pre></td></tr></table></figure><p><strong>2.忘记节点：</strong></p><p>在一个可用的节点上执行删除节点的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node &lt;可用的节点IP&gt;:&lt;可用的节点端口&gt; &lt;需要删除的节点ID&gt;</span><br></pre></td></tr></table></figure><h3 id="手动故障转移">手动故障转移</h3><p>在 Redis 集群中，手动故障转移允许管理员主动介入，以便在发现主节点故障时，迅速将其替换为副本节点，确保系统的持续可用性和稳定性。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9cf6e902f3f0988f2f8e3964e21bd5a5.png"></p><p>此外，手动数据迁移还支持三种不同模式：</p><ul><li><strong>缺省：</strong> 默认的流程，如图1~6步</li><li><strong>force：</strong> 省略了对offset的一致性校验</li><li><strong>takeover：</strong> 直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见</li></ul></div></div><div class="kratos-copyright text-center clearfix"><h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5></div><footer class="kratos-entry-footer clearfix"><div class="post-like-donate text-center clearfix" id="post-like-donate"><a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a><div class="share-wrap" style="display:none"><div class="share-group"><a href="javascript:;" class="share-plain qq" onclick='share("qq")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-qq"></i></div></a><a href="javascript:;" class="share-plain qzone" onclick='share("qzone")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-star"></i></div></a><a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow"><div class="icon-wrap"><i class="fa fa-weixin"></i></div><div class="share-int"><div class="qrcode" id="wechat-qr"></div><p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p></div></a><a href="javascript:;" class="share-plain weibo" onclick='share("weibo")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-weibo"></i></div></a><a href="javascript:;" class="share-plain facebook style-plain" onclick='share("facebook")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-facebook"></i></div></a><a href="javascript:;" class="share-plain twitter style-plain" onclick='share("twitter")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-twitter"></i></div></a></div><script type="text/javascript">$(()=>{
            new QRCode("wechat-qr", {
                text: "https://moduokesi.top/2024/08/12/%E3%80%90Redis%E9%9B%86%E7%BE%A4%E3%80%91%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moduokesi.top/2024/08/12/%E3%80%90Redis%E9%9B%86%E7%BE%A4%E3%80%91%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/";
            const title         = "「【Redis集群】集群原理最全解析」";
            const excerpt       = `主从集群
单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。

数据同步概念
Replication Id和offset
在从节点发起数据同步的请求中，有两个重要的属性...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };</script></div></div><div class="footer-tag clearfix"><div class="pull-left"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/" rel="tag">主从集群</a>, <a class="tag-none-link" href="/tags/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/" rel="tag">分片集群</a>, <a class="tag-none-link" href="/tags/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/" rel="tag">哨兵机制</a></div><div class="pull-date"><time datetime="2024-08-14T06:48:38.617Z" itemprop="dateModified">最后编辑：2024-08-14</time></div></div></footer></div><nav class="navigation post-navigation clearfix" role="navigation"><div class="nav-previous clearfix"><a title=" 【JVM】深入JIT优化机制" href="/2024/08/08/【JVM】深入JIT优化机制/">&lt; 上一篇</a></div><div class="nav-next clearfix"><a title=" 【设计模式】单例模式详解" href="/2024/08/21/【设计模式】单例模式详解/">下一篇 &gt;</a></div></nav></article></section><section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm"><aside id="krw-about" class="widget widget-kratos-about clearfix"><div class="photo-background"></div><div class="photo-wrapper clearfix"><div class="photo-wrapper-tip text-center"><img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto"></div></div><div class="textwidget"><p class="text-center">华为云享专家<br>荣获多项国家级及省级荣誉<br>欢迎访问顶栏"链接"，关注更多技术内容</p></div><div class="site-meta"><a class="meta-item" href="/archives/"><span class="title">文章 </span><span class="count">35 </span></a><a class="meta-item" href="/categories/"><span class="title">分类 </span><span class="count">13 </span></a><a class="meta-item" href="/tags/"><span class="title">标签 </span><span class="count">43</span></a></div></aside><div class="sticky-area"><aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class"><div class="photo-background"></div><h4 class="widget-title no-after"><i class="fa fa-compass"></i> 文章目录 <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span></h4><div class="textwidget"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-text">主从集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="toc-text">数据同步概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replication-id%E5%92%8Coffset"><span class="toc-text">Replication Id和offset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repl_baklog%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">repl_baklog缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-text">第一次数据同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-text">增量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">优化策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-text">哨兵机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-text">自动故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0master%E8%8A%82%E7%82%B9"><span class="toc-text">选举新master节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">进行故障转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">通知Redis客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-text">分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">重要概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-text">散列插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%AA%E5%85%83"><span class="toc-text">配置纪元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-1"><span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-text">故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master%E8%8A%82%E7%82%B9"><span class="toc-text">选举新的master节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB-1"><span class="toc-text">进行故障转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5redis%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">通知Redis客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="toc-text">集群伸缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-text">集群扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="toc-text">集群缩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">手动故障转移</span></a></li></ol></li></ol></div></aside><aside id="krw-categories" class="widget widget-kratos-categories clearfix"><h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">常用集合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a><span class="category-list-count">5</span></li></ul></aside><aside id="krw-tags" class="widget widget-kratos-tags clearfix"><h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4><div class="tag-clouds"><a href="/tags/AOF/" style="font-size:.6em">AOF</a> <a href="/tags/AQS%E6%9C%BA%E5%88%B6/" style="font-size:.6em">AQS机制</a> <a href="/tags/ConcurrentHashMap/" style="font-size:.6em">ConcurrentHashMap</a> <a href="/tags/CountDownLatch/" style="font-size:.6em">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size:.6em">CyclicBarrier</a> <a href="/tags/HashMap/" style="font-size:.6em">HashMap</a> <a href="/tags/JIT/" style="font-size:.6em">JIT</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size:.6em">Java内存区域</a> <a href="/tags/MVCC/" style="font-size:.6em">MVCC</a> <a href="/tags/MapStruct/" style="font-size:.6em">MapStruct</a> <a href="/tags/RDB/" style="font-size:.6em">RDB</a> <a href="/tags/RabbitMQ/" style="font-size:.8em">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:.6em">Redis</a> <a href="/tags/Redisson/" style="font-size:.6em">Redisson</a> <a href="/tags/ReentrantLock/" style="font-size:.6em">ReentrantLock</a> <a href="/tags/Semaphore/" style="font-size:.6em">Semaphore</a> <a href="/tags/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size:.6em">SpringBoot启动流程</a> <a href="/tags/starter%E6%9C%BA%E5%88%B6/" style="font-size:.6em">starter机制</a></div></aside><aside id="krw-posts" class="widget widget-kratos-posts"><h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4><div class="tab-content"><ul class="list-group"><a class="list-group-item" href="/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/"><i class="fa fa-book"></i> 【分布式】分布式锁设计与Redisson源码解析</a> <a class="list-group-item" href="/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E4%B8%87%E5%AD%97%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"><i class="fa fa-book"></i> 【SpringBoot】万字源码解析——启动流程</a> <a class="list-group-item" href="/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E4%B8%87%E5%AD%97%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%8Estarter%E6%9C%BA%E5%88%B6/"><i class="fa fa-book"></i> 【SpringBoot】万字源码解析——自动装配与starter机制</a> <a class="list-group-item" href="/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><i class="fa fa-book"></i> 【Redis】深入五大数据类型</a> <a class="list-group-item" href="/2024/09/29/%E3%80%90%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E3%80%91%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMap%E9%9B%86%E5%90%88/"><i class="fa fa-book"></i> 【常用集合】深入浅出Map集合</a></ul></div></aside></div></section></div></div></div><footer><div id="footer" class="ap-lrc"><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 footer-list text-center"><ul class="kratos-social-icons"><li><a target="_blank" rel="nofollow" href="https://weibo.com/u/https://weibo.com/u/7728377351"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:modoxlixin@outlook.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="nofollow" href="https://github.com/moduokesi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><ul class="kratos-copyright"><div><li>&copy; 2024 Modox's blog 版权所有.</li><li>本站已运行<span id="span_dt">Loading...</span></li></div><div><li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li><li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Modox.</li></div><div><li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li><li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li></div><div></div></ul></div></div></div><div class="kr-tool text-center"><div class="tool"><div class="box search-box"><a href="/search/"><span class="fa fa-search"></span></a></div><div class="box theme-box" id="darkmode-switch"><span class="fa fa-adjust"></span></div></div><div class="box gotop-box"><span class="fa fa-chevron-up"></span></div></div></div></footer></div></div><script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script><script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script><script>window.kr||(window.kr={}),window.kr.notMobile=!navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),window.kr.siteRoot="/"</script><div><canvas id="snow"></canvas><script async src="/js/snow.min.js"></script></div><script async src="/js/candy.min.js"></script><script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script><script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="3204190542" order="random" fixed="true"></meting-js><script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/kratosr.min.js"></script><script defer src="/js/pjax.min.js"></script></body></html>