<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" href="/images/logo.png"><title>【分布式】一文详解五大分布式ID实现方案 | Modox&#39;s blog</title><meta name="author" content="Modox"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="format-detection" content="telphone=no, email=no"><meta name="keywords" content="UUID, 雪花算法"><meta name="description" content="分布式ID 分布式 ID 是在分布式环境中生成全局唯一标识符的技术，确保在不同节点生成的 ID 不会冲突。常用于数据库主键、订单号等场景。 分布式 ID 是分布式系统中不可或缺的一环，其设计直接影响系统的性能和稳定性。在实际应用中，可以根据业务需求选择合适的生成方案，如高并发场景优先选择雪花算法，有序性需求可选 Redis 或号段模式。  分布式 ID 需要满足下面几个特性："><meta property="og:type" content="article"><meta property="og:title" content="【分布式】一文详解五大分布式ID实现方案"><meta property="og:url" content="https://moduokesi.top/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/index.html"><meta property="og:site_name" content="Modox&#39;s blog"><meta property="og:description" content="分布式ID 分布式 ID 是在分布式环境中生成全局唯一标识符的技术，确保在不同节点生成的 ID 不会冲突。常用于数据库主键、订单号等场景。 分布式 ID 是分布式系统中不可或缺的一环，其设计直接影响系统的性能和稳定性。在实际应用中，可以根据业务需求选择合适的生成方案，如高并发场景优先选择雪花算法，有序性需求可选 Redis 或号段模式。  分布式 ID 需要满足下面几个特性："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moduokesi.top/images/logo.png"><meta property="article:published_time" content="2024-12-22T08:56:17.000Z"><meta property="article:modified_time" content="2025-03-15T08:33:10.841Z"><meta property="article:author" content="Modox"><meta property="article:tag" content="雪花算法"><meta property="article:tag" content="UUID"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://moduokesi.top/images/logo.png"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"><link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme:dark)"><script src="/js/kr-dark.min.js"></script><link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"><link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"><link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"><link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script><script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script><style>.kratos-cover.kratos-cover-2{background-image:url(/images/banner.webp)}@media(min-width:768px){body.custom-background{background-image:url(/images/bg.webp)}}</style><meta name="generator" content="Hexo 6.2.0"></head><body class="custom-background"><div id="kratos-wrapper"><div id="kratos-page"><div id="kratos-header"><header id="kratos-desktop-topnav" class="kratos-topnav"><div class="container"><div class="nav-header"><nav id="kratos-menu-wrap"><ul id="kratos-primary-menu" class="sf-menu"><li><a href="/"><i class="fa fa-home"></i> 首页</a></li><li><a href="/archives/"><i class="fa fa-file"></i> 档案馆</a></li><li><a><i class="fa fa-paw"></i> 友站</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://penty7710.github.io/">pety's blog</a></li></ul></li><li><a><i class="fa fa-link"></i> 链接</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah?type=blog">CSDN</a></li><li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/community/usersnew/id_1670078149364456">华为云</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/moduokesi_admin">Gitee</a></li><li><a target="_blank" rel="noopener" href="https://github.com/moduokesi">GitHub</a></li></ul></li></ul></nav></div></div></header><header id="kratos-mobile-topnav" class="kratos-topnav"><div class="container"><div class="color-logo"><a href="/">Modox&#39;s blog</a></div><div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div></div></header></div><div class="kratos-start kratos-hero-2"><div class="kratos-cover kratos-cover-2 text-center"><div class="desc desc2 animate-box"><a href="/"><h2>Modox&#39;s blog</h2><br><span></span></a></div></div></div><div id="kratos-blog-post"><div class="container"><div id="main" class="row"><section class="col-md-8"><article itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://moduokesi.top/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/"><div class="kratos-hentry kratos-post-inner clearfix"><header class="kratos-entry-header"><h1 class="kratos-entry-title text-center" itemprop="name headline">【分布式】一文详解五大分布式ID实现方案</h1><ul class="kratos-post-meta text-center"><li><time datetime="2024-12-22T08:56:17.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-12-22</time></li><li itemprop="author" itemscope itemtype="https://schema.org/Person"><i class="fa fa-user"></i> 作者 <span itemprop="name">Modox</span></li><li><i class="fa fa-edit"></i> ~8.71K 字</li></ul></header><div class="kratos-post-content"><div id="expire-alert" class="alert alert-warning hidden" role="alert"><div class="icon"><i class="fa fa-warning"></i></div><div class="text"><p>本文最后编辑于 <time datetime="1742027590841"></time> 前，其中的内容可能需要更新。</p></div></div><div class="kratos-post-inner-toc toc-div-class"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid"><span class="toc-number">1.</span> <span class="toc-text">分布式ID</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-number">2.</span> <span class="toc-text">数据库自增主键</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">数据库号段模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">3.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84incr%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">Redis的incr命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">4.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uuid"><span class="toc-number">5.</span> <span class="toc-text">UUID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uuid%E7%89%88%E6%9C%AC"><span class="toc-number">5.1.</span> <span class="toc-text">UUID版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">5.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">雪花算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8"><span class="toc-number">6.1.</span> <span class="toc-text">防止时钟回拨</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%A0%87%E8%AF%86%E4%BD%8D%E5%94%AF%E4%B8%80"><span class="toc-number">6.2.</span> <span class="toc-text">保证标识位唯一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%88%86%E9%85%8D"><span class="toc-number">6.2.1.</span> <span class="toc-text">预分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">6.2.2.</span> <span class="toc-text">动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.3.</span> <span class="toc-text">具体方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">6.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></div><hr><div itemprop="articleBody"><h1 id="分布式id">分布式ID</h1><p><strong>分布式 ID</strong> 是在分布式环境中生成全局唯一标识符的技术，确保在不同节点生成的 ID 不会冲突。常用于<strong>数据库主键</strong>、<strong>订单号</strong>等场景。</p><p>分布式 ID 是分布式系统中不可或缺的一环，其设计直接影响系统的性能和稳定性。在实际应用中，可以根据业务需求选择合适的生成方案，如高并发场景优先选择雪花算法，有序性需求可选 Redis 或号段模式。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211113892.png" style="zoom:25%"></p><p><strong>分布式 ID</strong> 需要满足下面几个特性：</p><ul><li><p><strong>全局唯一</strong>：每个ID在整个分布式系统中必须是全局唯一的，不能出现重复。</p></li><li><p><strong>高性能&amp;高可用</strong>：在高并发的情况下，分布式ID生成系统需要具备高可用性和低延迟，能够快速生成ID。</p></li><li><p><strong>有序性</strong>：ID 的有序性可以提升数据库的写入效率，以便排序或提高数据库性能。</p></li><li><p><strong>安全性</strong>：需要保证 ID 无法被轻易猜测，避免数据库信息被泄露。</p></li></ul><h1 id="数据库自增主键">数据库自增主键</h1><p><strong>数据库的自增主键</strong>（<code>AUTO_INCREMENT</code>）是数据库层面提供的一种功能，能够自动为新插入的记录生成一个递增的整数主键。利用这种特性，应用程序可以通过插入一条记录获取唯一的 ID。</p><h2 id="实现方法">实现方法</h2><p><strong>1. 创建数据库表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sequence_id` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stub` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `stub` (`stub`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>id</code> 字段：作为主键，保证 <code>id</code> 字段全局唯一，并通过 <code>AUTO_INCREMENT</code>，自增生成唯一的<strong>分布式 ID</strong>。</li><li><code>stub</code> 字段：设为唯一索引（<code>UNIQUE KEY</code>），无实际业务意义，仅用于支持 <code>REPLACE INTO</code> 操作。强制插入数据时不能有重复值。</li></ul><p><strong>2. 执行事务生成并获取唯一ID</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">REPLACE <span class="keyword">INTO</span> sequence_id (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;stub&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li>开启事务：利用事务的隔离性，防止其他线程获取到当前的分布式ID，破坏分布式ID的唯一性。</li><li><code>REPLACE INTO</code> 语义：如果 <code>stub</code> 值已经存在，则删除该行并插入新行；如果 <code>stub</code> 值不存在，则直接插入新行。通过 <code>REPLACE INTO</code> 插入元素，生成自增主键ID。</li><li><code>SELECT LAST_INSERT_ID()</code> 作用：返回当前会话最后一次生成的自增主键值。</li></ul><p>通过执行事务，可以获取到数据库生成的唯一ID：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211941941.png"></p><p>此时 <code>sequence_id</code> 表的数据如下：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411211941301.png"></p><h2 id="优缺点">优缺点</h2><p>使用数据库自增主键生成分布式ID的方案实现简单，适合中小型系统，以下是优缺点：</p><blockquote><p><strong>优点</strong>：</p></blockquote><ul><li><strong>唯一性</strong>：在同一个数据库实例内是唯一的，天然保证了 ID 不会重复；在数据库集群模式下，需要额外设计步长+偏移量的方案，保证唯一性。</li><li><strong>有序性</strong>：在数据库存储时，自增 ID 的有序性可以减少 B+ 树索引的分裂，提高写入性能；但在数据库集群模式下，不能保证分布式ID严格有序。</li></ul><blockquote><p><strong>缺点</strong>：</p></blockquote><ul><li><strong>性能问题</strong>：频繁的 <code>INSERT</code> 操作会引发锁的竞争，降低数据库性能；每次获取分布式 ID 都要访问数据库，查询受到磁盘I/O的限制。</li><li><strong>可用性问题</strong>：存在单点故障问题，如果负责生成 ID 的数据库实例宕机，整个系统将无法生成新 ID。</li><li><strong>数据膨胀问题</strong>：频繁的写操作会导致数据库的二进制日志快速膨胀，影响复制和备份效率。</li><li><strong>信息泄露问题</strong>：自增 ID 直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li></ul><h1 id="数据库号段模式">数据库号段模式</h1><p><strong>号段模式</strong>是一种高效生成分布式唯一ID的方案，适用于分布式系统中需要高性能、全局唯一ID的场景。号段模式通常依赖于数据库，通过将分配到的号段缓存到内存中，直接从号段中取值生成ID，避免频繁访问数据库。</p><blockquote><p><strong>号段</strong>：将一批连续的数字ID作为一个号段，例如 <code>[1001, 2000]</code>。客户端从号段中依次分配ID，直到用完，再申请新的号段。</p></blockquote><h2 id="实现方法-1">实现方法</h2><p><strong>1. 创建数据库表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sequence_id_generator (</span><br><span class="line">    biz_type <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,      <span class="comment">-- 业务类型，如订单ID、用户ID等</span></span><br><span class="line">    max_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,            <span class="comment">-- 当前号段的最大值</span></span><br><span class="line">    step <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                 <span class="comment">-- 步长（每次分配的号段大小）</span></span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,              <span class="comment">-- 乐观锁版本号，防止并发问题</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (biz_type)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表中各个字段的含义如下：</p><table><thead><tr class="header"><th style="text-align:left">字段</th><th>含义</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">biz_type</td><td>业务类型，用于区分不同业务的ID生成规则</td></tr><tr class="even"><td style="text-align:left">max_id</td><td>当前号段的最大值，表示分配的ID范围上限</td></tr><tr class="odd"><td style="text-align:left">step</td><td>每次申请号段时的步长，为实际可用的ID数量</td></tr><tr class="even"><td style="text-align:left">version</td><td>版本号，申请新的号段时根据版本号进行并发控制</td></tr></tbody></table><p><strong>2. 初始化数据</strong></p><p>在使用号段模式分配ID之前，需要先在数据库中初始化数据，方便后续客户端的取用号段。</p><p>这里将初始的号段最大值 <code>max_id</code> 设置为 0，步长 <code>step</code> 设置为 100，版本号 <code>version</code> 设置为 0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sequence_id_generator`(`biz_type`, `max_id`, `step`, `version`) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 获取分布式ID</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `max_id`, `step`,`version` </span><br><span class="line"><span class="keyword">FROM</span> `sequence_id_generator` </span><br><span class="line"><span class="keyword">WHERE</span> `biz_type` <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212052736.png" style="zoom:67%"></p><p>分配的号段 <code>[max_id + 1, max_id + step]</code> 为分布式ID的可用范围。申请到号段的线程会将该号段缓存起来，直接在内存中取用号段中的数据作为分布式ID，从而避免访问数据库。（如果使用的是数据库自增主键的方案，就需要查询 <code>step</code> 次数据库，影响性能）</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212101483.png" style="zoom:25%"></p><p><strong>4. 生成分布式ID</strong></p><p>如果某一业务类型的号段用尽时，需要从数据库中申请新的号段。在应用层执行 <code>UPDATE</code> 语句时需要使用乐观锁，防止并发情况下多个线程申请到相同的号段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sequence_id_generator </span><br><span class="line"><span class="keyword">SET</span> max_id <span class="operator">=</span> max_id <span class="operator">+</span> step, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> biz_type <span class="operator">=</span> <span class="number">101</span> <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;version&#125;;</span><br></pre></td></tr></table></figure><p>数据库更新结果：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411212120632.png"></p><h2 id="优缺点-1">优缺点</h2><blockquote><p><strong>优点：</strong></p></blockquote><ul><li><strong>唯一性</strong>：依靠 <code>MySQL</code> 数据库的行级锁和应用层的乐观锁，保证相同业务类型 <code>biz_type</code>下号段分配的唯一性。</li><li><strong>有序性</strong>：每个号段分配的 ID 都是单调递增的，这对于某些需要有序 ID 的场景（如订单号、时间戳排序等）非常适用。</li><li><strong>高性能</strong>：相较于<strong>数据库自增主键</strong>的方案，ID 分配主要在内存中完成，只有在号段用尽时才访问数据库申请新的号段，大大提高了生成效率。</li></ul><blockquote><p><strong>缺点</strong>：</p></blockquote><ul><li><strong>乐观锁重试问题</strong>：在高并发情况下，客户端申请号段时，乐观锁可能频繁失败，需要多次重试才能成功获取号段，增加了分配延迟。</li><li><strong>可用性问题</strong>：存在单点故障问题，如果负责生成号段的数据库实例宕机，整个系统将无法生成新 ID。</li><li><strong>信息泄露问题</strong>：自增 ID 直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li></ul><h1 id="redis的incr命令">Redis的incr命令</h1><p><code>Redis</code> 的 <code>INCR</code> 命令是一种简单高效的分布式 ID 生成方案。通过 <code>Redis</code> 的<strong>单线程模型</strong>来保证分布式 ID 的唯一性，而 <code>INCR</code> 命令则保证了分布式 ID 的有序性。</p><blockquote><p><strong>单线程模型</strong>：<code>Redis</code> 的单线程模型保证多个客户端执行 <code>INCR</code> 命令时，同一时刻只会有一个线程执行 <code>INCR</code> 命令，因此避免了并发安全问题。</p></blockquote><h2 id="实现方法-2">实现方法</h2><p><strong>1. 初始化数据</strong></p><p>首先设置分布式 ID 的初始结构，后续直接取用 <code>seq_id</code> 对应的 <code>value</code>值作为分布式 ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET seq_id 1</span><br></pre></td></tr></table></figure><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411231606213.png" style="zoom:33%"></p><p><strong>2. 生成分布式ID</strong></p><p>对于单机模式下的 <code>Redis</code>，由于只存在一个 <code>Redis</code> 节点，直接使用 <code>INCR</code> 命令即可保证有序性。</p><p>对于集群模式下的 <code>Redis</code>，由于存在多个 <code>Redis</code> 节点，因此需要给每个节点设置<strong>不同的初始偏移量</strong>，并使用 <code>INCRBY</code> 命令<strong>指定集群中所有节点数量的步长</strong>来保证全局唯一性。（也可以使用<strong>哈希插槽</strong>将生成的分布式 ID 的键固定到同一个节点，将问题转化单机模式，<code>Redis</code> 集群模式讲解<a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah/article/details/141125941?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229c435857282114ad3fa5bddcb8d72d10%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=9c435857282114ad3fa5bddcb8d72d10&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-141125941-null-null.nonecase&amp;utm_term=Redis&amp;spm=1018.2226.3001.4450">详见此处</a>）</p><p>比如集群中共存在3个节点A、B、C，可以指定A的初始值为0，B的初始值为1，C的初始值为2，步长设置为3。这样每个节点生成的分布式ID为 <code>初始偏移量 + 访问次数 * 步长</code>，防止不同节点生成重复的分布式ID，保证 ID 的全局唯一性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自增命令</span></span><br><span class="line">INCR seq_id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定步长自增</span></span><br><span class="line">INCRBY seq_id 3</span><br></pre></td></tr></table></figure><p><strong>3. 获取分布式ID</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET seq_id</span><br></pre></td></tr></table></figure><h2 id="优缺点-2">优缺点</h2><blockquote><p><strong>优点：</strong></p></blockquote><ul><li><strong>唯一性</strong>：单机模式下依赖于 <code>Redis</code> 的单线程模型，可以保证 ID的唯一性；在集群模式，可以通过<strong>哈希插槽</strong>固定键到某个节点，或者通过<strong>步长+偏移量</strong>实现分布式 ID 的生成。</li><li><strong>有序性</strong>：在 <code>Redis</code> 单机模式或者在集群模式使用<strong>哈希插槽</strong>固定键到某个节点时，可以保证 ID 是严格有序的。</li><li><strong>高性能</strong>：<code>Redis</code> 是内存数据库，<code>INCR</code> 操作非常快，延迟一般在微秒级，单节点 QPS 可达十万级别。</li><li><strong>高可用</strong>：通过部署 <code>Redis</code> 分片集群，可以解决单点故障问题，保证某些节点故障后分布式 ID 生成服务依旧可用。</li></ul><blockquote><p><strong>缺点</strong>：</p></blockquote><ul><li><strong>非严格有序</strong>：在分布式场景下，为了保证ID 的唯一性，通常通过<strong>步长+偏移量</strong>生成 ID，但这导致生成的 ID 不是严格有序的。</li><li><strong>信息泄露问题</strong>：自增 ID 直接暴露数据插入的顺序，可能导致业务敏感信息（如用户量、交易量）被推测。</li></ul><h1 id="uuid">UUID</h1><p><strong>UUID (Universally Unique Identifier)</strong> 是一种通用唯一标识符，其目的是为分布式系统中的所有元素生成唯一的标识符，在大多数情况下具有全球唯一性。UUID 的长度为 <code>128</code> 位（<code>16</code> 字节 ），通常用 <code>32</code> 个十六进制数字表示。</p><p>按照十六进制的数字个数划分，UUID的长度构成为 <code>8-4-4-4-12</code>，一共 32 个数字。以下为 UUID 的示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure><p>UUID 的内部结构分为 5 个主要部分，每部分基于不同的位数：</p><ol type="1"><li><strong>时间低位</strong>（前 8 个字符）：共 32 位，表示时间戳的地位部分。</li><li><strong>时间中位</strong>（占 4 个字符）：共 16 位，表示时间戳的中间部分。</li><li><strong>时间高位及版本号</strong>（占 4 个字符）：共 16 位，由前 4 位版本号和后 12 位的时间戳高位部分组成。</li><li><strong>变体及序列号</strong>（占 4 个字符）：共 16 位，前 3 位表示变体，后 13 位表示序列号。</li><li><strong>节点</strong>（占 12 个字符）：共 48 位，表示节点信息，通常是设备的 MAC 地址或随机数。</li></ol><p>UUID 的生成方式由其 <strong>版本号（Version）</strong> 和 <strong>变体（Variant）</strong> 决定，本文主要关注不同版本下 UUID。</p><h2 id="uuid版本">UUID版本</h2><p>UUID 的五个版本各有用途，但最常用的是<strong>版本一</strong>和<strong>版本四</strong>。<strong>版本三</strong>和<strong>版本五</strong>更适合生成基于命名空间的确定性标识符，而<strong>版本二</strong>因适用范围窄，在现代系统中已很少使用。</p><ul><li><p><strong>版本一：基于时间戳和节点地址的 UUID</strong></p><p>通过计算当前时间戳、时钟序列号和机器的 MAC 地址生成。</p><ul><li>由于使用了 MAC 地址，可以保证在全球范围内唯一性。</li><li>包含生成时间信息，时间戳可以用作生成时间的标识。</li><li>依赖硬件 MAC 地址，可能会暴露设备信息，存在隐私风险。</li></ul></li><li><p><strong>版本二：DCE 安全的 UUID</strong></p><p>类似于版本一，但是依赖于早期的 DCE （分布式计算环境）环境，增加了一些安全特性，在现代系统中很少使用。</p></li><li><p><strong>版本三：基于命名空间的UUID（MD5）</strong></p><p>通过对名字（如字符串）和命名空间（如 URL）的组合计算 MD5 哈希值，并将 MD5 哈希值的部分位替换为版本号和变体标志生成。</p><ul><li>相同命名空间中相同名字生成的 UUID 保持一致。</li><li>哈希算法确定性强，适用于需要固定标识符的场景。</li><li>使用 MD5 算法，安全性较弱。</li></ul></li><li><p><strong>版本四：基于随机数的UUID</strong></p><p>UUID 的 128 位数据大部分由随机数生成。</p><ul><li>无需依赖硬件或时间信息，生成速度快。</li><li>碰撞概率极低，即使生成 10¹² 个 UUID，也几乎不会发生冲突。</li><li>不包含设备或时间信息，隐私性较好。</li></ul></li><li><p><strong>版本五：基于命名空间的UUID（SHA1）</strong></p><p>与版本三类似，但使用更安全的 SHA-1 哈希算法代替 MD5。</p><ul><li><p>同样的命名空间和名字生成的 UUID 一致。</p></li><li><p>SHA-1 比 MD5 更安全，但仍然存在一定的碰撞风险（对于 UUID 应用影响有限）。</p></li></ul></li></ul><table><colgroup><col style="width:10%"><col style="width:72%"><col style="width:16%"></colgroup><thead><tr class="header"><th>UUID版本</th><th>重复条件</th><th>重复概率</th></tr></thead><tbody><tr class="odd"><td><strong>版本1</strong></td><td>如果两个设备具有相同的 MAC 地址、相同的时钟序列，并在同一时刻生成，则可能重复。</td><td><strong>几乎不可能</strong></td></tr><tr class="even"><td><strong>版本2</strong></td><td>如果两个设备使用相同的本地标识符（UID/GID）和相同时间戳，可能重复（需要运行在 DCE 环境）。</td><td><strong>几乎不可能</strong></td></tr><tr class="odd"><td><strong>版本3</strong></td><td><strong>相同命名空间</strong>和<strong>相同名字</strong>才会重复；不同命名空间或名字不会重复。</td><td><strong>确定性重复</strong></td></tr><tr class="even"><td><strong>版本5</strong></td><td><strong>相同命名空间</strong>和<strong>相同名字</strong>才会重复；不同命名空间或名字不会重复。</td><td><strong>确定性重复</strong></td></tr><tr class="odd"><td><strong>版本4</strong></td><td>由于随机数生成碰撞（在生成量极大时，如接近 <span class="math inline">\(2^{64}\)</span> 时可能发生）。</td><td><strong>极低概率</strong></td></tr></tbody></table><h2 id="优缺点-3">优缺点</h2><blockquote><p><strong>优点</strong>：</p></blockquote><ul><li><strong>唯一性</strong>：使用不同的算法生成，<strong>几乎可以保证</strong>在全球范围内唯一，避免了多台机器之间主键冲突的问题。</li><li><strong>无需网络请求</strong>：UUID 生成过程完全依赖本地算法，无需访问数据库或其他第三方服务，不依赖于网络请求，降低了延迟。</li><li><strong>高可用</strong>：UID 生成过程完全依赖本地算法，无需依赖于第三方服务。</li><li><strong>不可预测</strong>：UUID 没有明确的序列信息，能够在一定程度上保护数据隐私，不易被外界推测业务数据规模或增长趋势。</li></ul><blockquote><p><strong>缺点</strong>：</p></blockquote><ul><li><strong>存储开销大</strong>：UUID的长度为128位（16字节），存储时会占用较多空间，尤其是在数据库中作为主键时，会增加索引的存储成本。</li><li><strong>不具体有序性</strong>：UUID生成通常是随机的（如版本四），插入数据库时会导致索引频繁分裂或重排，降低写入性能。</li></ul><h1 id="雪花算法">雪花算法</h1><p><strong>雪花算法（Snowflake 算法）</strong>是 Twitter 开源的分布式唯一 ID 生成算法，主要用于分布式系统中生成全球唯一的、有序的 64 位长整型 ID。它能够在高并发环境下快速生成高效、唯一的 ID，并确保生成的 ID 大致有序。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411231700176.png"></p><ul><li><strong>符号位(1bit)</strong>：预留的符号位，始终为0，占用1位。</li><li><strong>时间戳(41bit)</strong>：记录生成 ID 时的时间戳，精确到毫秒级别，可以容纳的毫秒数是2的41次幂，可以支持大约 69 年的时间跨度。</li><li><strong>数据中心标识(5bit)</strong>：可以用来区分不同的数据中心。</li><li><strong>机器标识(5bit)</strong>：可以用来区分不同的机器。</li><li><strong>序列号(12bit)</strong>：表示同一毫秒内生成的 ID 的序号，单台机器每毫秒可以生成 4096 个唯一ID。</li></ul><p>默认的雪花算法是 64 bit，具体的长度可以自行配置。如果希望运行更久，增加<strong>时间戳</strong>的位数；如果需要支持更多节点部署，增加<strong>标识位</strong>的长度；如果并发很高，增加<strong>序列号</strong>的位数。</p><h2 id="防止时钟回拨">防止时钟回拨</h2><p><strong>雪花算法生成的唯一ID依赖于当前系统时间戳。</strong>如果发生<strong>时钟回拨</strong>（系统时间向后调整），导致新的时间戳与之前生成 ID 时的时间戳重复，可能会造成分布式 ID 不唯一的问题。</p><ol type="1"><li><strong>等待策略</strong>：使用一个变量 <code>lastTimestamp</code> 记录上次生成 ID 的时间戳。当检测到时钟回拨时，服务可以暂时拒绝生成新的ID，等待系统时钟恢复到正常状态（至少大于或等于上次生成ID时的时间戳）。这种策略可以确保ID的严格递增性，但可能会在时钟调整期间暂停服务，对系统性能造成一定的影响。</li><li><strong>序列号持久化</strong>：雪花算法原本设计中序列号是在内存中自增的，为了避免时钟回拨导致的序列号重置问题，可以将序列号持久化存储到磁盘上。这样即使服务重启或时钟回拨，服务也能继续从上次持久化的序列号开始自增，从而避免ID重复。这种策略可以在一定程度上容忍时钟回拨，但可能会影响ID的绝对时间戳准确性。</li></ol><h2 id="保证标识位唯一">保证标识位唯一</h2><p><strong>雪花算法生成的唯一ID依赖于标识位</strong>。在集群模式下产生重复 ID，需要以下两个前提条件：</p><ol type="1"><li>服务通过集群的方式部署，其中部分机器标识位一致。（比如在 K8s 中，多个 Pod 使用相同的配置镜像启动，而镜像中未动态生成唯一标识）</li><li>在高并发场景下，不同实例或业务在同一毫秒内生成了相同的序列号，由于机器标识位一致，导致生成的 ID 出现冲突。</li></ol><p>由此可知，<strong>只要能够保证标识位不重复，那么雪花算法生成的分布式ID也不会重复。</strong></p><h3 id="预分配">预分配</h3><p>在应用启动之前，统计当前服务的节点数量，人工去申请标识位。</p><p>这种方案适合服务节点数量基本不变或者服务节点数量少的情况，但是如果服务节点较多，或者经常需要扩缩容时，预分配是无法满足ID不重复的要求的。</p><h3 id="动态分配">动态分配</h3><p>将标识位存放在 Redis、Zookeeper、MySQL等中间件中，在服务启动时动态的请求标识位。</p><p>如果要保证分布式ID在<strong>服务内唯一</strong>，将标识位直接存放在服务所使用的 Redis 节点即可；如果要保证分布式ID的<strong>全局唯一</strong>，则多个服务需要使用同一个 Redis 节点保证唯一性。</p><p>数据中心标识和机器标识的组合为 <code>32 * 32</code>，即可以存储 <code>1024</code> 个服务节点，如果节点数超过了这个数量，则可以扩展标识位，或者选用其他开源的分布式ID框架。</p><h3 id="具体方案">具体方案</h3><p>下面将用 <code>Redis</code> 展示<strong>服务内唯一</strong>的标识号分配实现方案</p><p><strong>1. 设计键值结构</strong></p><p>使用 <code>Redis</code> 中的 <code>Hash</code> 结构，<code>KEY</code> 为，键值对为 <code>datacenterId</code> 、<code>workerId</code> 及其对应生成的标识号。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202412221308554.png" style="zoom:25%"></p><p><strong>2.标识号自增逻辑</strong></p><p>通过 <code>Lua</code> 脚本从 <code>Redis</code> 中获取标识位，具体的执行逻辑为：</p><ol type="1"><li><strong>检查 Hash 是否存在</strong>：如果 Redis 中不存在 <code>id_key</code> 这个 Hash，则初始化 <code>id_key</code>，并将 <code>dataCenterId</code> 和 <code>workerId</code> 设置为 0。</li><li><strong>判断 Hash 是否已存在</strong>：<ul><li>如果 <code>id_key</code> 已存在，检查 <code>dataCenterId</code> 和 <code>workerId</code> 是否都达到最大值（31）。</li><li>若条件满足，则将 <code>dataCenterId</code> 和 <code>workerId</code> 都重置为 0，并返回。</li></ul></li><li><strong>分配策略</strong>：<code>dataCenterId</code> 和 <code>workerId</code> 的排列组合一共有 1024 种可能性，在分配时优先分配 <code>workerId</code>。</li><li><strong>分配逻辑</strong>：<ul><li>检查 <code>workerId</code> 是否小于 31。若满足条件，则对 <code>workerId</code> 自增并返回。</li><li>如果 <code>workerId</code> 等于 31，则将 <code>dataCenterId</code> 自增，同时将 <code>workerId</code> 重置为 0，并返回。</li></ul></li></ol><h2 id="优缺点-4">优缺点</h2><blockquote><p><strong>优点</strong>：</p></blockquote><ul><li><strong>高性能高可用</strong>：生成时不依赖于数据库，完全在内存中生成，每秒钟能生成数百万的自增ID。</li><li><strong>ID自增</strong>：在单个进程中，生成的ID是自增的，可以用作数据库主键做范围查询。但是需要注意的是，在集群中是没办法保证顺序一定是递增的。</li></ul><blockquote><p><strong>缺点</strong>：</p></blockquote><ul><li><strong>重复ID问题</strong>：雪花算法依赖于时间戳，在获取时间的时候，如果出现时间回拨问题，服务器上的时间突然倒退到之前的时间，会造成 ID 重复的问题。</li><li><strong>依赖机器ID不灵活</strong>：每个节点的机器ID和数据中心ID都是硬编码在代码中的，在分布式环境如果节点出现故障或者需要扩容，更改机器ID和数据中心ID需要重新编译代码。</li></ul></div></div><div class="kratos-copyright text-center clearfix"><h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5></div><footer class="kratos-entry-footer clearfix"><div class="post-like-donate text-center clearfix" id="post-like-donate"><a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a><div class="share-wrap" style="display:none"><div class="share-group"><a href="javascript:;" class="share-plain qq" onclick='share("qq")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-qq"></i></div></a><a href="javascript:;" class="share-plain qzone" onclick='share("qzone")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-star"></i></div></a><a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow"><div class="icon-wrap"><i class="fa fa-weixin"></i></div><div class="share-int"><div class="qrcode" id="wechat-qr"></div><p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p></div></a><a href="javascript:;" class="share-plain weibo" onclick='share("weibo")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-weibo"></i></div></a><a href="javascript:;" class="share-plain facebook style-plain" onclick='share("facebook")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-facebook"></i></div></a><a href="javascript:;" class="share-plain twitter style-plain" onclick='share("twitter")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-twitter"></i></div></a></div><script type="text/javascript">$(()=>{
            new QRCode("wechat-qr", {
                text: "https://moduokesi.top/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moduokesi.top/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/";
            const title         = "「【分布式】一文详解五大分布式ID实现方案」";
            const excerpt       = `分布式ID
分布式 ID
是在分布式环境中生成全局唯一标识符的技术，确保在不同节点生成的 ID
不会冲突。常用于数据库主键、订单号等场景。
分布式 ID
是分布式系统中不可或缺的一环，其设计直接影响系统的性能和稳定性。在实际...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };</script></div></div><div class="footer-tag clearfix"><div class="pull-left"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/UUID/" rel="tag">UUID</a>, <a class="tag-none-link" href="/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" rel="tag">雪花算法</a></div><div class="pull-date"><time datetime="2025-03-15T08:33:10.841Z" itemprop="dateModified">最后编辑：2025-03-15</time></div></div></footer></div><nav class="navigation post-navigation clearfix" role="navigation"><div class="nav-previous clearfix"><a title=" 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析" href="/2024/11/17/【设计模式】策略模式详解/">&lt; 上一篇</a></div><div class="nav-next clearfix"><a title=" 【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册" href="/2025/01/25/【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册/">下一篇 &gt;</a></div></nav></article></section><section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm"><aside id="krw-about" class="widget widget-kratos-about clearfix"><div class="photo-background"></div><div class="photo-wrapper clearfix"><div class="photo-wrapper-tip text-center"><img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto"></div></div><div class="textwidget"><p class="text-center">华为云享专家<br>荣获多项国家级及省级荣誉<br>欢迎访问顶栏"链接"，关注更多技术内容</p></div><div class="site-meta"><a class="meta-item" href="/archives/"><span class="title">文章 </span><span class="count">39 </span></a><a class="meta-item" href="/categories/"><span class="title">分类 </span><span class="count">13 </span></a><a class="meta-item" href="/tags/"><span class="title">标签 </span><span class="count">54</span></a></div></aside><div class="sticky-area"><aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class"><div class="photo-background"></div><h4 class="widget-title no-after"><i class="fa fa-compass"></i> 文章目录 <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span></h4><div class="textwidget"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid"><span class="toc-text">分布式ID</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-text">数据库自增主键</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">数据库号段模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84incr%E5%91%BD%E4%BB%A4"><span class="toc-text">Redis的incr命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-2"><span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uuid"><span class="toc-text">UUID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uuid%E7%89%88%E6%9C%AC"><span class="toc-text">UUID版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-text">雪花算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8"><span class="toc-text">防止时钟回拨</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%A0%87%E8%AF%86%E4%BD%8D%E5%94%AF%E4%B8%80"><span class="toc-text">保证标识位唯一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%88%86%E9%85%8D"><span class="toc-text">预分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88"><span class="toc-text">具体方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-text">优缺点</span></a></li></ol></li></ol></div></aside><aside id="krw-categories" class="widget widget-kratos-categories clearfix"><h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81/">Spring源码</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">常用集合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a><span class="category-list-count">6</span></li></ul></aside><aside id="krw-tags" class="widget widget-kratos-tags clearfix"><h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4><div class="tag-clouds"><a href="/tags/2PC-3PC/" style="font-size:.6em">2PC/3PC</a> <a href="/tags/AOF/" style="font-size:.6em">AOF</a> <a href="/tags/AQS%E6%9C%BA%E5%88%B6/" style="font-size:.6em">AQS机制</a> <a href="/tags/ConcurrentHashMap/" style="font-size:.6em">ConcurrentHashMap</a> <a href="/tags/CountDownLatch/" style="font-size:.6em">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size:.6em">CyclicBarrier</a> <a href="/tags/HashMap/" style="font-size:.6em">HashMap</a> <a href="/tags/JIT/" style="font-size:.6em">JIT</a> <a href="/tags/JWT/" style="font-size:.6em">JWT</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size:.6em">Java内存区域</a> <a href="/tags/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" style="font-size:.6em">MQ事务消息</a> <a href="/tags/MVCC/" style="font-size:.6em">MVCC</a> <a href="/tags/MapStruct/" style="font-size:.6em">MapStruct</a> <a href="/tags/RDB/" style="font-size:.6em">RDB</a> <a href="/tags/RabbitMQ/" style="font-size:.8em">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:.8em">Redis</a> <a href="/tags/Redisson/" style="font-size:.6em">Redisson</a> <a href="/tags/ReentrantLock/" style="font-size:.6em">ReentrantLock</a></div></aside><aside id="krw-posts" class="widget widget-kratos-posts"><h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4><div class="tab-content"><ul class="list-group"><a class="list-group-item" href="/2025/03/15/%E3%80%90SpringBoot%E3%80%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94JWT%E7%BB%93%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E5%8F%8CToken%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"><i class="fa fa-book"></i> 【SpringBoot】最佳实践——JWT结合Redis实现双Token无感刷新</a> <a class="list-group-item" href="/2025/01/25/%E3%80%90Linux%E6%89%AB%E7%9B%B2%E3%80%91Vim%E5%91%BD%E4%BB%A4%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%9F%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%AF%B9%E4%BA%86%EF%BC%81Vim%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"><i class="fa fa-book"></i> 【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册</a> <a class="list-group-item" href="/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/"><i class="fa fa-book"></i> 【分布式】一文详解五大分布式ID实现方案</a> <a class="list-group-item" href="/2024/11/17/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa fa-book"></i> 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析</a> <a class="list-group-item" href="/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 【分布式】万字图文解析——深入七大分布式事务解决方案</a></ul></div></aside></div></section></div></div></div><footer><div id="footer" class="ap-lrc"><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 footer-list text-center"><ul class="kratos-social-icons"><li><a target="_blank" rel="nofollow" href="https://weibo.com/u/https://weibo.com/u/7728377351"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:modoxlixin@outlook.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="nofollow" href="https://github.com/moduokesi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><ul class="kratos-copyright"><div><li>&copy; 2025 Modox's blog 版权所有.</li><li>本站已运行<span id="span_dt">Loading...</span></li></div><div><li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li><li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Modox.</li></div><div><li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li><li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li></div><div></div></ul></div></div></div><div class="kr-tool text-center"><div class="tool"><div class="box search-box"><a href="/search/"><span class="fa fa-search"></span></a></div><div class="box theme-box" id="darkmode-switch"><span class="fa fa-adjust"></span></div></div><div class="box gotop-box"><span class="fa fa-chevron-up"></span></div></div></div></footer></div></div><script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script><script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script><script>window.kr||(window.kr={}),window.kr.notMobile=!navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),window.kr.siteRoot="/"</script><div><canvas id="snow"></canvas><script async src="/js/snow.min.js"></script></div><script async src="/js/candy.min.js"></script><script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script><script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="3204190542" order="random" fixed="true"></meting-js><script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/kratosr.min.js"></script><script defer src="/js/pjax.min.js"></script></body></html>