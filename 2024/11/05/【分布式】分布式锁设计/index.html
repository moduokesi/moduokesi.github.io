<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" href="/images/logo.png"><title>【分布式】分布式锁设计与Redisson源码解析 | Modox&#39;s blog</title><meta name="author" content="Modox"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="format-detection" content="telphone=no, email=no"><meta name="keywords" content="Redisson, 分布式锁"><meta name="description" content="分布式锁 分布式锁是一种在分布式计算环境中用于控制多个节点（或多个进程）对共享资源的访问的机制。在分布式系统中，多个节点可能需要协调对共享资源的访问，以防止数据的不一致性或冲突。分布式锁允许多个节点在竞争访问共享资源时进行同步，以确保只有一个节点能够获得锁，从而避免冲突和数据损坏。 设计一个分布式锁需要保证以下四大特性：  互斥性：在任意时刻，只能有一个进程持有锁。 进程一致：加锁和解锁"><meta property="og:type" content="article"><meta property="og:title" content="【分布式】分布式锁设计与Redisson源码解析"><meta property="og:url" content="https://moduokesi.top/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/index.html"><meta property="og:site_name" content="Modox&#39;s blog"><meta property="og:description" content="分布式锁 分布式锁是一种在分布式计算环境中用于控制多个节点（或多个进程）对共享资源的访问的机制。在分布式系统中，多个节点可能需要协调对共享资源的访问，以防止数据的不一致性或冲突。分布式锁允许多个节点在竞争访问共享资源时进行同步，以确保只有一个节点能够获得锁，从而避免冲突和数据损坏。 设计一个分布式锁需要保证以下四大特性：  互斥性：在任意时刻，只能有一个进程持有锁。 进程一致：加锁和解锁"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moduokesi.top/images/logo.png"><meta property="article:published_time" content="2024-11-05T03:12:31.000Z"><meta property="article:modified_time" content="2024-11-05T03:12:34.682Z"><meta property="article:author" content="Modox"><meta property="article:tag" content="Redisson"><meta property="article:tag" content="分布式锁"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://moduokesi.top/images/logo.png"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"><link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme:dark)"><script src="/js/kr-dark.min.js"></script><link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"><link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"><link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"><link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script><script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script><style>.kratos-cover.kratos-cover-2{background-image:url(/images/banner.webp)}@media(min-width:768px){body.custom-background{background-image:url(/images/bg.webp)}}</style><meta name="generator" content="Hexo 6.2.0"></head><body class="custom-background"><div id="kratos-wrapper"><div id="kratos-page"><div id="kratos-header"><header id="kratos-desktop-topnav" class="kratos-topnav"><div class="container"><div class="nav-header"><nav id="kratos-menu-wrap"><ul id="kratos-primary-menu" class="sf-menu"><li><a href="/"><i class="fa fa-home"></i> 首页</a></li><li><a href="/archives/"><i class="fa fa-file"></i> 档案馆</a></li><li><a><i class="fa fa-paw"></i> 友站</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://penty7710.github.io/">pety's blog</a></li></ul></li><li><a><i class="fa fa-link"></i> 链接</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah?type=blog">CSDN</a></li><li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/community/usersnew/id_1670078149364456">华为云</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/moduokesi_admin">Gitee</a></li><li><a target="_blank" rel="noopener" href="https://github.com/moduokesi">GitHub</a></li></ul></li></ul></nav></div></div></header><header id="kratos-mobile-topnav" class="kratos-topnav"><div class="container"><div class="color-logo"><a href="/">Modox&#39;s blog</a></div><div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div></div></header></div><div class="kratos-start kratos-hero-2"><div class="kratos-cover kratos-cover-2 text-center"><div class="desc desc2 animate-box"><a href="/"><h2>Modox&#39;s blog</h2><br><span></span></a></div></div></div><div id="kratos-blog-post"><div class="container"><div id="main" class="row"><section class="col-md-8"><article itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://moduokesi.top/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/"><div class="kratos-hentry kratos-post-inner clearfix"><header class="kratos-entry-header"><h1 class="kratos-entry-title text-center" itemprop="name headline">【分布式】分布式锁设计与Redisson源码解析</h1><ul class="kratos-post-meta text-center"><li><time datetime="2024-11-05T03:12:31.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-11-05</time></li><li itemprop="author" itemscope itemtype="https://schema.org/Person"><i class="fa fa-user"></i> 作者 <span itemprop="name">Modox</span></li><li><i class="fa fa-edit"></i> ~11.23K 字</li></ul></header><div class="kratos-post-content"><div id="expire-alert" class="alert alert-warning hidden" role="alert"><div class="icon"><i class="fa fa-warning"></i></div><div class="text"><p>本文最后编辑于 <time datetime="1730776354682"></time> 前，其中的内容可能需要更新。</p></div></div><div class="kratos-post-inner-toc toc-div-class"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">解锁过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Redis实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">解锁过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisson%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">Redisson实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">解锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">看门狗机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">锁等待机制</span></a></li></ol></li></ol></li></ol></div><hr><div itemprop="articleBody"><h1 id="分布式锁">分布式锁</h1><p><strong>分布式锁是一种在分布式计算环境中用于控制多个节点（或多个进程）对共享资源的访问的机制</strong>。在分布式系统中，多个节点可能需要协调对共享资源的访问，以防止数据的不一致性或冲突。分布式锁允许多个节点在竞争访问共享资源时进行同步，以确保只有一个节点能够获得锁，从而避免冲突和数据损坏。</p><p>设计一个分布式锁需要保证以下四大特性：</p><ul><li><strong>互斥性</strong>：在任意时刻，只能有一个进程持有锁。</li><li><strong>进程一致</strong>：加锁和解锁的操作必须由同一个进程执行。</li><li><strong>防死锁</strong>：即使有一个进程在持有锁期间崩溃而未能主动释放锁，必须有其他方式去释放锁，以保证其他进程能够获取到锁。</li><li><strong>锁续期</strong>：持锁线程执行的操作超出预期时间，只要持锁线程仍然在执行，锁就不应该被释放。</li></ul><h2 id="mysql实现">MySQL实现</h2><h3 id="结构设计">结构设计</h3><ul><li><strong>设计表结构</strong>：设计一个锁的唯一标识 <code>lock_name</code> 作为表的主键，<code>thread_id</code> 字段存储持有锁的线程ID、设置 <code>counter</code> 字段用于记录重入次数、<code>expires_at</code> 设置锁的过期时间，以防止死锁。</li><li><strong>设计索引</strong>：还可以在 <code>CREATE</code> 语句中建立联合索引，减少回表次数，优化查询速度，但在高并发场景下执行增删改操作效率会下降。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE distributed_locks (</span><br><span class="line">    lock_name VARCHAR(255) PRIMARY KEY,    -- 锁的唯一标识</span><br><span class="line">    thread_id VARCHAR(255),                -- 当前持有锁的线程ID</span><br><span class="line">    counter INT DEFAULT 0,                 -- 计数器，记录重入次数</span><br><span class="line">    expires_at TIMESTAMP NULL              -- 锁的过期时间</span><br><span class="line">    # INDEX idx_lock_thread_expires (lock_name, thread_id, expires_at)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="加锁过程">加锁过程</h3><ol type="1"><li><p><strong>首次获取锁</strong>：通过 <code>SELECT</code> 语句，以 <code>lock_name</code> 和 <code>expires_at</code> 为查询条件，查询存在且未过期的锁。如果锁不存在，则使用 <code>INSERT</code> 语句插入锁标识、线程ID、计数器初始值一和过期时间。如果锁存在，执行下一步骤。（设置过期时间实现<strong>「防死锁」</strong>；由于 <code>INSERT</code> 语句默认使用行级锁，同一时刻只能有一个线程插入成功，因此保证了<strong>「互斥性」</strong>）</p></li><li><p><strong>重复获取锁</strong>：判断查询结果中的 <code>thread_id</code> 字段是否与当前线程ID相同。如果相同，说明当前线程需要重复获取锁，执行 <code>UPDATE</code> 语句将 <code>counter</code> 字段加一，并重置过期时间。如果不相同，执行下一步骤。（设置计数器实现<strong>可重入锁</strong>）</p></li><li><p><strong>获取锁失败</strong>：直接从查询结果返回锁的过期时间，帮助申请锁的线程得知等待锁释放的时间。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 查询锁是否存在且未过期</span><br><span class="line">SELECT * FROM distributed_locks </span><br><span class="line">WHERE lock_name = ? AND expires_at &gt; NOW();</span><br><span class="line"></span><br><span class="line">IF 结果为空 THEN</span><br><span class="line">    -- 锁不存在，插入新锁记录</span><br><span class="line">    INSERT INTO distributed_locks (lock_name, thread_id, counter, expires_at)</span><br><span class="line">    VALUES (?, ?, 1, DATE_ADD(NOW(), INTERVAL ? SECOND));</span><br><span class="line">ELSEIF thread_id 等于当前线程ID THEN</span><br><span class="line">    -- 锁已被当前线程持有，重入锁</span><br><span class="line">    UPDATE distributed_locks </span><br><span class="line">    SET counter = counter + 1, expires_at = DATE_ADD(NOW(), INTERVAL ? SECOND)</span><br><span class="line">    WHERE lock_name = ?;</span><br><span class="line">ELSE</span><br><span class="line">    -- 锁已被其他线程持有，加锁失败</span><br><span class="line">    返回锁的剩余有效期</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><h3 id="解锁过程">解锁过程</h3><ol type="1"><li><strong>检查锁持有者</strong>：通过 <code>SELECT</code> 语句，以 <code>lock_name</code> 和 <code>thread_id</code> 为查询条件，查询锁是否由当前线程持有。如果结果为空，则返回 <code>NULL</code> 表示解锁失败。如果结果不为空，执行下一步骤。（通过条件判断保证<strong>「进程一致」</strong>，即加解锁为同一线程）</li><li><strong>减少锁计数器</strong>：执行 <code>UPDATE</code> 语句给持有锁的线程的计数器减一，并判断计数器是否大于零。如果大于零，说明锁还没有完全释放，执行 <code>UPDATE</code> 语句重置锁的过期时间，返回 0 表示锁未完全释放；如果等于零，说明当前线程已完全释放锁，则执行 <code>DELETE</code> 语句删除整个锁，返回 1 表示锁完全释放。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 检查锁是否由当前线程持有</span><br><span class="line">SELECT * FROM distributed_locks </span><br><span class="line">WHERE lock_name = ? AND thread_id = ?;</span><br><span class="line"></span><br><span class="line">IF 结果为空 THEN</span><br><span class="line">    -- 锁不属于当前线程，解锁失败</span><br><span class="line">    返回 NULL;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 减少锁计数器</span><br><span class="line">UPDATE distributed_locks </span><br><span class="line">SET counter = counter - 1 </span><br><span class="line">WHERE lock_name = ? AND thread_id = ?;</span><br><span class="line"></span><br><span class="line">-- 检查计数器是否大于0</span><br><span class="line">IF counter &gt; 0 THEN</span><br><span class="line">    -- 锁仍然被当前线程持有（重置过期时间）</span><br><span class="line">    UPDATE distributed_locks </span><br><span class="line">    SET expires_at = DATE_ADD(NOW(), INTERVAL ? SECOND)</span><br><span class="line">    WHERE lock_name = ?;</span><br><span class="line">    返回 0;</span><br><span class="line">ELSE</span><br><span class="line">    -- 计数器为0，完全释放锁</span><br><span class="line">    DELETE FROM distributed_locks WHERE lock_name = ?;</span><br><span class="line">    返回 1;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><h2 id="redis实现">Redis实现</h2><h3 id="结构设计-1">结构设计</h3><ul><li><strong>选用数据结构</strong>：采用 <code>String</code> 结构。设置锁的唯一标识作为 KEY，并指定一个<strong>唯一的线程标识</strong>作为值 VALUE。</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411050937549.png" style="zoom:33%"></p><h3 id="加锁过程-1">加锁过程</h3><ol type="1"><li><strong>设置锁</strong>：使用 SET 命令 NX（只在键不存在时设置）和 PX（设置过期时间）选项来实现一个原子操作，确保了即使持锁进程崩溃，其他进程仍然能够获取到锁，从而满足<strong>「互斥性」</strong>和<strong>「防死锁」</strong> 。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.尝试获取锁，值为唯一的线程标识</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="string">&#x27;NX&#x27;</span>, <span class="string">&#x27;PX&#x27;</span>, ARGV[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="解锁过程-1">解锁过程</h3><ol type="1"><li><strong>释放锁</strong>：通过 DEL 命令清除锁的键来释放锁。在执行 DEL 操作之前，先使用 GET 命令检查锁的值是否与持锁者的唯一标识匹配，从而满足<strong>「进程一致」</strong> 。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 2.比较线程标识与锁中的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">	<span class="comment">-- 执行del释放锁</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>无论是MySQL还是Redis实现的分布式，虽然都考虑到了<strong>互斥性</strong>、<strong>防死锁</strong>和<strong>进程一致</strong>问题，但是却无法解决<strong>锁续期</strong>问题。所以，Redis 官方推荐采用 Redisson 实现 Redis 的分布式锁，借助 Redisson 的 <code>WatchDog</code> 机制能够很好的解决锁续期的问题。</p></blockquote><h2 id="redisson实现">Redisson实现</h2><h3 id="结构设计-2">结构设计</h3><ul><li><strong>选用数据结构</strong>：采用 <code>Hash</code> 结构，设置锁的唯一标识为键，值采用 <code>field-value</code> 格式，以线程ID为 <code>field</code>，计数器为 <code>value</code> 实现可重入锁。</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411041024490.png" style="zoom:33%"></p><h3 id="加锁过程-2">加锁过程</h3><ol type="1"><li><strong>执行Lua脚本</strong>：整个 Lua 脚本是以事务方式在 Redis 中运行的，由于 Redis 是单线程模型，因此脚本内的所有命令是按顺序一次性执行的，不会在中途被打断或交叉执行，从而保证<strong>「互斥性」</strong>。</li><li><strong>首次获取锁</strong>：通过 <code>exists</code> 命令判断锁是否不存在。如果不存在，则执行 <code>hincrby</code> 命令设置 <code>Hash</code> 结构的 <code>field</code> 为线程ID，<code>value</code> 为计数器的初始值一，同时执行 <code>pexpire</code> 命令设置锁的过期时间；如果存在，执行下一步操作。</li><li><strong>重复获取锁</strong>：通过 <code>hexists</code> 命令判断锁中的 <code>field</code> 是否与当前线程相同。如果相同，则执行 <code>hincrby</code> 命令给 <code>field</code> 对应的计数器加一，同时执行 <code>pexpire</code> 命令重置锁的过期时间，防止锁在持有者持有期间过期；如果不相同，说明当前锁被其他线程持有。</li><li><strong>返回结果</strong>：如果返回 <code>nil</code> 表明获取锁成功；如果返回的数据不为 <code>null</code> 而是 <code>Long</code>，表明申请锁的线程需要等待的时间。</li></ol><p>完整代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果锁不存在，设置当前持有者，并将计数器设置为 1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 设置锁的过期时间，单位为毫秒</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 nil 表示锁成功创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断锁是否已被当前持有者持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果锁已被当前持有者持有，将持有者的计数加 1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 重置锁的过期时间，防止锁在持有者持有期间过期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 nil 表示锁成功重入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果锁已存在，但被其他持有者持有</span></span><br><span class="line"><span class="comment">-- 返回锁的剩余有效期，单位为毫秒</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="解锁过程-2">解锁过程</h3><ol type="1"><li><strong>检查锁持有者</strong>：通过 <code>hexists</code> 命令查询锁中的 <code>field</code> 是否与当前线程相同。如果不相同，表明锁的持有者不是当前线程，返回 <code>nil</code>，如果相同，执行下一步操作。（通过条件判断保证<strong>「进程一致」</strong>，即加解锁为同一线程）</li><li><strong>减少锁计数器</strong>：执行 <code>hincrby</code> 命令给持有锁的线程的计数器减一，并判断计数器是否大于零。如果大于零，说明锁还没有完全释放，执行 <code>pexpire</code> 命令重置锁的过期时间，返回 0 表示锁未完全释放；如果等于零，说明当前线程已完全释放锁，则执行 <code>del</code> 删除整个锁，同时执行 <code>publish</code> 命令通知所有等待锁的其他线程，返回 1 表示锁完全释放。（这里执行消息发布是服务于<strong>锁等待</strong>机制，防止无意义的申请锁而浪费资源）</li></ol><p>完整代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查锁是否由当前线程持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 减少当前线程持有的锁计数器</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断计数器值是否大于 0</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果计数器大于 0，说明锁仍然被当前线程持有（多次重入）</span></span><br><span class="line">    <span class="comment">-- 重置锁的过期时间，防止锁在当前线程还未完全释放时过期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">-- 返回 0 表示锁还未完全释放（计数器还未清零）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 如果计数器等于 0，说明当前线程已完全释放锁</span></span><br><span class="line">    <span class="comment">-- 删除整个锁键</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 通过发布频道通知锁已释放（适用于等待锁的其他线程）</span></span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 返回 1 表示锁成功释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若发生意外情况，返回 nil 表示操作失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><h3 id="看门狗机制">看门狗机制</h3><p>当线程尝试执行 <code>tryLock()</code> 方法获取锁时，在内部调用了 <code>tryAcquireAsync()</code> 方法获取锁的等待时间，返回值为 <code>Long</code> 型 。如果返回结果为 <code>null</code>，表明加锁成功；返回结果不为 <code>null</code>，返回值就是需要等待锁的释放时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取加锁的返回值，如果为null则加锁成功，不为null表明加锁失败，还需等待ttl的时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 获取锁成功，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用tryAcquireAsync获取锁的等待时间的Long值</span></span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>tryAcquireAsync()</code> 方法中，首先判断锁是否设置了释放时间。</p><ul><li>如果设置了锁的释放时间，直接进行上述 <strong>lua脚本</strong> 的加锁操作，并返回结果；</li><li>如果没有设置锁的释放时间，将锁的过期时间设置为默认值30s并进行 <strong>lua脚本</strong> 的加锁操作，同时<strong>启用看门狗机制</strong>，不断的进行自动续约，实现<strong>「锁续期」</strong>；</li><li>可以看到，两种操作都最终使锁被设置了过期时间，防止持有锁的客户端异常退出后锁无法释放的问题（即<strong>「防死锁」</strong>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果设置锁的过期时间，直接进行加锁操作返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有设置锁的过期时间，同样调用tryLockInnerAsync方法进行加锁，但是将过期时间默认设置为30s</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">			commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    </span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 出现异常，返回</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁获取成功，进行自动续约</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动续约</strong>的操作由 <code>scheduleExpirationRenewal</code> 方法实现。该方法内部首先会从成员变量的 <code>ConcurrentHashMap</code> 集合中根据当前锁的名称获取值，如果获取不到，说明当前线程任务执行完毕，无需再进行锁的自动续期；如果可以获取到值，则启动一个定时任务，通过递归调用实现每 10s 触发一次任务，在任务内部执行了如下的 <strong>lua脚本</strong>，从而重置锁的过期时间。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查锁的持有者是否与当前线程相同</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果相同，重置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">-- 返回 1 表示操作成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果 field 不存在，返回 0 表示操作失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>取消自动续约</strong>：当持有锁的线程的任务执行完毕后，会执行 <code>remove()</code> 方法删除 <code>ConcurrentHashMap</code> 集合中的键值，而看门狗在获取 <code>ConcurrentHashMap</code> 集合中的键值失败后，就会返回结果，结束自动续约。</p></blockquote><h3 id="锁等待机制">锁等待机制</h3><ol type="1"><li><strong>尝试获取锁</strong>：<ul><li>首先调用 <code>tryAcquire()</code> 方法获取锁剩余的存活时间 ttl，如果结果为 null，返回 true 表明加锁成功。</li><li>接着计算当前时间与获取锁之前的时间的差值，如果申请锁的耗时大于等待时间，表明申请锁失败，返回 false。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 1.尝试获取锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 1.1.锁获取成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// x...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>订阅锁释放通知</strong>：通过 <code>subscribe</code> 方法，基于当前线程的 <code>threadId</code> 发起一个异步订阅请求，等待锁释放的通知。这一步骤的主要作用是通过订阅锁的释放事件来实现对锁的高效管理，防止无效的锁申请对系统资源造成浪费。<ul><li><strong>等待锁释放超时</strong>：通过 <code>await()</code> 方法（内部使用 <code>CountDownLatch</code> 实现阻塞）在指定时间内等待失败，说明当前线程的等待时间超时，无需再获取锁，需要执行取消订阅和失败处理的逻辑。</li><li><strong>取消订阅</strong>：通过 <code>cancel()</code> 方法取消订阅。如果取消失败，说明订阅任务正在执行，此时无法直接取消任务。需要执行回调函数等待任务执行完毕；如果取消成功，则执行 <code>acquireFailed()</code> 方法并返回 false。</li><li><strong>回调函数取消订阅</strong>：通过 <code>onComplete</code> 回调，可以在任务完成后自动触发 <code>unsubscribe</code> 操作，以确保订阅状态被正确清理。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.订阅锁释放通知，通过await方法阻塞等待锁释放，防止无效的锁申请浪费资源</span></span><br><span class="line">RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line"><span class="comment">// 2.1.如果await在规定的时间内未完成，表示订阅超时，进入if代码块，执行取消订阅和失败处理的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">        subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                unsubscribe(subscribeFuture, threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    acquireFailed(threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2.计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败.</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.x</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>轮询获取锁</strong>：<ul><li><strong>再次获取锁</strong>：返回锁的剩余存活时间 <code>ttl</code>；如果 <code>ttl</code> 为空说明获取锁成功，直接返回 true，否则继续下一步。</li><li><strong>阻塞获取锁</strong>：取锁剩余的存活时间和线程剩余的等待时间的最小值，利用<strong>信号量</strong> <code>Semaphore</code> 阻塞获取锁。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.while(true)死循环，不断尝试获取锁</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 3.1.再次尝试获取锁</span></span><br><span class="line">    ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新剩余的等待时间</span></span><br><span class="line">    time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentTime = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.取锁剩余的存活时间和线程剩余的等待时间的最小值，尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">        getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新剩余的等待时间</span></span><br><span class="line">    time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>取消订阅</strong>：无论最终是否成功获取锁，在 <code>finally</code> 中都会调用 <code>unsubscribe()</code> 方法取消订阅，以确保资源释放和避免不必要的等待事件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.无论是否获取到了锁,都要取消订阅解锁消息</span></span><br><span class="line">    unsubscribe(subscribeFuture, threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="kratos-copyright text-center clearfix"><h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5></div><footer class="kratos-entry-footer clearfix"><div class="post-like-donate text-center clearfix" id="post-like-donate"><a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a><div class="share-wrap" style="display:none"><div class="share-group"><a href="javascript:;" class="share-plain qq" onclick='share("qq")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-qq"></i></div></a><a href="javascript:;" class="share-plain qzone" onclick='share("qzone")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-star"></i></div></a><a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow"><div class="icon-wrap"><i class="fa fa-weixin"></i></div><div class="share-int"><div class="qrcode" id="wechat-qr"></div><p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p></div></a><a href="javascript:;" class="share-plain weibo" onclick='share("weibo")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-weibo"></i></div></a><a href="javascript:;" class="share-plain facebook style-plain" onclick='share("facebook")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-facebook"></i></div></a><a href="javascript:;" class="share-plain twitter style-plain" onclick='share("twitter")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-twitter"></i></div></a></div><script type="text/javascript">$(()=>{
            new QRCode("wechat-qr", {
                text: "https://moduokesi.top/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moduokesi.top/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/";
            const title         = "「【分布式】分布式锁设计与Redisson源码解析」";
            const excerpt       = `分布式锁
分布式锁是一种在分布式计算环境中用于控制多个节点（或多个进程）对共享资源的访问的机制。在分布式系统中，多个节点可能需要协调对共享资源的访问，以防止数据的不一致性或冲突。分布式锁允许多个节点在竞争访问共享资源时进行同步，以确...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };</script></div></div><div class="footer-tag clearfix"><div class="pull-left"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/Redisson/" rel="tag">Redisson</a>, <a class="tag-none-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag">分布式锁</a></div><div class="pull-date"><time datetime="2024-11-05T03:12:34.682Z" itemprop="dateModified">最后编辑：2024-11-05</time></div></div></footer></div><nav class="navigation post-navigation clearfix" role="navigation"><div class="nav-previous clearfix"><a title=" 【SpringBoot】源码解析——启动流程" href="/2024/10/26/【SpringBoot】源码解析——启动流程/">&lt; 上一篇</a></div><div class="nav-next clearfix"><a title=" 【分布式】万字图文解析——深入七大分布式事务解决方案" href="/2024/11/14/【分布式】分布式事务/">下一篇 &gt;</a></div></nav></article></section><section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm"><aside id="krw-about" class="widget widget-kratos-about clearfix"><div class="photo-background"></div><div class="photo-wrapper clearfix"><div class="photo-wrapper-tip text-center"><img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto"></div></div><div class="textwidget"><p class="text-center">华为云享专家<br>荣获多项国家级及省级荣誉<br>欢迎访问顶栏"链接"，关注更多技术内容</p></div><div class="site-meta"><a class="meta-item" href="/archives/"><span class="title">文章 </span><span class="count">39 </span></a><a class="meta-item" href="/categories/"><span class="title">分类 </span><span class="count">13 </span></a><a class="meta-item" href="/tags/"><span class="title">标签 </span><span class="count">54</span></a></div></aside><div class="sticky-area"><aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class"><div class="photo-background"></div><h4 class="widget-title no-after"><i class="fa fa-compass"></i> 文章目录 <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span></h4><div class="textwidget"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%AE%9E%E7%8E%B0"><span class="toc-text">MySQL实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">解锁过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redis实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-text">解锁过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisson%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redisson实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-2"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-2"><span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B-2"><span class="toc-text">解锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-text">看门狗机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6"><span class="toc-text">锁等待机制</span></a></li></ol></li></ol></li></ol></div></aside><aside id="krw-categories" class="widget widget-kratos-categories clearfix"><h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81/">Spring源码</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">常用集合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a><span class="category-list-count">6</span></li></ul></aside><aside id="krw-tags" class="widget widget-kratos-tags clearfix"><h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4><div class="tag-clouds"><a href="/tags/2PC-3PC/" style="font-size:.6em">2PC/3PC</a> <a href="/tags/AOF/" style="font-size:.6em">AOF</a> <a href="/tags/AQS%E6%9C%BA%E5%88%B6/" style="font-size:.6em">AQS机制</a> <a href="/tags/ConcurrentHashMap/" style="font-size:.6em">ConcurrentHashMap</a> <a href="/tags/CountDownLatch/" style="font-size:.6em">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size:.6em">CyclicBarrier</a> <a href="/tags/HashMap/" style="font-size:.6em">HashMap</a> <a href="/tags/JIT/" style="font-size:.6em">JIT</a> <a href="/tags/JWT/" style="font-size:.6em">JWT</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size:.6em">Java内存区域</a> <a href="/tags/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" style="font-size:.6em">MQ事务消息</a> <a href="/tags/MVCC/" style="font-size:.6em">MVCC</a> <a href="/tags/MapStruct/" style="font-size:.6em">MapStruct</a> <a href="/tags/RDB/" style="font-size:.6em">RDB</a> <a href="/tags/RabbitMQ/" style="font-size:.8em">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:.8em">Redis</a> <a href="/tags/Redisson/" style="font-size:.6em">Redisson</a> <a href="/tags/ReentrantLock/" style="font-size:.6em">ReentrantLock</a></div></aside><aside id="krw-posts" class="widget widget-kratos-posts"><h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4><div class="tab-content"><ul class="list-group"><a class="list-group-item" href="/2025/03/15/%E3%80%90SpringBoot%E3%80%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94JWT%E7%BB%93%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E5%8F%8CToken%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"><i class="fa fa-book"></i> 【SpringBoot】最佳实践——JWT结合Redis实现双Token无感刷新</a> <a class="list-group-item" href="/2025/01/25/%E3%80%90Linux%E6%89%AB%E7%9B%B2%E3%80%91Vim%E5%91%BD%E4%BB%A4%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%9F%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%AF%B9%E4%BA%86%EF%BC%81Vim%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"><i class="fa fa-book"></i> 【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册</a> <a class="list-group-item" href="/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/"><i class="fa fa-book"></i> 【分布式】一文详解五大分布式ID实现方案</a> <a class="list-group-item" href="/2024/11/17/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa fa-book"></i> 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析</a> <a class="list-group-item" href="/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 【分布式】万字图文解析——深入七大分布式事务解决方案</a></ul></div></aside></div></section></div></div></div><footer><div id="footer" class="ap-lrc"><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 footer-list text-center"><ul class="kratos-social-icons"><li><a target="_blank" rel="nofollow" href="https://weibo.com/u/https://weibo.com/u/7728377351"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:modoxlixin@outlook.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="nofollow" href="https://github.com/moduokesi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><ul class="kratos-copyright"><div><li>&copy; 2025 Modox's blog 版权所有.</li><li>本站已运行<span id="span_dt">Loading...</span></li></div><div><li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li><li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Modox.</li></div><div><li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li><li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li></div><div></div></ul></div></div></div><div class="kr-tool text-center"><div class="tool"><div class="box search-box"><a href="/search/"><span class="fa fa-search"></span></a></div><div class="box theme-box" id="darkmode-switch"><span class="fa fa-adjust"></span></div></div><div class="box gotop-box"><span class="fa fa-chevron-up"></span></div></div></div></footer></div></div><script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script><script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script><script>window.kr||(window.kr={}),window.kr.notMobile=!navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),window.kr.siteRoot="/"</script><div><canvas id="snow"></canvas><script async src="/js/snow.min.js"></script></div><script async src="/js/candy.min.js"></script><script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script><script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="3204190542" order="random" fixed="true"></meting-js><script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/kratosr.min.js"></script><script defer src="/js/pjax.min.js"></script></body></html>