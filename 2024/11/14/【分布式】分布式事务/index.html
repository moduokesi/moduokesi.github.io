<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" href="/images/logo.png"><title>【分布式】万字图文解析——深入七大分布式事务解决方案 | Modox&#39;s blog</title><meta name="author" content="Modox"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="format-detection" content="telphone=no, email=no"><meta name="keywords" content="2PC/3PC, MQ事务消息, Saga, TCC, 分布式事务, 最大努力通知, 本地消息表"><meta name="description" content="分布式事务 分布式事务是指跨多个独立服务或系统的事务管理，以确保这些服务中的数据变更要么全部成功，要么全部回滚，从而保证数据的一致性。在微服务架构和分布式系统中，由于业务逻辑往往会跨多个服务，传统的单体事务无法覆盖，因此需要通过分布式事务来保障一致性。 三种数据一致性模型：  强一致性：系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。 弱一致性："><meta property="og:type" content="article"><meta property="og:title" content="【分布式】万字图文解析——深入七大分布式事务解决方案"><meta property="og:url" content="https://moduokesi.top/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/index.html"><meta property="og:site_name" content="Modox&#39;s blog"><meta property="og:description" content="分布式事务 分布式事务是指跨多个独立服务或系统的事务管理，以确保这些服务中的数据变更要么全部成功，要么全部回滚，从而保证数据的一致性。在微服务架构和分布式系统中，由于业务逻辑往往会跨多个服务，传统的单体事务无法覆盖，因此需要通过分布式事务来保障一致性。 三种数据一致性模型：  强一致性：系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。 弱一致性："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moduokesi.top/images/logo.png"><meta property="article:published_time" content="2024-11-14T02:46:02.000Z"><meta property="article:modified_time" content="2024-11-14T02:46:21.058Z"><meta property="article:author" content="Modox"><meta property="article:tag" content="TCC"><meta property="article:tag" content="Saga"><meta property="article:tag" content="2PC&#x2F;3PC"><meta property="article:tag" content="MQ事务消息"><meta property="article:tag" content="本地消息表"><meta property="article:tag" content="最大努力通知"><meta property="article:tag" content="分布式事务"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://moduokesi.top/images/logo.png"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"><link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme:dark)"><script src="/js/kr-dark.min.js"></script><link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"><link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"><link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"><link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script><script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script><style>.kratos-cover.kratos-cover-2{background-image:url(/images/banner.webp)}@media(min-width:768px){body.custom-background{background-image:url(/images/bg.webp)}}</style><meta name="generator" content="Hexo 6.2.0"></head><body class="custom-background"><div id="kratos-wrapper"><div id="kratos-page"><div id="kratos-header"><header id="kratos-desktop-topnav" class="kratos-topnav"><div class="container"><div class="nav-header"><nav id="kratos-menu-wrap"><ul id="kratos-primary-menu" class="sf-menu"><li><a href="/"><i class="fa fa-home"></i> 首页</a></li><li><a href="/archives/"><i class="fa fa-file"></i> 档案馆</a></li><li><a><i class="fa fa-paw"></i> 友站</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://penty7710.github.io/">pety's blog</a></li></ul></li><li><a><i class="fa fa-link"></i> 链接</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah?type=blog">CSDN</a></li><li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/community/usersnew/id_1670078149364456">华为云</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/moduokesi_admin">Gitee</a></li><li><a target="_blank" rel="noopener" href="https://github.com/moduokesi">GitHub</a></li></ul></li></ul></nav></div></div></header><header id="kratos-mobile-topnav" class="kratos-topnav"><div class="container"><div class="color-logo"><a href="/">Modox&#39;s blog</a></div><div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div></div></header></div><div class="kratos-start kratos-hero-2"><div class="kratos-cover kratos-cover-2 text-center"><div class="desc desc2 animate-box"><a href="/"><h2>Modox&#39;s blog</h2><br><span></span></a></div></div></div><div id="kratos-blog-post"><div class="container"><div id="main" class="row"><section class="col-md-8"><article itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://moduokesi.top/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><div class="kratos-hentry kratos-post-inner clearfix"><header class="kratos-entry-header"><h1 class="kratos-entry-title text-center" itemprop="name headline">【分布式】万字图文解析——深入七大分布式事务解决方案</h1><ul class="kratos-post-meta text-center"><li><time datetime="2024-11-14T02:46:02.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-11-14</time></li><li itemprop="author" itemscope itemtype="https://schema.org/Person"><i class="fa fa-user"></i> 作者 <span itemprop="name">Modox</span></li><li><i class="fa fa-edit"></i> ~11.40K 字</li></ul></header><div class="kratos-post-content"><div id="expire-alert" class="alert alert-warning hidden" role="alert"><div class="icon"><i class="fa fa-warning"></i></div><div class="text"><p>本文最后编辑于 <time datetime="1731552381058"></time> 前，其中的内容可能需要更新。</p></div></div><div class="kratos-post-inner-toc toc-div-class"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">刚性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">两阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">2.2.</span> <span class="toc-text">三阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">预提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">柔性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcc"><span class="toc-number">3.1.</span> <span class="toc-text">TCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">典型示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-1"><span class="toc-number">3.1.3.</span> <span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">MQ事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saga"><span class="toc-number">3.4.</span> <span class="toc-text">Saga</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">协调式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E6%8E%92%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">编排式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">3.4.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-number">3.5.</span> <span class="toc-text">最大努力通知</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">4.</span> <span class="toc-text">事务对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcc%E5%92%8C2pc3pc"><span class="toc-number">4.1.</span> <span class="toc-text">TCC和2PC&#x2F;3PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-number">4.2.</span> <span class="toc-text">MQ事务消息&amp;本地消息表&amp;最大努力通知</span></a></li></ol></li></ol></div><hr><div itemprop="articleBody"><h1 id="分布式事务">分布式事务</h1><p>分布式事务是指跨多个独立服务或系统的事务管理，以确保这些服务中的数据变更要么全部成功，要么全部回滚，从而<strong>保证数据的一致性</strong>。在微服务架构和分布式系统中，由于业务逻辑往往会跨多个服务，传统的单体事务无法覆盖，因此需要通过分布式事务来保障一致性。</p><p>三种数据一致性模型：</p><ul><li><strong>强一致性</strong>：系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。</li><li><strong>弱一致性</strong>：放宽了一致性保证，允许在不同节点之间的数据访问之间存在一定程度的不一致性，以换取更高的性能和可用性。</li><li><strong>最终一致性</strong>：允许在系统发生分区或网络故障后，经过一段时间，系统将最终达到一致状态。</li></ul><h1 id="刚性事务">刚性事务</h1><p>刚性事务（Rigid Transaction）也称为<strong>强一致性事务</strong>，遵循严格的ACID特性（原子性、一致性、隔离性、持久性），确保所有操作都严格按照要求执行，要么全部成功，要么全部回滚。刚性事务常用于金融系统、银行转账等场景，要求数据高度一致，不能有任何误差。</p><p>在分布式系统中，实现刚性事务通常采用<strong>2PC</strong>或<strong>3PC协议</strong>，但这些协议会带来较高的性能开销，同时存在同步阻塞等问题。因此，刚性事务适合对数据一致性要求极高、但允许较高事务延迟的场景。</p><p><strong>2PC</strong>或<strong>3PC协议</strong>根据 <code>XA</code> 规范衍生而来，<code>XA</code> 规范将分布式事务处理模型中涉及到了角色主要分为了应用程序（AP）、事务管理器（TM）和资源管理器（RM）</p><ul><li><code>AP(Application Program)</code>：应用程序本身。</li><li><code>RM(Resource Manager)</code>：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库，一个分布式事务往往涉及到多个资源管理器。</li><li><code>TM(Transaction Manager)</code>：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li></ul><h2 id="两阶段提交">两阶段提交</h2><p>2PC（Two-Phase Commit Protocol，两阶段提交协议）是分布式系统中广泛使用的一种协议，用于保证事务跨多个节点（参与者）一致地提交或回滚。</p><p>两阶段提交协议分为两个阶段：<strong>准备阶段</strong>和<strong>提交阶段</strong>。</p><h3 id="准备阶段">准备阶段</h3><ol type="1"><li><strong>事务管理器（TM）</strong>向所有<strong>事务参与者（资源管理器，RM）</strong>发送<strong>准备提交（prepare）</strong>的请求。</li><li>每个事务参与者在收到请求后执行以下操作：<ul><li>执行<strong>本地数据库事务预操作</strong>，比如写 <code>redo log / undo log</code> 日志，保留修改（如将数据写入暂存区域或进行日志记录），但不提交。</li><li>若该操作能够成功完成并保证后续提交，则返回<strong>同意消息</strong>。</li><li>若遇到错误或不能确保事务提交成功，则返回<strong>拒绝消息</strong>。</li></ul></li><li>在准备阶段，事务参与者只是准备提交，尚未实际提交事务。这使得系统仍然处于一致性状态。</li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131025662.png" style="zoom:25%"></p><h3 id="提交阶段">提交阶段</h3><ol type="1"><li>如果所有事务参与者都返回了<strong>同意消息</strong>，事务管理器向所有参与者发送<strong>提交（Commit）请求</strong>。<ul><li>各参与者收到提交消息后，正式提交事务操作，释放锁，清除临时数据，并通知事务管理器提交成功。</li></ul></li><li>如果任何一个事务参与者返回<strong>拒绝消息</strong>，事务管理器向所有参与者发送<strong>回滚（Rollback）请求</strong>。<ul><li>各参与者收到回滚消息后，撤销预操作，将状态恢复到事务开始之前。</li></ul></li><li>在提交阶段，如果某个参与者出现故障，事务管理器会根据超时或故障检测机制来决定事务状态，尽量使所有节点最终保持一致。</li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131039069.png" style="zoom:25%"></p><h3 id="存在的问题">存在的问题</h3><ul><li><strong>同步阻塞</strong>：在事务提交的过程中，如果事务管理者出现故障，所有的事务参与者会进入阻塞状态，等待事务管理者的进一步指令，导致整个系统的事务处理停滞，不能继续执行其他事务。</li><li><strong>单点故障</strong>：事务管理器是单点故障，如果事务管理器在提交阶段崩溃，系统将无法知道事务的最终状态，容易导致数据不一致。</li><li><strong>数据不一致风险</strong>：在提交阶段，若事务管理器在发送提交或回滚请求后崩溃，可能导致部分参与者收到提交请求，而部分未收到，从而造成数据不一致。</li></ul><h2 id="三阶段提交">三阶段提交</h2><p>3PC（Three-Phase Commit Protocol，三阶段提交协议）是在两阶段提交协议的基础上进一步改进的分布式事务一致性协议，通过增加<strong>预提交阶段</strong>，增强了系统的容错能力和处理网络分区的能力，以解决2PC的同步阻塞问题和单点故障风险。</p><h3 id="准备阶段-1">准备阶段</h3><ol type="1"><li><strong>事务管理器（TM）</strong>向所有<strong>事务参与者（资源管理器，RM）</strong>发送「准备请求」，询问它们是否能够完成事务提交操作。</li><li>每个事务参与者收到「准备请求」后，如果认为自己可以完成事务，则返回<strong>同意消息</strong>；如果认为无法完成，则返回<strong>拒绝消息</strong>。</li><li>事务管理器收集所有参与者的响应：<ul><li>若所有事务参与者都返回<strong>同意消息</strong>，则进入预提交阶段。</li><li>若任何一个事务参与者返回<strong>拒绝消息</strong>，则进入终止阶段并通知所有参与者回滚事务。</li></ul></li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131049007.png" style="zoom:25%"></p><h3 id="预提交阶段">预提交阶段</h3><ol type="1"><li>如果所有事务参与者在第一阶段都返回了<strong>同意消息</strong>，事务管理器向所有参与者发送「预提交请求」。</li><li>每个事务参与者收到「预提交请求」后，执行<strong>本地数据库事务预操作</strong>，记录日志，保存即将提交的事务信息，以确保即使事务管理器故障也能恢复状态。如果事务参与者成功执行了事务预操作，发送<strong>预提交成功</strong>给事务管理器；如果执行失败，返回<strong>预提交失败</strong>给事务管理器。</li><li>预提交阶段通过提前记录事务信息，保证即使事务管理器故障，事务参与者也能够通过日志记录自我恢复。</li><li>事务管理器<strong>在等待一段时间后</strong>收集所有参与者的响应：<ul><li>若所有参与者都返回<strong>预提交成功</strong>，事务管理器进入提交阶段。</li><li>若任意一个参与者返回<strong>预提交失败</strong>，则事务管理器进入终止阶段并通知所有参与者回滚事务。</li></ul></li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131054246.png" style="zoom:25%"></p><h3 id="提交阶段-1">提交阶段</h3><ol type="1"><li>若事务管理器在预提交阶段收到所有参与者的<strong>预提交成功</strong>，则向所有参与者发送「事务提交请求」。<ul><li>各参与者收到提交请求后，正式提交事务操作，释放锁，清除临时数据，并返回<strong>提交完成</strong>。</li></ul></li><li>若事务管理器在预提交阶段未收到所有参与者的响应，或检测到参与者或事务管理器自身出现故障，则事务管理器向所有参与者发送「事务回滚请求」。<ul><li>各参与者收到回滚请求后，撤销事务，并返回<strong>回滚完成</strong>。</li></ul></li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131039069.png" style="zoom:25%"></p><h3 id="优缺点">优缺点</h3><p>虽然 3PC 通过引入<strong>超时机制</strong>和<strong>预提交阶段</strong>一定程度上解决了 2PC 的同步阻塞和单点故障的问题，但是依然存在数据不一致的问题，同时也引入了一些新问题比如性能糟糕。</p><ul><li><strong>解决同步阻塞</strong>：在3PC中，通过<strong>预提交阶段</strong>参与者在实际提交前达成共识状态，具备了超时控制和独立决策的条件。即使协调者故障，参与者也能在超时后依据自身状态决定提交或回滚，从而有效避免了因协调者故障导致的长时间同步阻塞问题。</li><li><strong>解决单点故障</strong>：在3PC中，事务参与者引入了<strong>超时机制</strong>，当事务管理者挂掉后，事务参与者在等待超时后可以根据自身的状态来进行决策（如提交或回滚），不必依赖事务管理者的指令，从而降低了事务管理者的单点故障风险。</li></ul><p>存在的问题：</p><ul><li><strong>网络分区风险</strong>：3PC试图通过在预提交阶段前引入准备阶段来减少阻塞问题，但如果在该阶段发生网络分区，事务管理器和参与者之间的通信可能会断开。此时，部分参与者可能会继续提交事务，而其他未收到指令的参与者则可能回滚，从而导致数据不一致。</li><li><strong>性能降低</strong>：3PC虽然解决了一些2PC的阻塞问题，但增加的确认阶段和处理步骤使得事务处理的整体延迟变高。在高并发环境下，系统性能和响应速度可能会受到影响，导致事务处理效率较低。</li><li><strong>数据不一致风险</strong>：虽然3PC引入了超时机制，但当事务管理器在预提交阶段（准备提交）崩溃且没有及时恢复时，参与者可能会依据超时策略决定提交或回滚，导致不同参与者采取了不同的事务状态，从而产生数据不一致。</li></ul><h1 id="柔性事务">柔性事务</h1><p>柔性事务（Flexible Transaction）也称为<strong>最终一致性事务</strong>，放宽了对事务的严格性要求，允许系统在短期内出现不一致，只要在一段时间后达成<strong>最终一致性</strong>即可。柔性事务通常不完全遵循ACID特性，而采用<strong>BASE理论</strong>（基本可用、软状态、最终一致），在保证系统可用性的同时降低了对一致性的强制要求。</p><p>柔性事务广泛应用于电商订单处理、社交应用等对实时性和高可用性要求高，但数据一致性可延迟的场景。</p><p>柔性事务常见的实现方式包括：</p><ul><li><strong>TCC（Try-Confirm-Cancel）</strong>：将事务分解为三个步骤，先尝试（Try），再确认（Confirm）或取消（Cancel）。</li><li><strong>可靠消息事务</strong>：利用消息队列确保最终一致性，通过消息重试机制来保证事务操作的最终完成。</li><li><strong>补偿事务</strong>：通过补偿机制在出现错误时对事务进行回滚。</li></ul><h2 id="tcc">TCC</h2><p><strong>TCC</strong>（Try-Confirm-Cancel）是一种分布式事务解决方案，特别适用于柔性事务场景。TCC通过将事务分解为三个步骤来确保最终一致性，提供对事务操作的更加灵活的控制。</p><h3 id="执行流程">执行流程</h3><ul><li><strong>Try（尝试）阶段</strong>：事务参与者尝试执行本地事务，并对全局事务预留业务资源。如果 <code>try</code> 阶段执行成功，参与者会返回一个成功标识，否则会返回一个失败标识。</li><li><strong>Confirm（确认）阶段</strong>：如果所有参与者的 <code>try</code> 阶段都执行成功，则协调者通知所有参与者提交事务，执行 <code>confirm</code> 阶段。这时参与者将在本地提交事务，并处理全局事务预留的资源。</li><li><strong>Cancel（取消）阶段</strong>：如果任意参与者在 <code>try</code> 阶段或 <code>Confirm</code> 阶段执行失败，则协调者通知所有参与者回滚事务，执行 <code>cancel</code> 阶段。这时参与者将释放预留的业务资源。</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411131127522.png" style="zoom:25%"></p><blockquote><p>如果<strong>Confirm</strong>或者<strong>Cancel</strong>执行失败，可以采用重试的方式减少因为网络问题导致TM没有接收到消息的情况，此外，还可以采用异常监控、日志记录和人工干预的方式来保证事务的一致性。</p><p>对于<strong>Confirm</strong>执行失败，还可以采用执行<strong>Cancel</strong>操作的方式，撤销在<strong>Try</strong>阶段预留的事务资源。</p></blockquote><h3 id="典型示例">典型示例</h3><p>假设我们有一个转账服务，需要从 A 账户转账 100 元到 B 账户，同时从 A 账户转账 200 元到 C 账户，总计从 A 账户中扣减 300 元。整个事务流程分为 Try、Confirm 和 Cancel 三个阶段：</p><ol type="1"><li><strong>Try 阶段</strong>：转账服务首先冻结 A 账户的 300 元，以确保后续转账的可用性和一致性。</li><li><strong>Confirm 阶段</strong>：如果所有 Try 操作都成功执行，转账服务进入 Confirm 阶段，实际执行转账操作。此时，A 账户的冻结金额解冻，系统将 100 元转入 B 账户，200 元转入 C 账户，完成资金划转。</li><li><strong>Cancel 阶段</strong>：如果在 Try 阶段某一步失败，则系统进入 Cancel 阶段，对 A 账户的冻结金额进行解冻处理，保证资金不受影响；如果 Confirm 阶段中某步转账失败，例如 A 到 B 的转账失败，而 A 到 C 的转账已完成，则需要通过 C 到 A 的逆向转账操作将金额退回，保证 A 账户资金最终一致。</li></ol><p>通过这种方式，TCC 模式确保了分布式事务的最终一致性，即使在部分失败的情况下，系统也能通过回滚或补偿机制恢复到一致状态。</p><h3 id="存在的问题-1">存在的问题</h3><ul><li><strong>空回滚</strong>：在TCC协议中，如果某些参与者在<strong>Try</strong>阶段成功，而其他参与者失败，此时所有参与者需要执行<strong>Cancel</strong>操作。对于那些在<strong>Try</strong>阶段没有成功的参与者来说，执行<strong>Cancel</strong>操作就成为一次<strong>空回滚</strong>。如果业务没有有效地识别和处理空回滚，可能会导致异常错误，甚至可能导致<strong>Cancel</strong>一直失败，最终使整个分布式事务失败。</li><li><strong>悬挂事务</strong>：在TCC执行一阶段的<strong>Try</strong>操作阶段时，可能出现网络拥堵导致超时，事务协调器会触发二阶段的<strong>Cancel</strong>操作。而下游的节点由于网络延迟先接收到了<strong>Cancel</strong>，网络恢复后会在<strong>Cancel</strong>后再次接收到<strong>Try</strong>请求，这就导致该节点<strong>Try</strong>操作占用的资源无法释放，造成事务悬挂。</li></ul><h3 id="解决方案">解决方案</h3><p>通过引入<strong>分布式事务记录表</strong>，可以解决上述两个问题。该表中两个关键字段，一个是 <code>tx_id</code> 字段用于保存本次处理的事务ID，另一个是 <code>state</code> 字段用于记录本次事务的执行状态。</p><p>当后续在进行<strong>Try</strong>、<strong>Confirm</strong>和<strong>Cancel</strong>操作时，都需要在本地事务中创建或修改这条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#x27;distribute_transaction&#x27; (</span><br><span class="line">	&#x27;tx_id&#x27; varchar(128) NOT NULL COMMENT &#x27;事务id&#x27;,</span><br><span class="line">	&#x27;state&#x27; int(1) DEFAULT NULL COMMENT &#x27;事务状态，0:try，1:confirm，2:cancel&#x27;,</span><br><span class="line">	PRIMARY KEY (&#x27;tx_id&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>解决空回滚</strong>：当一个事务参与者接受到<strong>Cancel</strong>请求时，先去事务记录表中查询是否存在当前事务 <code>trx_id</code> 的<strong>Try</strong>操作的记录，如果记录不存在，则说明<strong>Try</strong>操作并未成功，此时可以直接跳过<strong>Cancel</strong>，避免执行空回滚。</li><li><strong>解决悬挂事务</strong>：当一个事务参与者接收到<strong>Try</strong>请求时，先去事务记录表中查询是否存在当前事务 <code>trx_id</code> 的<strong>Cancel</strong>操作的记录，如果存在，说明执行<strong>Try</strong>操作会导致事务悬挂，无法释放资源，拒绝本次<strong>Try</strong>请求。</li></ul><h2 id="mq事务消息">MQ事务消息</h2><p>RocketMQ 事务消息是一种可靠的消息传输机制，用于保证分布式事务的最终一致性。事务消息允许<strong>将消息的发送与本地事务绑定在一起</strong>，使得即使在网络异常或系统故障情况下，消息也能最终达到一致状态。</p><h3 id="执行流程-1">执行流程</h3><p>下图为MQ事务消息的总体执行流程：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411121502693.png"></p><p>RocketMQ 的事务消息通过 <code>TransactionListener</code> 接口实现，其执行流程总体上可以分为四个步骤：</p><ol type="1"><li><strong>发送半消息</strong>：消息发送方给 <code>MQ Broker</code> 发送一条 <code>Half</code> 消息，即半消息。半消息会存储在 <code>Broker</code> 的<strong>事务消息日志</strong>中，且该半消息暂时无法被消费。</li><li><strong>执行本地事务</strong>：半消息发送成功后，<code>Broker</code> 会通知消息发送方执行本地事务，消息发送方可以根据本地事务的执行情况，判断是否需要提交该事务消息。</li><li><strong>发送提交或回滚消息</strong>：如果本地事务执行成功，发送方会通知 <code>Broker</code> 提交该事务消息，使得消息被消费者消费；如果本地事务执行失败，发送方会通知 <code>Broker</code> 回滚该事务消息，并将该半消息从<strong>事务消息日志</strong>中删除，不会被消费者消费。</li><li><strong>回查事务状态</strong>：如果 <code>Broker</code> 在规定时间内没有收到 <code>COMMIT</code> 和 <code>ROLLBACK</code> 消息，会向消息发送方发送一个<strong>回查请求</strong>，根据请求的回调结果判断是否需要提交或回滚事务消息。</li></ol><h3 id="相关问题">相关问题</h3><blockquote><p><strong>半消息发送失败了，如何处理？</strong></p></blockquote><p>在 <strong>RocketMQ 事务消息</strong>的一致性解决方案中，应用程序（即消息发送方）是先发送半消息，后执行的本地事务。因此如果半消息发送失败了，直接进行消息重发即可，不会造成数据不一致的问题。</p><blockquote><p><strong>为什么需要先发送半消息？</strong></p></blockquote><p>主要原因是：<strong>本地事务执行完成后再发送消息，如果消息发送失败，那么 <code>Broker</code> 将无法感知本地事务的执行状态</strong>。</p><p>如果先执行完本地事务消息，再发送消息，当发送消息失败时，消费者没有半消息提供的本地事务的任何信息，因此 <code>Broker</code> 无法去回查本地事务的状态。</p><p>通过先发送半消息，<code>Broker</code> 可以在日志中记录该半消息，进而获知该事务的“初步状态”。如果半消息在超时内没有完成提交或回滚，<code>Broker</code> 就可以发起回查，以此来确保事务消息的最终一致性。因此，半消息为 <code>Broker</code> 提供了识别和查询特定事务状态的依据。</p><h2 id="本地消息表">本地消息表</h2><p>本地消息表（Local Message Table）同样也是一种分布式系统中常用的可靠消息传递方案。其核心思想是在发送消息的业务系统中，在消息发送方创建一个<strong>本地消息表</strong>，用于记录每一条需要发送的消息，并通过<strong>定时任务</strong>确保消息的可靠传递。</p><h3 id="执行流程-2">执行流程</h3><p>一个典型的本地消息表结构如下：</p><table><colgroup><col style="width:16%"><col style="width:16%"><col style="width:66%"></colgroup><thead><tr class="header"><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>id</td><td>VARCHAR(36)</td><td>消息ID，唯一标识</td></tr><tr class="even"><td>content</td><td>TEXT</td><td>消息内容</td></tr><tr class="odd"><td>status</td><td>INT</td><td>消息状态（0: 待发送，1: 已发送，2: 已完成）</td></tr><tr class="even"><td>retry_count</td><td>INT</td><td>重试次数</td></tr><tr class="odd"><td>create_time</td><td>TIMESTAMP</td><td>创建时间</td></tr><tr class="even"><td>update_time</td><td>TIMESTAMP</td><td>最后更新时间</td></tr></tbody></table><p>该方案主要将<strong>分布式事务</strong>拆分成了<strong>本地事务</strong>和<strong>消息事务</strong>两个部分，具体执行流程如下：</p><ol type="1"><li><strong>执行本地事务</strong>：首先由消息发送方开启本地事务，在本地事务中执行具体的业务操作。业务操作执行成功后，发送方将需要通知到其他服务的消息记录在<strong>本地消息表</strong>中，并设置消息状态为<strong>「待发送」</strong>。</li><li><strong>定时任务发送消息</strong>：在<strong>本地消息表</strong>中，消息初始状态为<strong>「待发送」</strong>。业务系统通过定时任务周期性地扫描本地消息表，找到所有<strong>「待发送」</strong>状态的消息，将其发送到消息队列，并将状态设置为<strong>「已发送」</strong>。定时任务的时间间隔可以根据业务需求设置。</li><li><strong>保证消息一致性</strong>：消息发送到消息队列后，可以通过<strong>消息重试机制</strong>，防止因网络问题导致传递的消息丢失问题；消息传递到消费者后，可以通过<strong>消费者确认机制</strong>、<strong>消息幂等处理</strong>来保证消息的一致性。</li><li><strong>返回消费结果</strong>：消费者消费完毕后，返回消费结果给生产者。生产者接收到消费者的消费确认后，根据消息的唯一ID，将<strong>本地消息表</strong>中对应消息的状态更新为<strong>「已完成」</strong>。</li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411140911116.png"></p><h3 id="相关问题-1">相关问题</h3><blockquote><p><strong>如果步骤1和2失败，如何处理？</strong></p></blockquote><p>当本地事务执行失败时，由于此阶段将业务操作和消息表写入放在了同一个事务中，即使步骤1和2执行失败，事务也可以通过回滚恢复数据，保证业务操作和消息表写入的一致性。</p><blockquote><p><strong>如果步骤3中的消息发送失败，如何处理？</strong></p></blockquote><p>需要在消息发送方开启一个定时任务，不断的扫描<strong>本地消息表</strong>中状态为<strong>「待发送」</strong>的消息，对于未发送成功的消息重新投递。</p><blockquote><p><strong>如果步骤4和5失败，如何处理？</strong></p></blockquote><p>依靠消费者的确认机制和重试机制，如果消息丢失或者处理失败，则重新进行投递。此外，还可以借助死信队列进行额外处理。</p><blockquote><p><strong>如果步骤6和7失败，即本地消息表更新失败，如何处理？</strong></p></blockquote><p>执行到这里时，已经可以保证消息发送方和消息接收方的业务数据保持一致了，但是本地消息表的数据还未更新。消息接收方可以设置定时任务，定期扫描<strong>本地消息表</strong>中的消息，如果消息为<strong>「已发送」</strong>而不是<strong>「已完成」</strong>，可以通过重试来再次尝试更新本地消息的状态。此外，消息发送方可以设置定时任务，主动查询消费者的业务状态，如果消息被正常消费，可以直接更新<strong>本地消息表</strong>。</p><h2 id="saga">Saga</h2><p>Saga 是一种分布式事务管理模式，主要用于解决微服务架构中跨多个服务的事务一致性问题。Saga模式通过将一个大事务分解成一系列小的局部事务，并通过<strong>补偿机制</strong>来保证最终一致性，从而避免了传统的分布式事务（如2PC或3PC）带来的性能瓶颈和复杂性。</p><h3 id="协调式">协调式</h3><p>编排式Saga是由一个<strong>中央协调者</strong>来控制整个Saga事务的执行流程。协调者负责决定每个局部事务的执行顺序，处理每个局部事务的成功或失败，并在必要时触发补偿操作。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411141038197.png" style="zoom:80%"></p><h3 id="编排式">编排式</h3><p>编排式<strong>没有中央协调者</strong>，而是通过<strong>事件驱动</strong>的方式来协调各个局部事务的执行。每个服务通过发布事件来通知其他服务，其他服务根据事件决定是否执行后续操作或进行补偿。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202411141038297.png" style="zoom:67%"></p><h3 id="对比">对比</h3><p><strong>编排式Saga</strong>适用于事务流程较为清晰、需要集中控制的场景，尤其是在业务流程复杂且需要监控和调度时。它具有较强的控制能力，但可能会带来单点故障问题。</p><p><strong>事件驱动式Saga</strong>适用于高可扩展性、去中心化的分布式系统，适合松耦合的微服务架构。它更加灵活，但在实现上需要处理更复杂的事件和状态管理。</p><table><colgroup><col style="width:19%"><col style="width:41%"><col style="width:39%"></colgroup><thead><tr class="header"><th>特性</th><th>编排式（Orchestration）</th><th>事件驱动式（Choreography）</th></tr></thead><tbody><tr class="odd"><td><strong>控制方式</strong></td><td>中央协调者控制事务执行</td><td>各个服务通过事件进行事务协作</td></tr><tr class="even"><td><strong>事务执行顺序</strong></td><td>顺序执行，协调者决定后续事务的执行</td><td>各个服务根据事件决定执行顺序</td></tr><tr class="odd"><td><strong>补偿操作</strong></td><td>由协调者决定是否进行补偿操作</td><td>由各服务根据事件决定补偿操作</td></tr><tr class="even"><td><strong>扩展性</strong></td><td>较差，协调者可能成为瓶颈</td><td>高，服务间解耦，易于扩展</td></tr><tr class="odd"><td><strong>耦合度</strong></td><td>高，服务需要与协调者交互</td><td>低，服务间解耦，事件驱动</td></tr><tr class="even"><td><strong>单点故障问题</strong></td><td>是，协调者故障会影响整个事务</td><td>否，没有单点故障问题</td></tr><tr class="odd"><td><strong>监控与调试</strong></td><td>相对简单，所有操作由协调者管理</td><td>较为复杂，需要事件追踪和状态管理</td></tr></tbody></table><h2 id="最大努力通知">最大努力通知</h2><p>在最大努力通知机制中，发送方会尽最大可能确保通知送达目标，通常通过<strong>重试机制</strong>提高通知的到达率。在此过程中，若出现网络通信故障或消息队列异常，就可能导致消息传递失败，<strong>即消息可能会丢失</strong>。因此，最大努力通知机制不能完全保证接收方一定能收到每条消息，但会尽最大努力确保消息通知的完成。</p><p>最大努力通知常见实现：生产者重试机制、消费者重试机制、死信队列、定时任务重试</p><p>最大努力通知适合在以下场景中使用：</p><ul><li><strong>日志记录</strong>：日志记录的发送可以采用最大努力通知的方式，保证不影响主业务流程。</li><li><strong>非核心业务流程</strong>：例如积分更新、通知消息推送等，在用户体验上容错性较高的场景。</li></ul><h1 id="事务对比">事务对比</h1><h2 id="tcc和2pc3pc">TCC和2PC/3PC</h2><p><strong>适用场景</strong>：</p><ul><li><strong>TCC</strong>：提供<strong>最终一致性</strong>，允许短时间内的数据不一致，通过补偿机制在失败后恢复状态。适合对响应速度要求高、允许一定延迟一致性的场景，如电商订单处理、支付等需要预留资源的业务。</li><li><strong>2PC</strong>：提供<strong>强一致性</strong>，确保所有参与者最终的状态保持一致，要么全部成功提交，要么全部回滚。适合对一致性要求高的场景，如金融系统、银行转账等场景，要求数据高度一致，不能有任何误差。</li></ul><p><strong>执行流程</strong>：</p><ul><li><strong>TCC</strong>：三阶段模型，主要包括<strong>Try（预留资源）</strong>、<strong>Confirm（提交）</strong>、<strong>Cancel（补偿/撤销）</strong>，在<strong>Try</strong>或<strong>Confirm</strong>阶段执行失败可以进行<strong>Cancel</strong>补偿。</li><li><strong>2PC</strong>：两阶段模型，主要包括<strong>Prepare（准备）</strong>和<strong>Commit（提交）</strong>，无独立的回滚机制。</li></ul><p><strong>容错和恢复机制</strong>：</p><ul><li><strong>TCC</strong>：每个阶段都有独立的失败处理，通过Cancel阶段的补偿操作可以回滚已预留的资源。</li><li><strong>2PC</strong>：容错能力较弱，尤其在协调者宕机的情况下易发生资源锁死，恢复依赖协调者的重启和日志记录。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>TCC</strong>：是业务层面的分布式事务，不会一直持有资源的锁，性能较好。TCC 方案允许各个参与者自定义Try、Confirm和Cancel事务逻辑，对业务侵入性较高，但具有较好的灵活性和可恢复性。</li><li><strong>2PC</strong>：是资源层面的分布式事务，需要数据库支持XA协议，在两阶段提交的整个过程中，会一直持有资源的锁，一般高并发性能会比较差。2PC 方案由协调者统一管理事务状态，能确保强一致性，但在分布式系统中较为耗时，且在网络中断或协调者失败时可能会出现阻塞问题。</li></ul><hr><table><colgroup><col style="width:22%"><col style="width:36%"><col style="width:41%"></colgroup><thead><tr class="header"><th>特点</th><th>TCC</th><th>2PC</th></tr></thead><tbody><tr class="odd"><td><strong>事务管理</strong></td><td>由业务逻辑分阶段管理</td><td>由协调者统一管理</td></tr><tr class="even"><td><strong>阶段划分</strong></td><td>Try、Confirm、Cancel</td><td>准备阶段、提交阶段</td></tr><tr class="odd"><td><strong>执行方式</strong></td><td>预留资源+确认/取消业务执行</td><td>准备阶段锁定资源+正式提交/回滚</td></tr><tr class="even"><td><strong>一致性</strong></td><td>最终一致性</td><td>强一致性</td></tr><tr class="odd"><td><strong>资源锁定时间</strong></td><td>较短</td><td>较长，可能导致阻塞</td></tr><tr class="even"><td><strong>容错机制</strong></td><td>允许自定义重试和补偿</td><td>协调者故障会阻塞事务</td></tr><tr class="odd"><td><strong>性能</strong></td><td>较高，灵活性好</td><td>较低，且有单点故障风险</td></tr></tbody></table><h2 id="mq事务消息本地消息表最大努力通知">MQ事务消息&amp;本地消息表&amp;最大努力通知</h2><p><strong>适用场景</strong>：</p><ul><li><strong>MQ事务消息</strong>：适用于金融交易、订单支付等场景，尤其适合对系统一致性和事务可靠性要求较高的场景。事务消息能确保在消息发送和本地事务之间的一致性。</li><li><strong>本地消息表</strong>：适用于异步处理或延迟处理，尤其是在高并发、大流量场景中，可以通过本地消息表和定时任务确保消息可靠性。</li><li><strong>最大努力通知</strong>：适用于容忍一定消息丢失的场景，例如日志记录、通知推送等业务，这类业务的容错性较高，不需要完全保证每条消息的送达，只要尽最大努力确保通知的到达即可。</li></ul><p><strong>执行流程</strong>：</p><ul><li><strong>MQ事务消息</strong>：消息发送方先发送半消息到 <code>Broker</code>，此时消息不可消费，但 <code>Broker</code> 会记录该消息状态。接着执行本地事务，根据执行结果，发送方通知 <code>Broker</code> 提交或回滚消息，决定消息是否可消费。如果 <code>Broker</code> 在规定时间内未收到确认，会向发送方发起回查请求，以确保消息状态和事务最终一致。</li><li><strong>本地消息表</strong>：发送方在本地事务中记录消息到<strong>本地消息表</strong>，确保消息与业务操作同步执行且一致。记录的消息状态为“待发送”，定时任务定期扫描表中待发送的消息，将其发送至消息队列。消息成功消费后，消费者通过确认机制通知发送方，发送方将消息状态更新为“已完成”。</li><li><strong>最大努力通知</strong>：发送方在消息发送过程中尽量保证消息成功传递给接收方，即使遇到网络问题也会进行多次重试。发送失败的消息会进入重试队列或死信队列，以便后续重发或进一步处理。尽管此机制不能保证百分百的消息送达，但通过多层次的重试和降级措施，努力减少消息丢失。</li></ul><p><strong>容错和恢复机制</strong>：</p><ul><li><strong>MQ事务消息</strong>：消息发送方先发送半消息到 <code>Broker</code> 并记录状态，接着执行本地事务。根据事务结果决定提交或回滚该消息；如果 <code>Broker</code> 未收到确认，将回查事务状态，确保消息最终一致性。</li><li><strong>本地消息表</strong>：本地事务中将消息记录到<strong>本地消息表</strong>并设为“待发送”，由定时任务扫描发送至消息队列。消息消费成功后更新状态为“已完成”，保证业务和消息的最终一致。</li><li><strong>最大努力通知</strong>：发送方通过多次重试确保消息尽量传递成功，遇到异常则进入重试或死信队列处理。尽管不能确保百分百送达，通过重试和降级机制尽量减少消息丢失。</li></ul><p><strong>性能与复杂度</strong>：</p><ul><li><strong>MQ事务消息</strong>：性能较低，因为每次发送消息都需要和本地事务进行绑定，并且涉及到消息提交或回滚的操作。系统复杂度较高，需要处理回查等操作。</li><li><strong>本地消息表</strong>：性能相对较好，通过定时任务和本地消息表机制，不需要等待事务的回查，但需要额外的定时任务和表管理，且数据库的存储压力较大。</li><li><strong>最大努力通知</strong>：性能最好，消息的发送与本地事务并不绑定，只需要通过重试机制和死信队列保证尽最大努力将消息送达。适用于容忍一定丢失的业务场景。</li></ul><hr><table><colgroup><col style="width:6%"><col style="width:33%"><col style="width:33%"><col style="width:26%"></colgroup><thead><tr class="header"><th>特点</th><th style="text-align:left">MQ事务消息</th><th>本地消息表</th><th>最大努力通知</th></tr></thead><tbody><tr class="odd"><td><strong>适用场景</strong></td><td style="text-align:left">需要保证分布式事务一致性的场景</td><td>不要求强一致性，确保消息最终送达</td><td>容忍一定消息丢失的场景</td></tr><tr class="even"><td><strong>执行流程</strong></td><td style="text-align:left">发送半消息 -&gt; 执行本地事务 -&gt; 提交/回滚消息 -&gt; 回查事务状态</td><td>执行本地事务 -&gt; 记录消息 -&gt; 定时任务发送消息 -&gt; 消费者确认</td><td>尽最大努力发送消息 -&gt; 重试机制/死信队列</td></tr><tr class="odd"><td><strong>容错机制</strong></td><td style="text-align:left">通过回查机制保证最终一致性</td><td>通过定时任务和重试机制保证消息可靠性</td><td>重试机制和死信队列，无法完全保证送达</td></tr><tr class="even"><td><strong>一致性</strong></td><td style="text-align:left">强一致性，消息与事务绑定</td><td>最终一致性，依赖重试机制和确认机制</td><td>无法保证一致性，只能最大努力保证送达</td></tr><tr class="odd"><td><strong>性能</strong></td><td style="text-align:left">较低，涉及事务回查等操作</td><td>较高，通过定时任务和重试机制管理</td><td>较高，适合对性能要求高但不要求严格一致性的场景</td></tr></tbody></table></div></div><div class="kratos-copyright text-center clearfix"><h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5></div><footer class="kratos-entry-footer clearfix"><div class="post-like-donate text-center clearfix" id="post-like-donate"><a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a><div class="share-wrap" style="display:none"><div class="share-group"><a href="javascript:;" class="share-plain qq" onclick='share("qq")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-qq"></i></div></a><a href="javascript:;" class="share-plain qzone" onclick='share("qzone")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-star"></i></div></a><a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow"><div class="icon-wrap"><i class="fa fa-weixin"></i></div><div class="share-int"><div class="qrcode" id="wechat-qr"></div><p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p></div></a><a href="javascript:;" class="share-plain weibo" onclick='share("weibo")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-weibo"></i></div></a><a href="javascript:;" class="share-plain facebook style-plain" onclick='share("facebook")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-facebook"></i></div></a><a href="javascript:;" class="share-plain twitter style-plain" onclick='share("twitter")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-twitter"></i></div></a></div><script type="text/javascript">$(()=>{
            new QRCode("wechat-qr", {
                text: "https://moduokesi.top/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moduokesi.top/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/";
            const title         = "「【分布式】万字图文解析——深入七大分布式事务解决方案」";
            const excerpt       = `分布式事务
分布式事务是指跨多个独立服务或系统的事务管理，以确保这些服务中的数据变更要么全部成功，要么全部回滚，从而保证数据的一致性。在微服务架构和分布式系统中，由于业务逻辑往往会跨多个服务，传统的单体事务无法覆盖，因此需要通过分布...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };</script></div></div><div class="footer-tag clearfix"><div class="pull-left"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/2PC-3PC/" rel="tag">2PC/3PC</a>, <a class="tag-none-link" href="/tags/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" rel="tag">MQ事务消息</a>, <a class="tag-none-link" href="/tags/Saga/" rel="tag">Saga</a>, <a class="tag-none-link" href="/tags/TCC/" rel="tag">TCC</a>, <a class="tag-none-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a>, <a class="tag-none-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/" rel="tag">最大努力通知</a>, <a class="tag-none-link" href="/tags/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8/" rel="tag">本地消息表</a></div><div class="pull-date"><time datetime="2024-11-14T02:46:21.058Z" itemprop="dateModified">最后编辑：2024-11-14</time></div></div></footer></div><nav class="navigation post-navigation clearfix" role="navigation"><div class="nav-previous clearfix"><a title=" 【分布式】分布式锁设计与Redisson源码解析" href="/2024/11/05/【分布式】分布式锁设计/">&lt; 上一篇</a></div><div class="nav-next clearfix"><a title=" 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析" href="/2024/11/17/【设计模式】策略模式详解/">下一篇 &gt;</a></div></nav></article></section><section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm"><aside id="krw-about" class="widget widget-kratos-about clearfix"><div class="photo-background"></div><div class="photo-wrapper clearfix"><div class="photo-wrapper-tip text-center"><img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto"></div></div><div class="textwidget"><p class="text-center">华为云享专家<br>荣获多项国家级及省级荣誉<br>欢迎访问顶栏"链接"，关注更多技术内容</p></div><div class="site-meta"><a class="meta-item" href="/archives/"><span class="title">文章 </span><span class="count">36 </span></a><a class="meta-item" href="/categories/"><span class="title">分类 </span><span class="count">13 </span></a><a class="meta-item" href="/tags/"><span class="title">标签 </span><span class="count">50</span></a></div></aside><div class="sticky-area"><aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class"><div class="photo-background"></div><h4 class="widget-title no-after"><i class="fa fa-compass"></i> 文章目录 <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span></h4><div class="textwidget"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-text">刚性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">两阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">三阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5-1"><span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">预提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5-1"><span class="toc-text">提交阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-text">柔性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcc"><span class="toc-text">TCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="toc-text">典型示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-1"><span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">MQ事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-text">本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-2"><span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-1"><span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saga"><span class="toc-text">Saga</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E5%BC%8F"><span class="toc-text">协调式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E6%8E%92%E5%BC%8F"><span class="toc-text">编排式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-text">最大努力通知</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-text">事务对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcc%E5%92%8C2pc3pc"><span class="toc-text">TCC和2PC&#x2F;3PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-text">MQ事务消息&amp;本地消息表&amp;最大努力通知</span></a></li></ol></li></ol></div></aside><aside id="krw-categories" class="widget widget-kratos-categories clearfix"><h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">常用集合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a><span class="category-list-count">5</span></li></ul></aside><aside id="krw-tags" class="widget widget-kratos-tags clearfix"><h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4><div class="tag-clouds"><a href="/tags/2PC-3PC/" style="font-size:.6em">2PC/3PC</a> <a href="/tags/AOF/" style="font-size:.6em">AOF</a> <a href="/tags/AQS%E6%9C%BA%E5%88%B6/" style="font-size:.6em">AQS机制</a> <a href="/tags/ConcurrentHashMap/" style="font-size:.6em">ConcurrentHashMap</a> <a href="/tags/CountDownLatch/" style="font-size:.6em">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size:.6em">CyclicBarrier</a> <a href="/tags/HashMap/" style="font-size:.6em">HashMap</a> <a href="/tags/JIT/" style="font-size:.6em">JIT</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size:.6em">Java内存区域</a> <a href="/tags/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" style="font-size:.6em">MQ事务消息</a> <a href="/tags/MVCC/" style="font-size:.6em">MVCC</a> <a href="/tags/MapStruct/" style="font-size:.6em">MapStruct</a> <a href="/tags/RDB/" style="font-size:.6em">RDB</a> <a href="/tags/RabbitMQ/" style="font-size:.8em">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:.6em">Redis</a> <a href="/tags/Redisson/" style="font-size:.6em">Redisson</a> <a href="/tags/ReentrantLock/" style="font-size:.6em">ReentrantLock</a> <a href="/tags/Saga/" style="font-size:.6em">Saga</a></div></aside><aside id="krw-posts" class="widget widget-kratos-posts"><h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4><div class="tab-content"><ul class="list-group"><a class="list-group-item" href="/2024/11/17/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa fa-book"></i> 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析</a> <a class="list-group-item" href="/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 【分布式】万字图文解析——深入七大分布式事务解决方案</a> <a class="list-group-item" href="/2024/11/05/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1/"><i class="fa fa-book"></i> 【分布式】分布式锁设计与Redisson源码解析</a> <a class="list-group-item" href="/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"><i class="fa fa-book"></i> 【SpringBoot】源码解析——启动流程</a> <a class="list-group-item" href="/2024/10/26/%E3%80%90SpringBoot%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%8Estarter%E6%9C%BA%E5%88%B6/"><i class="fa fa-book"></i> 【SpringBoot】源码解析——自动装配与starter机制</a></ul></div></aside></div></section></div></div></div><footer><div id="footer" class="ap-lrc"><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 footer-list text-center"><ul class="kratos-social-icons"><li><a target="_blank" rel="nofollow" href="https://weibo.com/u/https://weibo.com/u/7728377351"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:modoxlixin@outlook.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="nofollow" href="https://github.com/moduokesi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><ul class="kratos-copyright"><div><li>&copy; 2024 Modox's blog 版权所有.</li><li>本站已运行<span id="span_dt">Loading...</span></li></div><div><li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li><li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Modox.</li></div><div><li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li><li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li></div><div></div></ul></div></div></div><div class="kr-tool text-center"><div class="tool"><div class="box search-box"><a href="/search/"><span class="fa fa-search"></span></a></div><div class="box theme-box" id="darkmode-switch"><span class="fa fa-adjust"></span></div></div><div class="box gotop-box"><span class="fa fa-chevron-up"></span></div></div></div></footer></div></div><script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script><script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script><script>window.kr||(window.kr={}),window.kr.notMobile=!navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),window.kr.siteRoot="/"</script><div><canvas id="snow"></canvas><script async src="/js/snow.min.js"></script></div><script async src="/js/candy.min.js"></script><script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script><script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="3204190542" order="random" fixed="true"></meting-js><script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/kratosr.min.js"></script><script defer src="/js/pjax.min.js"></script></body></html>