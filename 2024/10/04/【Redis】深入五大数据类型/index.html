<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><link rel="icon" href="/images/logo.png"><title>【Redis】深入五大数据类型 | Modox&#39;s blog</title><meta name="author" content="Modox"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="format-detection" content="telphone=no, email=no"><meta name="keywords" content="数据结构"><meta name="description" content="数据结构 简单动态字符串（SDS） Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串。 C语言字符串 C 语言的字符串不足之处以及可以改进的地方：  获取字符串长度的时间复杂度为 O（N）； 字符串的结尾是以 “\0"><meta property="og:type" content="article"><meta property="og:title" content="【Redis】深入五大数据类型"><meta property="og:url" content="https://moduokesi.top/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html"><meta property="og:site_name" content="Modox&#39;s blog"><meta property="og:description" content="数据结构 简单动态字符串（SDS） Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串。 C语言字符串 C 语言的字符串不足之处以及可以改进的地方：  获取字符串长度的时间复杂度为 O（N）； 字符串的结尾是以 “\0"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://moduokesi.top/images/logo.png"><meta property="article:published_time" content="2024-10-04T09:21:43.000Z"><meta property="article:modified_time" content="2024-10-04T09:22:25.227Z"><meta property="article:author" content="Modox"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://moduokesi.top/images/logo.png"><link rel="alternate" href="atom.xml" type="application/atom+xml"><link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"><link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme:dark)"><script src="/js/kr-dark.min.js"></script><link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"><link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"><link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"><link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script><script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script><style>.kratos-cover.kratos-cover-2{background-image:url(/images/banner.webp)}@media(min-width:768px){body.custom-background{background-image:url(/images/bg.webp)}}</style><meta name="generator" content="Hexo 6.2.0"></head><body class="custom-background"><div id="kratos-wrapper"><div id="kratos-page"><div id="kratos-header"><header id="kratos-desktop-topnav" class="kratos-topnav"><div class="container"><div class="nav-header"><nav id="kratos-menu-wrap"><ul id="kratos-primary-menu" class="sf-menu"><li><a href="/"><i class="fa fa-home"></i> 首页</a></li><li><a href="/archives/"><i class="fa fa-file"></i> 档案馆</a></li><li><a><i class="fa fa-paw"></i> 友站</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://penty7710.github.io/">pety's blog</a></li></ul></li><li><a><i class="fa fa-link"></i> 链接</a><ul class="sub-menu"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/k123456kah?type=blog">CSDN</a></li><li><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/community/usersnew/id_1670078149364456">华为云</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/moduokesi_admin">Gitee</a></li><li><a target="_blank" rel="noopener" href="https://github.com/moduokesi">GitHub</a></li></ul></li></ul></nav></div></div></header><header id="kratos-mobile-topnav" class="kratos-topnav"><div class="container"><div class="color-logo"><a href="/">Modox&#39;s blog</a></div><div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div></div></header></div><div class="kratos-start kratos-hero-2"><div class="kratos-cover kratos-cover-2 text-center"><div class="desc desc2 animate-box"><a href="/"><h2>Modox&#39;s blog</h2><br><span></span></a></div></div></div><div id="kratos-blog-post"><div class="container"><div id="main" class="row"><section class="col-md-8"><article itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://moduokesi.top/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><div class="kratos-hentry kratos-post-inner clearfix"><header class="kratos-entry-header"><h1 class="kratos-entry-title text-center" itemprop="name headline">【Redis】深入五大数据类型</h1><ul class="kratos-post-meta text-center"><li><time datetime="2024-10-04T09:21:43.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-10-04</time></li><li itemprop="author" itemscope itemtype="https://schema.org/Person"><i class="fa fa-user"></i> 作者 <span itemprop="name">Modox</span></li><li><i class="fa fa-edit"></i> ~13.36K 字</li></ul></header><div class="kratos-post-content"><div id="expire-alert" class="alert alert-warning hidden" role="alert"><div class="icon"><i class="fa fa-warning"></i></div><div class="text"><p>本文最后编辑于 <time datetime="1728033745227"></time> 前，其中的内容可能需要更新。</p></div></div><div class="kratos-post-inner-toc toc-div-class"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds"><span class="toc-number">1.1.</span> <span class="toc-text">简单动态字符串（SDS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">C语言字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">动态扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88intset"><span class="toc-number">1.2.</span> <span class="toc-text">整数集合（IntSet）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%8D%87%E7%BA%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">编码升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8dict"><span class="toc-number">1.3.</span> <span class="toc-text">字典（Dict）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-number">1.3.3.</span> <span class="toc-text">rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9-1"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">动态扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BC%A9%E5%AE%B9"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">动态缩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">渐进式rehash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict%E4%B8%8Ehashmap"><span class="toc-number">1.3.4.</span> <span class="toc-text">Dict与HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dict"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Dict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">HashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist"><span class="toc-number">1.4.</span> <span class="toc-text">压缩列表（ZipList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-number">1.4.2.</span> <span class="toc-text">encoding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">连锁更新问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8quicklist"><span class="toc-number">1.5.</span> <span class="toc-text">快速列表（QuickList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">压缩列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">限制大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E4%BD%8D%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.5.4.</span> <span class="toc-text">首位压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8skiplist"><span class="toc-number">1.6.</span> <span class="toc-text">跳表（SkipList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">插入过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">删除过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">1.6.5.</span> <span class="toc-text">跳表与平衡树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listpack"><span class="toc-number">1.7.</span> <span class="toc-text">listpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">常见数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisobject"><span class="toc-number">2.2.</span> <span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">2.3.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">2.4.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">2.5.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zset"><span class="toc-number">2.6.</span> <span class="toc-text">ZSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-number">2.7.</span> <span class="toc-text">Hash</span></a></li></ol></li></ol></div><hr><div itemprop="articleBody"><h1 id="数据结构">数据结构</h1><h2 id="简单动态字符串sds">简单动态字符串（SDS）</h2><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为<strong>简单动态字符串（simple dynamic string，SDS）</strong> 的数据结构来表示字符串。</p><h3 id="c语言字符串">C语言字符串</h3><p>C 语言的字符串不足之处以及可以改进的地方：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面<strong>不能包含 “\0” 字符</strong>，因此<strong>不能保存二进制数据</strong>；</li><li>字符串<strong>操作函数不高效且不安全</strong>，比如有缓冲区溢出的风险，有可能会造成程序运行终止。比如函数<code>char *strcat(char *dest, const char* src);</code>，可能会超出dest字符串长度。</li></ul><h3 id="结构设计">结构设计</h3><p>前三个属性len、alloc和flags都是结构体的头信息，只有buf字段才真正存储数据。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408121413066.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;   <span class="comment">/* buf已保存的字符串字节数，不包含结束标示*/</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* buf申请的总的字节数，不包含结束标示*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/*不同SDS的头类型，用来控制SDS的头大小*/</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构中的每个成员变量分别介绍下：</p><ul><li><p><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</p></li><li><p><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</p></li><li><p><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p></li><li><p><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</p></li></ul><p><code>flags</code>字段的前3位用于表示SDS的类型：</p><ul><li><strong>SDS_TYPE_5</strong> (<code>000</code>): 使用5位存储长度信息，适用于长度较小的字符串。</li><li><strong>SDS_TYPE_8</strong> (<code>001</code>): 使用1个字节（8位）存储长度信息。</li><li><strong>SDS_TYPE_16</strong> (<code>010</code>): 使用2个字节（16位）存储长度信息。</li><li><strong>SDS_TYPE_32</strong> (<code>011</code>): 使用4个字节（32位）存储长度信息。</li><li><strong>SDS_TYPE_64</strong> (<code>100</code>): 使用8个字节（64位）存储长度信息。</li></ul><h3 id="动态扩容">动态扩容</h3><p>当追加的字符串超过分配的空间时，会触发扩容机制：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的<code>两倍 + 1</code>（+1是为了保存一个结束标识<code>'\0'</code>）</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度<code>+ 1M + 1</code>。称为内存预分配。</li></ul><blockquote><p><strong>示例：</strong>初始有一个内容为"hi"的SDS，加上字符串",Amy"，新字符串长度小于1M，扩容为原本的2倍+1</p></blockquote><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408121431595.png"></p><h2 id="整数集合intset">整数集合（IntSet）</h2><p><strong>整数集合是 Set 对象的实现方式之一。</strong>具备长度可变、有序等特征，当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用<code>Intset</code>这个数据结构作为底层实现。</p><h3 id="结构设计-1">结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">/* 编码方式，支持存放16位、32位、64位整数*/</span></span><br><span class="line">    <span class="type">uint32_t</span> length;   <span class="comment">/* 元素个数 */</span></span><br><span class="line">    <span class="type">int8_t</span> contents[]; <span class="comment">/* 整数数组，保存集合数据*/</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding的三种模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET ENC INT16 &lt;INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16(sizeof(int16_t)) <span class="comment">/* 2字节整数，范围类似java的short*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32(sizeof(int32_t)) <span class="comment">/* 4字节整数，范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64(sizeof(int64_t)) <span class="comment">/* 8字节整数，范围类似java的long */</span></span></span><br></pre></td></tr></table></figure><h3 id="编码升级">编码升级</h3><p>当向<code>intset</code>中插入一个新整数且该整数超过了当前编码类型的范围时，<code>intset</code>会自动进行编码升级。</p><p>现在，假设有一个intset，元素为{5，10，20}，采用的编码是<code>INTSET_ENC_INT16</code>，则每个整数占2字节。我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122340043.png"></p><p>以当前案例来说流程如下:</p><ol type="1"><li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占4字节，并<strong>按照新的编码方式及元素个数扩容数组</strong></li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li></ol><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122339574.png"></p><h2 id="字典dict">字典（Dict）</h2><p>Redis本身就是一个键值型的数据库，其核心就是通过高效的方式来存储和检索键值对。在Redis的内部，键值对的存储和管理依赖于一种叫做<code>Dict</code>（字典）的数据结构。</p><h3 id="结构设计-2">结构设计</h3><p>Dict由三部分组成，分别是：哈希表(DictHashTable)、哈希节点(DictEntry)、字典(Dict)</p><p><strong>哈希表：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">	<span class="comment">// entry数组，数组中保存的是指向entry的指针</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">	<span class="comment">// 哈希表大小，即哈希表桶（bucket）的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="comment">// 哈希表大小的掩码，等于size -1</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">	<span class="comment">// 哈希表元素的个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p><strong>哈希节点：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *key;	<span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;		<span class="comment">//值</span></span><br><span class="line">    <span class="comment">//下一个Entry的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><strong>字典：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// dic类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata; <span class="comment">// 私有数据，在做特殊hash运算时用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">// rehash的进度，-1表示未进行</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;<span class="comment">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271752927.webp"></p><h3 id="添加元素">添加元素</h3><p>当利用Dict添加元素时，Redis首先会根据key计算出hash值，然后利用哈希值对长度取余<code>hash % size</code>获取哈希表的下标。</p><p>当<code>size</code>的长度为2的倍数时，满足公式：<code>hash % size == hash &amp; (sizemask)</code>。由于位运算可直接在内存进行操作，不需要转为十进制，所以性能更好。</p><blockquote><p><strong>公式解释：</strong>当哈希表的长度为2的倍数时，哈希表大小的掩码<code>sizemask</code>的二进制表示必然是多个1组成的<code>1111</code>，而1按位与任何数，都为数本身，所以可以达到对hash值取余的效果。</p></blockquote><p>当有元素添加进来时，采用头插法插入元素，头插法的时间复杂度为 O(1)，能够在哈希冲突发生时迅速将新元素插入到链表中。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408122215101.png"></p><h3 id="rehash">rehash</h3><h4 id="动态扩容-1">动态扩容</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次增加键值对时都会检查<strong>负载因子（哈希表中元素的数量与哈希表桶数量的比值）</strong><code>LoadFactor = used/size</code>，满足以下三 种情况时会触发<strong>哈希表扩容</strong>。</p><ul><li>负载因子<code>LoadFactor &gt;= 1</code>，并且服务器没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>等后台进程；</li><li>负载因子<code>LoadFactor &gt; 5</code>；</li></ul><p><strong>当Dict执行扩容时，需要扩容到第一个大于等于<code>used + 1</code>（哈希表中元素个数 + 1）的2 ^ n。</strong></p><h4 id="动态缩容">动态缩容</h4><p>满足以下情况时，触发<strong>哈希表缩容</strong>。</p><ul><li>负载因子<code>LoadFactor &lt; 0.1</code>，会触发哈希表缩容</li></ul><p><strong>当Dict执行缩容时，需要缩容到第一个大于等于<code>used</code>（哈希表中元素个数）的2 ^ n，但不能小于初始大小4。</strong></p><h4 id="渐进式rehash">渐进式rehash</h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的:</p><ol type="1"><li>计算新hash表的size，值取决于当前要做的是扩容还是收缩:<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used+1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n(不得小于4)</li></ul></li><li>按照新的size申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx=0，标示开始rehash</li><li><strong>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]桶上的所有元素rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]中。</strong></li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li><strong>将rehashidx赋值为-1，代表rehash结束</strong></li><li><strong>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht{0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</strong></li></ol><h3 id="dict与hashmap">Dict与HashMap</h3><h4 id="dict">Dict</h4><ul><li><strong>负载因子为5时扩容</strong>：较高的负载因子可以使得哈希表桶的数据更加紧凑，提高内存利用率；较高的负载因子可以减少扩容频率，减少资源消耗；在负载因子为 5 时，哈希表桶的链表相对较短，仍能保证相对较快的查找效率。</li><li>在负载因子较高时扩容，字典的空间利用率更高，这对于减少内存开销很有帮助。而在负载因子为5时，哈希冲突虽然较多，但Redis通过链表等机制处理冲突，依然能够保持较高的查询速度。</li><li><strong>渐进式rehash</strong>：Redis在扩容时采用渐进式rehash（渐进式重新哈希），逐步将旧表中的键值对迁移到新表中，以避免扩容时阻塞Redis的正常操作。因此，Redis可以在负载因子较高时继续工作，并在扩容过程中平滑地处理大量数据。</li><li><strong>单线程模型</strong>：Redis 是单线程处理模型，<code>Dict</code> 不需要处理线程安全问题。这使得 <code>Dict</code> 的操作可以更加简单和高效，因为不需要复杂的锁机制来同步多线程访问。</li><li><strong>链地址法</strong>：</li></ul><h4 id="hashmap">HashMap</h4><ul><li><strong>负载因子为0.75时扩容</strong>：<code>HashMap</code>在设计时追求在插入和查找操作之间的平衡。负载因子为0.75时，哈希冲突率较低，查找和插入性能较高，同时又避免了内存的浪费。</li><li><strong>即时扩容</strong>：与Redis不同，Java的<code>HashMap</code>在达到扩容阈值时会立即进行扩容操作，重新计算哈希值并将元素放置到新表中。这样做是为了保持插入和查找的性能，避免在高负载因子下，哈希冲突过多导致查询效率大幅下降。</li><li><strong>多线程环境</strong>：<code>HashMap</code> 本身不是线程安全的，在多线程环境中使用时可能会出现并发修改异常或数据不一致问题。为此，Java 提供了 <code>ConcurrentHashMap</code>，它使用分段锁（Java 7 之前）或 CAS 操作（Java 8 之后）来实现线程安全的哈希表。</li><li><strong>红黑树：</strong></li></ul><h2 id="压缩列表ziplist">压缩列表（ZipList）</h2><p><code>ZipList</code>是一种特殊的“双端链表”，由一系列特殊编码的<strong>连续内存块</strong>组成。可以在任意一端进行压入/弹出操作,并且该操作的时间复杂度为 0(1)。</p><h3 id="结构设计-3">结构设计</h3><p><strong>ZipList：</strong></p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141115497.png"></p><table><colgroup><col style="width:9%"><col style="width:11%"><col style="width:9%"><col style="width:69%"></colgroup><thead><tr class="header"><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr class="odd"><td>zlbytes</td><td><code>uint32_t</code></td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr class="even"><td>zltail</td><td><code>uint32_t</code></td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr class="odd"><td>zllen</td><td><code>uint16_t</code></td><td>2 字节</td><td>记录了压缩列表包含的节点数量。最大值为 <code>UINT16_MAX</code> (65534)，如果超过这个值，此处会记录为 <code>65535</code>，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr class="even"><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr class="odd"><td>zlend</td><td><code>uint8_t</code></td><td>1 字节</td><td>特殊值 <code>0xFF</code> (十进制 255)，用于标记压缩列表的末端。</td></tr></tbody></table><p><strong>ZipListEntry：</strong></p><p><code>ZipList</code>中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用下面的结构：</p><table><thead><tr class="header"><th>previous_entry_length</th><th>encoding</th><th>content</th></tr></thead><tbody></tbody></table><ul><li><strong>previous_entry_length</strong>：前一节点的长度，占1个或5个字节。<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保这个长度值，第一个字节为0xfe<code>标记采用5字节</code>，后四个字节才是真实长度数据</li></ul></li><li><strong>encoding</strong>：编码属性，记录content的数据类型(字符串还是整数)以及长度，占用1个、2个或5个字节</li><li><strong>contents</strong>：负责保存节点的数据，可以是字符串或整数</li></ul><h3 id="encoding">encoding</h3><p><code>ZipListEntry</code>中的encoding编码分为字符串和整数两种，<strong>编码格式采用十六进制</strong>。</p><h4 id="字符串">字符串</h4><p>如果encoding是以"00"、"01"或者"10"开头，则证明content是字符串</p><table><colgroup><col style="width:63%"><col style="width:15%"><col style="width:21%"></colgroup><thead><tr class="header"><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>字符串大小</strong></th></tr></thead><tbody><tr class="odd"><td><code>|00pppppp|</code></td><td>1bytes</td><td>最大长度为2^6-1</td></tr><tr class="even"><td><code>|01pppppp|qqqqqqqq|</code></td><td>2 bytes</td><td>最大长度为2^14-1</td></tr><tr class="odd"><td><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</code></td><td>5 bytes</td><td>最大长度为2^32-1</td></tr></tbody></table><p>例如，如果需要保存字符串"ab"和"bc"，abc的ASCII码从<code>97</code>依次递增</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141146414.png"></p><h4 id="整数">整数</h4><p>如果encoding是以"11"开始，则证明content是整数，且encoding固定只占用1个字节</p><table><colgroup><col style="width:12%"><col style="width:14%"><col style="width:73%"></colgroup><thead><tr class="header"><th>编码</th><th><strong>编码长度</strong></th><th><strong>整数类型</strong></th></tr></thead><tbody><tr class="odd"><td><code>11000000</code></td><td>1</td><td><code>int16_t</code> (2 bytes)</td></tr><tr class="even"><td><code>11010000</code></td><td>1</td><td><code>int32_t</code> (4 bytes)</td></tr><tr class="odd"><td><code>11100000</code></td><td>1</td><td><code>int64_t</code> (8 bytes)</td></tr><tr class="even"><td><code>11110000</code></td><td>1</td><td>24位有符整数 (3 bytes)</td></tr><tr class="odd"><td><code>11111110</code></td><td>1</td><td>8位有符整数 (1 byte)</td></tr><tr class="even"><td><code>1111xxxx</code></td><td>1</td><td>省去content字段，直接在<code>xxxx</code>位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><p>例如，如果需要保存整数"2"和"6"，省去content字段直接存储。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141159233.png"></p><h3 id="连锁更新问题">连锁更新问题</h3><p><strong>previous_entry_length</strong>：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于等于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保这个长度值，第一个字节为0xfe<code>标记采用5字节</code>，后四个字节才是真实长度数据</li></ul><p>假设压缩列表有多个连续的、长度为250~253字节之间的entry，因此节点的<code>previous_entry_length</code>属性用1个字节即可表示，如图所示：</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271753637.webp"></p><p>此时如果添加一个新的节点，长度超过了254字节，就会导致<code>e1</code>节点的<code>previous_entry_length</code>属性更新，采用5字节，从而导致后续的节点产生连锁更新的现象。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408141209157.png"></p><h2 id="快速列表quicklist">快速列表（QuickList）</h2><h3 id="压缩列表">压缩列表</h3><p>压缩列表有以下缺点：</p><ul><li><code>ZipList</code>虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低（找不到内存碎片）。</li><li><code>ZipList</code>存在连锁更新问题，元素越多越可能发生连锁更新问题。</li></ul><h3 id="结构设计-4">结构设计</h3><p><strong>quickList：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head:</span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail.</span><br><span class="line">    <span class="comment">// 所有的压缩列表的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// 压缩列表的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271754114.webp"></p><h3 id="限制大小">限制大小</h3><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code>来限制，默认值为-2。</p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况</li></ul><h3 id="首位压缩">首位压缩</h3><p>除了控制ZipList的大小，<code>QuickList</code>还可以对节点的ZipList做压缩。通过配置项<code>list-compress-depth</code>来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p><ul><li>0:特殊值，代表不压缩</li><li>1:标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li><li>2:标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li><li>以此类推</li></ul><h2 id="跳表skiplist">跳表（SkipList）</h2><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><h3 id="结构设计-5">结构设计</h3><p><strong>zskiplist：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">//最大的索引层级，默认是1</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755442.webp"></p><p><strong>zskiplistNode：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;<span class="comment">// 节点存储的值</span></span><br><span class="line">    doble score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//下一个节点指针</span></span><br><span class="line">    	<span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">//索引跨度</span></span><br><span class="line">	&#125; level[];<span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode:</span><br></pre></td></tr></table></figure><p>ZSet 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 sds 类型的 <strong>ele 变量</strong>和 double 类型的 <strong>score 变量</strong>。每个跳表节点都有一个后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度用来记录两个节点之间的距离。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755771.webp"></p><p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p><p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L2），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。</p><h3 id="查询过程">查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li><strong>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</strong></li><li><strong>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</strong></li><li><strong>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</strong></li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271755725.webp"></p><p>如果需要查找「元素：abcd，权重：4」的节点，查找过程如下：</p><ol type="1"><li>先从头结点最高层开始，L2指向了「元素：abc，权重：3」节点，先查询该节点</li><li>由于该层下一节点为NULL，所以跳到下一层，也就是「元素：abc，权重：3」节点的<code>level[1]</code>层</li><li><code>level[1]</code>层的下一节点是「元素：abcde，权重：4」，当前的权重等于查找的权重，但是当前的元素大于查询的元素（abcde &gt; abcd），所以跳转到下一层，也就是「元素：abc，权重：3」节点的<code>level[0]</code>层</li><li>查询到「元素：abcd，权重：4」，正是要查询的节点，直接返回。</li></ol><h3 id="插入过程">插入过程</h3><p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong>。</p><p>具体的做法是，<strong>跳表在添加节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>插入一个新节点到跳表中，通常会涉及以下步骤：</p><ol type="1"><li><strong>查找插入位置</strong>：<ul><li>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li><li>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</li></ul></li><li><strong>随机生成层数</strong>：在跳表中，新节点的层数是随机生成的。层数越高，新节点的概率越低。</li><li><strong>插入新节点</strong>：<ul><li>更新与新节点相关的前驱节点和后继节点的指针，以保持跳表的正确性。</li><li>如果插入的层数比当前跳表的最大层数要高，那么需要更新跳表的头节点层数。</li></ul></li></ol><h3 id="删除过程">删除过程</h3><ol type="1"><li><strong>查找删除位置</strong>：<ul><li>如果下一节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果下一节点的权重「等于」要查找的权重时，并且下一节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li><li>如果上面两个条件都不满足，或者下一个节点为空时，跳到当前节点的下一层。</li></ul></li><li><strong>删除新节点</strong>：<ul><li>更新与原有节点相关的前驱节点和后继节点的指针，以保持跳表的正确性。</li><li>如果删除后的层数比当前跳表的最大层数要低，那么需要更新跳表的头节点层数。</li></ul></li></ol><h3 id="跳表与平衡树">跳表与平衡树</h3><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li></ul><h2 id="listpack">listpack</h2><p><code>listpack</code>的目的是替代压缩列表，它的最大特点是 listpack 中<strong>每个节点不再包含前一个节点的长度</strong>，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408271756703.webp"></p><p>主要包含三个方面内容:</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码</li><li>data，实际存放的数据:</li><li>len，encoding+data的总长度:</li></ul><p>可以看到，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p><h1 id="数据类型">数据类型</h1><h2 id="常见数据类型">常见数据类型</h2><p>Redis 中比较常见的数据类型有下面这些：</p><ul><li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Hash（散列）、Set（集合）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142246546.png"></p><h2 id="redisobject">RedisObject</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象。</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142124669.png"></p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。encoding的编码方式如下：</p><table><thead><tr class="header"><th>数据类型</th><th>对应编码方式</th></tr></thead><tbody><tr class="odd"><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr class="even"><td>OBJ_LIST</td><td>LinkedList + ZipList（3.2以前）、QuickList（3.2以后）</td></tr><tr class="odd"><td>OBJ_SET</td><td>IntSet、HT</td></tr><tr class="even"><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr class="odd"><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table><h2 id="string">String</h2><p>String 是最基本的<code>key-value</code>结构，key 是唯一标识，value 是具体的值。value不一定是字符串，也可以是数字(整数或浮点数)，value 最多可以容纳的数据长度是 512M。</p><ul><li><strong>其基本编码方式是<code>RAW</code></strong>，基于简单动态字符串(SDS)实现，存储上限为512mb。</li><li><strong>如果存储的SDS长度小于44字节，则会采用<code>EMBSTR</code>编码</strong>，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li><li><strong>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<code>INT</code>编码</strong>，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不再需要SDS了。</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142135149.png"></p><h2 id="list">List</h2><p>List 结构类似一个双端链表，可以从首、尾操作列表中的元素。</p><ul><li>在3.2版本之前，Redis采用<code>LinkedList</code>和<code>ZipList</code>编码来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码</li><li>在3.2版本之后，Redis统一采用<code>QuickList</code>编码来实现List</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142147783.png"></p><h2 id="set">Set</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><ul><li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用<code>IntSet</code>编码，以节省内存。</li><li>为了查询效率和唯一性，Set采用<code>HT</code>编码(Dict)。Dict中的key用来存储元素，value统一为null</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142155798.png"></p><h2 id="zset">ZSet</h2><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值。ZSet底层数据结构必须满足<strong>键值存储</strong>、<strong>键必须唯一</strong>、<strong>可排序</strong>这几个需求，所以需要同时采用<code>SkipList</code>和<code>HT</code>这两种编码。</p><ul><li><code>SkipList</code>：可以排序，并且可以同时存储score和ele值(member)</li><li><code>HT</code>：可以键值存储，并且可以根据key找value</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142200431.png"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此ZSet还会采用<code>ZipList</code>编码来节省内存，不过需要同时满足两个条件:</p><ul><li>元素数量小于zset_max_ziplist_entries(默认值128)</li><li>每个元素都小于zset_max_ziplist_value(默认值64字节)</li></ul><p>ZipList本身没有排序功能，而且没有键值对的概念，通过编码实现:</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142204860.png"></p><h2 id="hash">Hash</h2><p>Hash结构默认采用<code>ZipList</code>编码，用以节省内存。ZipList中相邻的两个entry分别保存field和value</p><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142212999.png"></p><p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个:</p><ul><li>ZipList中的元素数量超过了hash-max-ziplist-entries(默认512)</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value(默认64字节)</li></ul><p><img src="https://modox.oss-cn-hangzhou.aliyuncs.com/img/202408142213898.png"></p></div></div><div class="kratos-copyright text-center clearfix"><h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5></div><footer class="kratos-entry-footer clearfix"><div class="post-like-donate text-center clearfix" id="post-like-donate"><a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a><div class="share-wrap" style="display:none"><div class="share-group"><a href="javascript:;" class="share-plain qq" onclick='share("qq")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-qq"></i></div></a><a href="javascript:;" class="share-plain qzone" onclick='share("qzone")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-star"></i></div></a><a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow"><div class="icon-wrap"><i class="fa fa-weixin"></i></div><div class="share-int"><div class="qrcode" id="wechat-qr"></div><p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p></div></a><a href="javascript:;" class="share-plain weibo" onclick='share("weibo")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-weibo"></i></div></a><a href="javascript:;" class="share-plain facebook style-plain" onclick='share("facebook")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-facebook"></i></div></a><a href="javascript:;" class="share-plain twitter style-plain" onclick='share("twitter")' rel="nofollow"><div class="icon-wrap"><i class="fa fa-twitter"></i></div></a></div><script type="text/javascript">$(()=>{
            new QRCode("wechat-qr", {
                text: "https://moduokesi.top/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moduokesi.top/2024/10/04/%E3%80%90Redis%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/";
            const title         = "「【Redis】深入五大数据类型」";
            const excerpt       = `数据结构
简单动态字符串（SDS）
Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char*
字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple
dynamic string，SDS）...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };</script></div></div><div class="footer-tag clearfix"><div class="pull-left"><i class="fa fa-tags"></i> <a class="tag-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></div><div class="pull-date"><time datetime="2024-10-04T09:22:25.227Z" itemprop="dateModified">最后编辑：2024-10-04</time></div></div></footer></div><nav class="navigation post-navigation clearfix" role="navigation"><div class="nav-previous clearfix"><a title=" 【常用集合】深入浅出Map集合" href="/2024/09/29/【常用集合】深入浅出Map集合/">&lt; 上一篇</a></div><div class="nav-next clearfix"><a title=" 【SpringBoot】源码解析——自动装配与starter机制" href="/2024/10/26/【SpringBoot】源码解析——自动装配与starter机制/">下一篇 &gt;</a></div></nav></article></section><section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm"><aside id="krw-about" class="widget widget-kratos-about clearfix"><div class="photo-background"></div><div class="photo-wrapper clearfix"><div class="photo-wrapper-tip text-center"><img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto"></div></div><div class="textwidget"><p class="text-center">华为云享专家<br>荣获多项国家级及省级荣誉<br>欢迎访问顶栏"链接"，关注更多技术内容</p></div><div class="site-meta"><a class="meta-item" href="/archives/"><span class="title">文章 </span><span class="count">39 </span></a><a class="meta-item" href="/categories/"><span class="title">分类 </span><span class="count">13 </span></a><a class="meta-item" href="/tags/"><span class="title">标签 </span><span class="count">54</span></a></div></aside><div class="sticky-area"><aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class"><div class="photo-background"></div><h4 class="widget-title no-after"><i class="fa fa-compass"></i> 文章目录 <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span></h4><div class="textwidget"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds"><span class="toc-text">简单动态字符串（SDS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">C语言字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-text">动态扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88intset"><span class="toc-text">整数集合（IntSet）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%8D%87%E7%BA%A7"><span class="toc-text">编码升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8dict"><span class="toc-text">字典（Dict）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-2"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-text">rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9-1"><span class="toc-text">动态扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BC%A9%E5%AE%B9"><span class="toc-text">动态缩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-text">渐进式rehash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict%E4%B8%8Ehashmap"><span class="toc-text">Dict与HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dict"><span class="toc-text">Dict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap"><span class="toc-text">HashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist"><span class="toc-text">压缩列表（ZipList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-3"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-text">encoding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-text">整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-text">连锁更新问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8quicklist"><span class="toc-text">快速列表（QuickList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-text">压缩列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-4"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%A4%A7%E5%B0%8F"><span class="toc-text">限制大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E4%BD%8D%E5%8E%8B%E7%BC%A9"><span class="toc-text">首位压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8skiplist"><span class="toc-text">跳表（SkipList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-5"><span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">插入过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="toc-text">删除过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">跳表与平衡树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listpack"><span class="toc-text">listpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisobject"><span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zset"><span class="toc-text">ZSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-text">Hash</span></a></li></ol></li></ol></div></aside><aside id="krw-categories" class="widget widget-kratos-categories clearfix"><h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81/">Spring源码</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">常用集合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a><span class="category-list-count">6</span></li></ul></aside><aside id="krw-tags" class="widget widget-kratos-tags clearfix"><h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4><div class="tag-clouds"><a href="/tags/2PC-3PC/" style="font-size:.6em">2PC/3PC</a> <a href="/tags/AOF/" style="font-size:.6em">AOF</a> <a href="/tags/AQS%E6%9C%BA%E5%88%B6/" style="font-size:.6em">AQS机制</a> <a href="/tags/ConcurrentHashMap/" style="font-size:.6em">ConcurrentHashMap</a> <a href="/tags/CountDownLatch/" style="font-size:.6em">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size:.6em">CyclicBarrier</a> <a href="/tags/HashMap/" style="font-size:.6em">HashMap</a> <a href="/tags/JIT/" style="font-size:.6em">JIT</a> <a href="/tags/JWT/" style="font-size:.6em">JWT</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size:.6em">Java内存区域</a> <a href="/tags/MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" style="font-size:.6em">MQ事务消息</a> <a href="/tags/MVCC/" style="font-size:.6em">MVCC</a> <a href="/tags/MapStruct/" style="font-size:.6em">MapStruct</a> <a href="/tags/RDB/" style="font-size:.6em">RDB</a> <a href="/tags/RabbitMQ/" style="font-size:.8em">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:.8em">Redis</a> <a href="/tags/Redisson/" style="font-size:.6em">Redisson</a> <a href="/tags/ReentrantLock/" style="font-size:.6em">ReentrantLock</a></div></aside><aside id="krw-posts" class="widget widget-kratos-posts"><h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4><div class="tab-content"><ul class="list-group"><a class="list-group-item" href="/2025/03/15/%E3%80%90SpringBoot%E3%80%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94JWT%E7%BB%93%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E5%8F%8CToken%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"><i class="fa fa-book"></i> 【SpringBoot】最佳实践——JWT结合Redis实现双Token无感刷新</a> <a class="list-group-item" href="/2025/01/25/%E3%80%90Linux%E6%89%AB%E7%9B%B2%E3%80%91Vim%E5%91%BD%E4%BB%A4%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%9F%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%AF%B9%E4%BA%86%EF%BC%81Vim%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"><i class="fa fa-book"></i> 【Linux扫盲】Vim命令不会用？看这篇就对了！Vim最佳实践参考手册</a> <a class="list-group-item" href="/2024/12/22/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8FID/"><i class="fa fa-book"></i> 【分布式】一文详解五大分布式ID实现方案</a> <a class="list-group-item" href="/2024/11/17/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa fa-book"></i> 【策略模式】最佳实践——Spring IoC实现策略模式全流程深度解析</a> <a class="list-group-item" href="/2024/11/14/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 【分布式】万字图文解析——深入七大分布式事务解决方案</a></ul></div></aside></div></section></div></div></div><footer><div id="footer" class="ap-lrc"><div class="container"><div class="row"><div class="col-md-6 col-md-offset-3 footer-list text-center"><ul class="kratos-social-icons"><li><a target="_blank" rel="nofollow" href="https://weibo.com/u/https://weibo.com/u/7728377351"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:modoxlixin@outlook.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="nofollow" href="https://github.com/moduokesi"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><ul class="kratos-copyright"><div><li>&copy; 2025 Modox's blog 版权所有.</li><li>本站已运行<span id="span_dt">Loading...</span></li></div><div><li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li><li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Modox.</li></div><div><li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li><li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li></div><div></div></ul></div></div></div><div class="kr-tool text-center"><div class="tool"><div class="box search-box"><a href="/search/"><span class="fa fa-search"></span></a></div><div class="box theme-box" id="darkmode-switch"><span class="fa fa-adjust"></span></div></div><div class="box gotop-box"><span class="fa fa-chevron-up"></span></div></div></div></footer></div></div><script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script><script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script><script>window.kr||(window.kr={}),window.kr.notMobile=!navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),window.kr.siteRoot="/"</script><div><canvas id="snow"></canvas><script async src="/js/snow.min.js"></script></div><script async src="/js/candy.min.js"></script><script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script><script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="3204190542" order="random" fixed="true"></meting-js><script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/kratosr.min.js"></script><script defer src="/js/pjax.min.js"></script></body></html>