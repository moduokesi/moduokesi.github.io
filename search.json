[{"title":"【IDEA结合Git实现项目管理实战】三、实战篇","date":"2023-12-15T04:01:20.000Z","url":"/2023/12/15/%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98/","tags":[["项目管理","/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"]],"categories":[["Git","/categories/Git/"]],"content":"【IDEA结合Git实现项目管理实战】三、实战篇 前言 本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。 本系列主讲如何具体操作，因此对于Git内部的原理将不会过多深究。 本文严禁任何形式的转载、搬运！ 本文作为该系列的实战篇，将正式介绍如何使用IDEA结合Git进行项目管理。 注意：本文假设你已经成功在IDEA中配置了git 在配置篇中，当我们已经在本地推送/克隆了一个项目后，我们能看到如下两个功能块。 在本文中，我们称红色箭头所指为git日志，蓝色箭头所指为git工具栏。 设置默认添加文件 还记得基础篇我们提到的四个工作区域吗？如果我们想要将变更的文件推送到远程仓库，我们首先需要先保证变更的文件在暂存区中。 在基础篇中，我们提到每当创建一个文件时，idea都会询问我们是否将文件添加到git，即是否添加到暂存区中。为了避免这种麻烦，我们打开设置，按以下流程选择无提示添加，这样idea就会默认将我们创建的文件自动添加到git了。 配置完该设置后，相当于每次创建文件都会默认执行git命令git add，作用是将文件添加到暂存区中。 推送更改的文件到本地库 当我们在本地完成了我们的工作后，我们可以先将变更的文件提交到本地库中保存。 这里我们点击蓝色箭头所指git工具栏的第二个按钮，即提交按钮。 该按钮对应git命令git commit，作用是将文件提交到本地库中。 这里我简单的修改了下我自己的更改，填写完提交信息后点击提交。 如果点击提交并推送的话，就可以直接将变更推送到远程仓库，省去了一个步骤。 提交并推送按钮对应git命令git commit &amp; git push，作用是将暂存区的变更直接推送到远程仓库 提交完毕后，我们打开git日志，能在当前的本地分支中看到我们刚才提交记录： 将本地库的提交记录推送到远程库中 当我们已经确定本地库的工作已经结束后，我们就可以将本地库的记录推送到远程库中。 我们点击git工具栏的第三个按钮，即推送按钮。 该按钮对应git命令git push，作用是将本地的提交记录推送到远程库中。 这里我准备了两个提交记录，按ctrl + 鼠标左键可以多选提交记录。 点击推送按钮后，我们可以在git日志中看到远程仓库中出现了我们刚才推送的提交记录。 此时我们打开gitee，可以发现提交记录同样生效于gitee中。 拉取远程分支的变更 当你的远程仓库发生改变时（你的队友推送了提交记录到远程仓库中），而你自己的远程分支不会自动拉取别人的提交记录，也就是说你的远程分支不具备别人的提交历史。 此时我们需要点击提取所有远程按钮，这时候就可以把远程仓库的所有本更拉取到自己的远程分支中。 提取所有远程按钮对应git命令git fetch，作用是将远程仓库的变更拉取到远程分支中。 这里我在gitee中手动添加了一个README.md文件。 点击按钮后，可以看到远程分支中增加了这条记录，同时，我们可以注意到本地分支名后出现了向下的蓝色箭头，这代表着当前远程分支已经更新了，本地分支也应该进行更新。 我们选中对应的本地分支，点击更新所选内容按钮，就可以把远程分支的提交记录添加到我们的本地分支中。 这里我们也可以选择git工具栏的第一个按钮，这样就可以指定方式传入变更。 该按钮对应git命令git merge或git rebase，作用是传入变更到当前分支 结果如下 新建分支 正常来说我们开发项目肯定不可能只用一个本地分支，一般会在其他分支中开发完毕后再推送到主分支中，这时候就需要新建分支的操作了。 分支可以简单的理解为我想基于这个提交以及它所有的父提交进行新的工作。当我们新建分支时，Git就会将HEAD指向的提交记录以及该提交记录之前的所有提交记录保存到新分支中。 如果我们要新建分支，可以点击左侧工具栏的加号按钮，这样就得到了一个新的分支。 该按钮对应git命令git branch，作用是基于当前提交历史创建新的分支。 新建后我们得到了一个全新的分支dev，他包含了master的全部提交历史。 当然，由于HEAD当前指向的是最后一个提交记录，所以新分支dev就包含了master的全部提交记录。如果我们要基于测试1这个提交历史创建分支的话，需要右键该提交历史，点击新建分支后再输入分支名并创建即可。 这样我们就得到了一个包含测试1之前所有提交记录的分支。 回到指定的提交历史 假设你当前开发的代码出现了问题，如何找回之前的代码？这时候就可以通过签出这一git提供功能回到之前的提交历史。当你签出到一个提交历史时，你就获取到了这个提交历史的所有代码。 注意：在签出前确保你当前的代码已经提交到了本地或者远程分支中，签出到其他提交记录时IDEA不会帮你自动保存当前的代码。 在签出的操作中，我们必须要明白HEAD这一概念，HEAD 是一个指向当前所在分支的指针，或者是指向当前所在提交记录的指针。在IDEA中，HEAD的位置可以通过黄色便签来看到，比如在下图master的提交历史中，HEAD指向的分支就是master，同时指向提交消息为add README.md.的提交记录。这里我们将下图称为图1。 如果我们要切换到测试1的提交历史上，右键测试1，点击签出修订。 签出修订按钮对应git命令git checkout，作用是将HEAD指针转移到当前分支/提交记录。 可以看到黄色便签转移到了测试1上，证明我们当前在测试1的提交历史上，这时我们就可以基于测试1的代码进行修改了。这里我们将下图称为图2。 但是这里有个问题，为什么图2在master分支上的黄色便签消失了？而在图1中黄色便签既指向了master又指向了最后一个提交记录add README.md. 这里要明白一个原理，那就是分支本身也能看作是一个指针，这个指针恒指向该分支的最后一个提交记录。 那么在图1中，HEAD其实是通过指向分支进而指向了该分支的最后一个提交记录，即HEAD-&gt;master-&gt;add README.md.。而在图2中，HEAD被称作游离的HEAD，是因为它指向的并不是分支而是该分支的一个提交历史，自然就不会指向master分支了，即HEAD-&gt;测试1。 基于指定提交历史修改代码 在上一个回到指定的提交历史的操作中，我们通过签出的操作获取到了指定的提交历史的代码，这时我们就能够基于这个提交历史的代码进行开发。 举个例子，假设我们要回到之前刚添加md文件的提交历史上进行代码开发，给md文件进行修改。我们当前分支的最新提交为博文3，如何回到提交历史add README.md.上？ 第一步我们肯定要签出到add README.md.上，签出后可以发现项目文件回到了刚开始提交md文件的时候。 这时我们对md文件进行修改，这里我删除了一些段落。 然后点击提交按钮，将这个修改历史666提交到本地分支中。 此时Git给出了警告。如果我们无视警告，仍然点击提交按钮，就会发现原本存在于add README.md.提交记录的指针消失了，而且我们修改后的提交记录666也并没有被提交到本地分支中。 还记得之前我们提到的游离的HEAD吗？如果直接在特定提交上修改代码并运行 git commit，这实际上会在游离的 HEAD 状态下创建一个新的提交，而不会创建分支。这样的操作可能会导致出现一个游离的提交，Git 的垃圾回收机制可能会删除这些提交。 解决方法1 一种方法是：我们在指定提交历史上创建一个分支，然后在新分支上开发完毕后进行提交。这两步操作前文已经详细介绍了，不再赘述，如图所示。 解决方法2 第二种方法则是：对指定提交记录执行git revert命令，该命令会基于指定提交记录创建一个新的提交历史 我们可以右键一个提交记录，选择还原提交选项。 如果当前分支的提交记录和还原的提交记录的文件存在差异的话会出现代码冲突。这里因为我当前分支的第一个提交记录博文3和add README.md.在md文件上存在差异，所以出现了冲突。 由于我们当前的目标是回到add README.md.这个提交记录的代码中，所以我们选择忽略来自其他提交的变更，保留add README.md.提交记录的原本代码即可。 写好提交消息后点击提交 可以发现我们这样就创建了一个和add README.md.一模一样的提交记录了。 接着我们可以基于这个提交记录的代码进行开发，这里前文已经详细介绍了，不再赘述。 将远程分支拉取到本地 设想这样一个场景：你的同事创建了一个新的远程分支并做了一个新的功能，而这个分支是你本地没有的，你现在的工作要基于这个新的功能才能进行下去，那么我们就需要把这个远程分支拉取到本地来。 在这个例子中，你的同事创建了远程分支origin/dev，而我们本地并没有与其对应的分支。 我们只需要右键该分支，点击签出，即可将该远程分支拉取到本地。 代码整合 在项目合作中，将其他人的代码整合到自己的代码中是经常用到的操作，这时就需要利用到Git的合并或变基功能。 一般来说代码整合会遇到以下几种情况： 当前分支正好比其他分支少了几条记录 如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，当前dev1中没有dev中的add README.md.的修改记录。首先确保我们当前分支在dev1分支上。 我们右键dev分支，选择变基或合并均可。 可以看到dev的提交记录整合到了dev1中。 当前分支和其他分支都修改了几条记录 如图，当前我们自己的代码在dev1分支中，我们要整合来自dev的代码，dev1中我写的md文件的内容较少。 在dev中我的队友写的md文件的内容较多。 现在一样要确保当前分支在dev1中，并且右键dev分支选择合并/变基来整合代码。这个时候就出现了冲突，大家应该很容易就想明白了，因为我当前分支和我队友的分支都同时存在文件名相同、内容不同的文件，这个问题不解决的话自然无法整合。 解决冲突的话就需要你和队友进行协商。比如这里我的分支dev1就比较少，队友的分支dev写的比我详细，所以我可以进行\"妥协\"，直接用队友的md文件即可，点击接受他们的这个按钮就可以使用队友的md文件了。 当然，我们也可以不进行妥协，IDEA提供了强大的修订功能，通过点击合并按钮，我们可以选择整合该文件的特定部分。具体如何操作，大家自行练习吧~ 删除提交 我们在实际开发中难免会提交一些无用的提交记录，这时需要利用删除提交的操作。 右键一个提交记录，选择删除提交选项，即可删除。 很简单吧？但要注意已经推送到远程分支的提交是不可删除的。 这里的绿色提交记录代表还未推送到远程分支的提交记录，棕色代表已经推送到远程分支的提交记录。 "},{"title":"【IDEA结合Git实现项目管理实战】二、基础篇","date":"2023-12-10T08:20:10.000Z","url":"/2023/12/10/%E4%BA%8C%E3%80%81Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F/","tags":[["项目管理","/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"]],"categories":[["Git","/categories/Git/"]],"content":"【IDEA结合Git实现项目管理实战】二、基础篇 前言 本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。 本系列主讲如何具体操作，因此对于Git内部的原理将不会过多深究。 本文严禁任何形式的转载、搬运！ 本文作为该系列的基础篇，将简要介绍使用Git所应该知道的最基本的知识，因此不算深究原理，哈哈。 注意：本文假设你已经成功在IDEA中配置了git Git的四个工作区域 基本概念 Git本地有三个工作区域，分别是工作区、暂存区、本地仓库 Git远程有一个工作区域，叫做远程仓库 工作区：开发者当前工作的目录，主要包含项目的实际文件，其中可能包括未进行版本管理的新文件和已修改的文件。 暂存区：作为一个临时存储区域，用于存放工作区中已经修改的文件的快照，以便将它们作为一个逻辑单元提交到本地仓库。 本地库：包含了项目的提交历史，开发者可以对其进行各种操作，如分支合并、变基、签出等。本地库是在开发者本地计算机上的存储库。 远程库： 存放在代码托管平台（如Gitee、GitHub）上的仓库，包含了已推送的代码版本、分支、标签等信息。开发者可以通过推送和拉取操作与远程库进行交互，以保持代码同步。 概念解释 工作区 一下子引入了这么多概念，可能大家会有点接受不了，那么这里对以上概念进行详细解释。 具体来说，工作区可以看做你在IDEA中打开的项目目录，如下图： 这里的项目目录就可以看作是工作区，但是在这个工作区中，既存在正常颜色（白色）的文件名，也存在红色、绿色和蓝色的文件名，那么这些文件分别代表什么含义？这里的文件的颜色，其实也就对应着上文所谓未进行版本管理的新文件和已修改的文件。如下表： 颜色 含义 白色 在当前提交历史未改动或者已经提交到本地库的文件 红色 未进行版本管理的新文件，也被称为未跟踪的文件 绿色 已经进行版本管理的新文件，该文件已被添加到暂存区中 蓝色 当前工作区中被修改的文件，该文件已被添加到暂存区中，与绿色相似 红色文件名、绿色文件名实例 大家可以自行测试下，如果你直接在项目目录中创建一个文件的话，IDEA会做出提醒： 这时如果你选择添加的话，该文件就会变成绿色文件从而被Git进行版本管理，如果选择取消的话，说明你不希望该文件被Git管理，那么该文件就是红色文件而不能被提交到暂存区。 总结： 当你创建一个新文件时，它就是红色的，表示这是一个未跟踪的文件。通过运行 git add 命令，将文件添加到暂存区，此时文件变为绿色，表示它已经被 Git 管理并准备提交。 如果你不想将一个未跟踪的文件或已修改的文件纳入版本管理，你可以选择不使用 git add 命令，或者使用 git reset 命令来取消已经添加到暂存区的文件。取消后，文件会回到红色状态，表示它未被跟踪或未被修改。 但是对于我们日常开发来说，我们创建一个文件肯定是有用意的，一般都希望该文件被提交上去，所以我们一般都选择添加文件，这样才能通过添加到暂存区，再到本地库最终推送到远程仓库中。 白色、蓝色文件名实例 比如这里我删除了md文件中的其中一行，md文件的文件名由白色转为了蓝色 该文件一般在该项目已经提交到本地库中后，我们准备开发新的功能时才会出现，也就是我们修改了当前已经存在于本地库中的文件，该文件就会被转化成蓝色文件。因为该文件已经被Git版本管理过了，所以可以直接提交到本地库。 总结： 蓝色文件可以直接提交到本地库中，因为其已经被Git版本管理了 蓝色文件可以简单认为就是白色文件被修改后的文件 暂存区 经过前面的内容，大家多少应该可以感觉到，暂存区其实是我们看不见、摸不着的存在，在暂存区中存在的文件一般是绿色和蓝色文件，也就是我们已经使用git add命令添加的文件。 当我们开发完毕一个新的功能后，我们就会准备将这次修改记录提交到本地仓库，这时候使用git commit命令就可以将暂存区中的文件提交到本地仓库中。 提交实例 在该实例中，我们删除了md文件的其中一行（可以看到changes一栏中是蓝色文件，如果你把一个新的文件也添加到暂存区的话就是前文提到的绿色文件），这里我们要在下方框中填写相关介绍，以便帮助其他团队成员或日后的自己知道这次的提交做了什么。 本地库 具体来说，本地库包含了开发者本地完整的提交历史和所有的本地分支，本地库中的提交记录是暂存区通过执行git commit后得来的。 这里要注意本地分支和本地库的区别，本地分支只是本地库众多分支的其中一个分支，当然本地库也可以只包含一个本地分支（但是一般来说开发者不会这么做）。 本地分支实例 这里展示了本地库中的master分支，在这个分支中存在着该分支的提交历史和各种信息。 远程库 远程库是存放在代码托管平台（如Gitee、GitHub）上的仓库，本地库执行git push命令可将本地的提交记录推送到远程仓库中。 远程分支和远程库的区别同本地分支与本地库的区别一样 远程分支实例 同上本地分支实例。 需要注意的是，由于我们在团队开发中涉及到多人的共同协作，因此每个人都可以向远程仓库中推送自己的代码，也就意味在当你在开发新的代码时，远程仓库可能已经发生了变动，那么远程分支也就不能实时和远程仓库的提交记录保持同步了，这时我们需要使用git fetch命令，将远程仓库的提交记录拉取到的远程分支中。 总结 通过对于工作区域的认识，大家想必已经了解了一个文件如何从工作区一步步提交到远程仓库中，当然这里存在着很多操作中的细节，如切换分支，合并来自其他分支的结果等，而我们是使用IDEA结合Git实现版本管理，同样存在着如何具体使用的问题。由于本篇只讲理论，就不过多介绍了，本系列将会继续更新下去，大家敬请期待~"},{"title":"【IDEA结合Git实现项目管理实战】一、配置篇","date":"2023-12-07T02:30:29.000Z","url":"/2023/12/07/%E4%B8%80%E3%80%81IDEA%E9%85%8D%E7%BD%AE/","tags":[["项目管理","/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"]],"categories":[["Git","/categories/Git/"]],"content":"【IDEA结合Git实现项目管理实战】一、配置篇 前言 本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。 本系列主讲如何具体操作，因此对于Git内部的原理将不会过多深究。 本文严禁任何形式的转载、搬运！ 本文作为该系列的配置篇，将介绍如何使用IDEA整合git，从而实现项目管理。 本文将使用Gitee作为项目管理工具。 注意：本文假定你已经拥有了一个Gitee账号并已经配置了密钥。 下载插件 打开设置 在插件中搜索Gitee并下载安装，安装完毕后IDEA会提醒重启IDE，重启后插件才会生效！ 添加账号 IDEA重启后，再次打开设置，在版本控制中可以看到Gitee这一栏，点击加号添加账号 点击加号后我们选择Log in via Gitee 授权完毕后点击应用。 项目管理 最后一个步骤就是正式的实现项目的版本控制了，实现这一步骤有两种操作。 第一种是将IDEA本地的项目上传到gitee中 第二种是从远程clone一个仓库到IDEA本地中 下面我们来逐个介绍这两种操作，并简述这两者之间的区别和使用场景。 1.将IDEA本地的下面上传到Gitee中 现在我们打开你想要托管给Gitee的项目，打开工具栏的VCS，点击Share Project on Gitee 这里我们可以设置仓库名（Repository name），Remote是远程分支名，可以不用修改，Description是这个仓库的描述，这里自己填写即可。 填写完毕后点击share，弹出这个窗口。 我们需要在本窗口中添加需要进行版本管理的文件以进行初始化，可以看到，本项目的所有文件都是理论篇提到的红色文件名的文件，这是因为这个项目还没有上传到远程仓库，也就不存在被Git跟踪的文件，所以都是红色文件名。 这里我们填写下提交信息并点击添加按钮，就可以上传成功了。 上传完毕后，我们可以观察到IDEA中出现了这三个功能块，至于这些功能块有何具体作用，我们将在基础篇详细介绍，这里不过多解释了。 这时候我们可以打开gitee的网站，点击顶部工具栏的头像，选择我的仓库，就可以看到刚刚创建的仓库了! 2.从远程clone一个仓库到IDEA本地中 这一步我们将从远程仓库中clone一个项目到本地中。 我们在gitee中选择一个想要clone的远程仓库，这里我使用的是我自己的远程仓库：  点击VCS，选择从版本控制中获取。 在仓库URL中，在URL中粘贴我们刚才复制的HTTPS地址，在目录中选择我们想要放置远程仓库代码的本地地址，填写完毕后点击克隆。 注意：目录必须是一个空目录 等待克隆完成后项目会自动跳转到你选择的目录。 总结 通过以上的介绍，我们了解到实现版本控制有两种操作： 第一种操作适用于以下场景： 本地你已经开发好了项目，需要将项目托管给远程仓库。 第二种操作适用于以下场景： 团队已经有了远程仓库（有人已经将远程仓库创建好了），这时候我们直接clone即可。 在gitee或github中看到了优质项目，我们clone本地进行学习 "},{"title":"【IDEA结合Git实现项目管理实战】四、git冲突篇","date":"2023-01-04T10:21:22.000Z","url":"/2023/01/04/%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81/","tags":[["项目管理","/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"]],"categories":[["Git","/categories/Git/"]],"content":"【IDEA结合Git实现项目管理实战】四、git冲突篇 前言 本系列将结合我个人参与团队协作开发项目的经验来介绍如何使用IDEA结合Git实现项目管理，因此可能与真正的企业开发协作存在差异，且文章所涉及的解析可能存在个人理解与实际的偏差。 本系列主讲如何具体操作，因此对于Git内部的原理将不会过多深究。 本文严禁任何形式的转载、搬运！ 在使用Git进行项目管理时，代码合并是一项常见而重要的操作。本文将重点探讨两种常用的代码合并操作：合并（merge）和变基（rebase）。在进行代码合并时，我们难免会遇到Git冲突的情况。本文也将通过举例详细介绍如何通过IDEA使用Git进行合并或变基操作时可能遇到的代码冲突情况，并提供解决方法。 什么是git冲突 在多分支并行处理时，每个分支可能基于不同版本的主干分支创建。如果每个分支都独立开发而没有进行代码合并，自然不会出现代码冲突。但是，当两个分支同时修改同一文件时，在代码合并时就会出现冲突。 下图为两个分支分别使用合并/变基操作解决冲突后的提交树。 解决git冲突 介绍完冲突出现的原因，那么如何解决冲突呢？在解决git冲突时，我们需要确定以哪个分支的文件版本为准，或者取两个分支的文件的部分片段进行整合。 IDEA提供了强大的冲突解决功能，供用户处理git冲突。下面将进行详细介绍。 当前分支dev1的代码： 目标分支dev的代码： 我们现在的目标是让两个分支合并后的代码中同时出现method1、method2、access和acess2这四个方法。 执行合并后，出现界面： 左侧为当前分支dev1的提交记录，中间为合并前的预览结果，右侧为目标分支dev的提交记录。 其中红色区域为代码存在差异的部分。 先来看第一块红色区域的中间部分的代码。大家一定会疑惑预览结果中出现这段代码是什么意思？为什么会出现报错呢？ 这里其实是git对于左右侧存在差异的代码的标记。符号&lt;&lt;&lt;&lt;&lt;&lt;&lt; xxx的下方是左侧存在差异的代码，符号&gt;&gt;&gt;&gt;&gt;&gt; xxx的上方是右侧存在差异的代码，比如&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD箭头所指方向也就是我们当前分支的方向（在左侧），在该箭头下面的部分是当前分支的与目标分支的差异代码，这里因为左侧比右侧少了一段代码，因此下面啥东西没有；=======代表分割符号，该分割符号的下面就是目标分支的代码，即import java.util.concurrent.TimeUnit；&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev也就代表目标分支的方向（在右侧） 那么如何解决冲突呢？对于我们的目标来说，我们的输出语句自然不需要导入这个包，因此把语句import java.util.concurrent.TimeUnit;给删除即可。 点击左侧的箭头符号，可以把中间区域被替换成左侧的红色区域（那根细线，也就是没有代码）。 点击后中间区域消失。 再来看第二个红色区域，根据我们的目标，我们要将这四个方法都添加进入中间区域。 先点击左侧的箭头。可以发现中间区域被替换为左侧代码，右侧向左箭头变成了向左下箭头。 这个向左下的箭头代表将右侧的代码添加到中间代码的下方。 点击后如图： 那么一切就大功告成了，冲突解决成功，点击应用按钮。 git提示还有冲突未处理，这是为什么？ 把界面翻到上面，发现这个红色区域还没有处理，我们点击那个查号，作用是将冲突标记为已解决。 这时IDEA提示所有变更已被处理，那么我们就可以放心大胆的合并了。 合并成功！ 合并/变基详解 合并（git merge） 当前分支和目标分支执行合并操作时，Git会将当前分支的最新提交记录与目标分支的最新提交记录合并，并在当前分支形成一个新的提交记录。 示例1 当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。 执行合并操作，dev中的提交记录添加到了分支dev1中。 示例2 当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。 执行合并操作，git给出提示（已是最新 删除dev），当前分支dev1没有变动。 示例3 当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录添加测试类，目标分子dev中有新提交记录添加新文件（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突） dev1中添加了一个JavaTest文件。 dev分支中添加了一个test.lua文件。 执行合并操作，在目标分支dev1中生成一个新的提交记录Merge branch 'dev' into dev1，该提交记录包含了这两个提交记录的变更，如图。 在提交树中，可以看到两个提交记录合并为一个记录。 变基（git rebase） 当前分支和目标分支执行变基操作时，Git会将目标分支的最新提交记录依次应用到当前分支的每个新的提交记录中。 示例1 当前分支为dev1，目标分支为dev，目标分支dev中存在两条当前分支dev1分支没有的提交记录。 执行变基操作，dev中的两条记录添加到了dev1中。 示例2 当前分支为dev1，目标分支为dev，当前分支dev1中存在两条目标分支dev分支没有的提交记录。 执行变基操作，没有发生变化。 示例3 当前分支为dev1，目标分支为dev，当前分支dev1中有新的提交记录添加测试类，目标分子dev中有新提交记录添加新文件（该示例由于都是添加新文件，没有对同一文件进行更改，因此不存在代码冲突） dev1中添加了一个JavaTest文件。 dev分支中添加了一个test.lua文件。 执行变基操作，dev分支的提交记录添加到了dev1分支中。 总结 可以发现，无论是对于合并还是变基操作的示例1和示例2，最终执行操作后的结果都是一样的。对于合并操作，git将两个分支进行合并，最后生成一个新的提交记录，提交树存在交叉。对于变基操作，git将目标分支的提交记录应用到当前分支，提交树仍然是线性的。如图所示。 至于在实际开发中选择合并还是变基，还是看个人喜好了。 代码冲突示例 注意：本文为方便理解，所有示例均简单的修改项目中的md文件，实际开发中可能存在对多个文件的冲突，但万变不离其宗，只要你具备了解决单个文件代码冲突的能力，那么多个文件的冲突也能轻松应对。 合并/变基分支1 分支情况，当前dev1的两个提交记录博文1和博文2都在dev的提交记录博文3之前，其余分支一样 时间顺序：博文1-&gt;博文2-&gt;博文3 合并 此时合并有代码冲突，解决这个冲突。 发现该冲突只针对博文2，也就是最后一个提交记录 变基 该冲突为博文1和博文3的冲突 该冲突为变基后的博文1和博文2的冲突 合并/变基分支2 分支情况： dev中的博文3在dev1中的博文1和博文2之间 时间顺序：博文1-&gt;博文3-&gt;博文2 合并 基于上述情况，合并分支存在代码冲突 在代码冲突中，存在博文2和博文3的冲突， 冲突解决后如图所示。 这里紫色因为博文3是属于别的分支过来的，其父提交是add README.md.。所以从add README.md.出发，与dev1原本的提交记录博文2结合形成一个新的提交记录Merge branch 'dev' into dev1 结论：分支以时间顺序进行排序，合并分支永远是两个分支的最后一个提交历史进行合并。 变基 博文1和博文3存在冲突 冲突解决后，选择提交消息不变 依然存在冲突 可以发现该冲突来自于已经变基的提交博文1和之后的博文2 得到变基后的提交树 合并/变基分支3 分支情况： dev1中的两个提交记录博文1和博文2在dev中的博文3提交之后 时间顺序：博文3-&gt;博文1-&gt;博文2 合并 博文2和博文3存在代码冲突 变基 冲突来自于博文3和博文1 冲突来自变基后的博文1和博文2 总结 通过这三个代码冲突的示例，看到区别了吗？ 在合并操作时，冲突通常发生在两个分支的最新提交记录上。这是因为合并是将两个不同的分支合并为一个，而最新的提交记录是两个分支的端点。如果两个分支都对同一文件进行了修改，Git 无法确定应该选择哪个更改，因此会产生冲突。 在变基操作时，冲突可能发生在当前分支的提交记录和目标分支的提交记录之间的每个提交记录上。这是因为变基是将一系列提交应用到另一个分支上，而不仅仅是最新的提交。如果两个分支都修改了相同的文件，冲突可能会在每个提交记录上发生，而不仅仅是最新的提交。 总的来说，冲突是由于两个分支都对同一文件进行了修改，而 Git 无法自动解决冲突的情况下发生的。在合并操作中，冲突通常发生在最新的提交记录上；在变基操作中，冲突可能发生在多个提交记录上。"},{"title":"Redis持久化问题排查","date":"2022-10-29T12:49:50.000Z","url":"/2022/10/29/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","tags":[["问题解决","/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Redis持久化问题排查 前言：在学习黑马的Redis持久化课程时因为老师用的MobaXterm软件与我使用的VMware存在差异，同时，老师上传的视频的redis配置与我大为不同而导致了一系列的问题，在进行了一天的排查（死杠）后终于解决了问题，感慨良多。在遇到问题解决不了的时候还是要多回头看，没准在出发点就能找到问题了。 下面就将展示问题的描述和解决方案 问题描述 老师在使用MobaXterm软件时使用redis-server redis.conf命令指定配置文件在前台启动Redis 然而我在使用redis-server命令却出现了下面的两种情况： 第一种：不指定配置文件启动Redis 发现监听6379端口失败 第二种：指定配置文件启动Redis 这里要先cd到自己的Redis安装路径下，然后使用命令redis-server redis.conf 发现没有产生日志，这里使用ps -ef | grep redis查看后端端口占用情况 显然，后台端口已经被占用了，这里是因为Redis配置了开机自启动和后台启动，导致端口占用而无法使用redis-server命令 问题解决 在执行以下操作前建议使用VMware创建一个快照，防止后续操作不当导致虚拟机设置出现问题 先使用以下命令关闭后台端口 此时cd到Redis的安装目录下，使用命令ps -ef | grep redis查看后台端口占用情况，发现后台端口关闭 然后在当前路径下使用vi redis.conf关闭Redis后台启动 将 daemonize 修改为 no 这样Redis就不会在后台启动了！ 接着可以开心的使用redis-server redis.conf指定配置文件启动redis了！ 然而，如果你使用该命令后又出现了如下情况 发现当前窗口确实是像前台启动一样阻塞的，但是却没有任何日志信息输出，这时我们打开RESP等图形化界面看一下连接是否成功 嗯，确实成功了，说明Redis服务确实启动了，但还是没有日志文件，那么这是怎么回事呢？ 哈哈，不用着急，我们先使用ctrl + c停止当前端口，然后再回到RESP上发现连接终止，这就说明我们之前做的操作没有问题！现在我们回到终端，使用vi redis.conf命令进入到配置文件中 找到logfile，发现logfile后面的引号内为一个日志文件 这个时候一切都真相大白了，因为在一开始配置Redis时，我们将在logfile的引号内写入了一个日志文件名称（一开始的logfile内的引号默认是空的），这就导致了我们使用redis-server命令输出的日志都进入到这个日志文件中，所以启动时当然看不到任何信息了！现在我们将引号内的文件命删除，保存并退出 再次使用redis-server redis.conf命令启动Redis 启动成功，大功告成！"},{"title":"VMWare演示Redis持久化","date":"2022-10-28T12:49:50.000Z","url":"/2022/10/28/VMWare%E6%BC%94%E7%A4%BARedis%E6%8C%81%E4%B9%85%E5%8C%96/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["Linux","/categories/Linux/"]],"content":"VMware演示Redis持久化 Redis持久化的作用 Redis是内存存储，如果出现服务器宕机、服务重启等情况可能会丢失数据，利用Redis持久化可以将数据写入磁盘中，这样Redis就可以利用持久化的文件进行数据恢复，数据安全性得以大大提升。 RDB RDB全称为Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存重的所有数据都记录道磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。 RDB实现数据持久化有两种命令：save和bgsave save命令适合用于准备将Redis停机的情况。 在执行save命令时会占用Redis的主进程，阻塞所有命令，因此不适用于Redis正在运行的情况。 而bgsave命令会执行fork操作开启一个子进程，避免主进程收到影响。 此外，当Redis停机时会执行一次RDB操作进行数据备份。 下面将对该情况进行验证 RDB演示 使用redis-server redis.conf指令在任意路径下运行Redis 接下来创建一个新的终端创建连接，存入键值对 接着回到上一个终端使用ctrl + c关闭Redis，可以看到DB saved on disk表示文件正常保存 在当前路径下使用ll查看所有文件，看到dump.rdb快照文件已经生成 接着再次在当前终端使用redis-server redis.conf启动Redis，此时数据会自动恢复，回到另一个终端窗口 此时将使用ctrl + c关闭当前命令行客户端，重新使用redis-cli开启一个新的命令行 这时使用get num命令发现数据返回为789，（如果get num返回错误Error：Server closed the connection要将redis.conf的protected-mode设置为No关闭保护模式）表明数据备份成功 Redis停机自动执行RDB证明完毕！ 实现RDB的相关配置 这里需要 cd 到redis的安装目录下，我的安装目录在 /usr/local/src/redis-6.2.6下 这里老师用的MobaXterm可以直接使用第三方文件打开配置文件进行修改，因为我用的是VMware所以只能使用Linux命令进行修改配置 使用 vi redis.conf修改配置文件 这里有一些小技巧： 按下INSERT键进入修改状态，此时才可以对文件进行修改 按下ESC键可以使用一些命令：/xxx可以查找跳跃到当前文件中的xxx名称，:wq保存当前文件并退出，:q不保存并退出当前文件，:q!不保存并强制退出当前文件 下面就可以对配置文件进行修改了！ 修改为五秒内执行一次操作就出发RDB备份 接着 再查找rdbcompression后修改为yes即可 使用:wq保存并退出 rdb文件名修改后使用终端再次运行Redis，发现此时没有DB文件录入消息，之前的dump.rdb文件已不能被读取 到另一个终端重新使用redis-cli开启命令行，使用get num命令发现结果为空，再set 一个新的键值，回到Redis窗口发现出现Background saving started字段即表示成功！ AOF AOF全称为Append Only File (追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。 开启AOF需要在Redis的配置文件中修改配置，AOF记录命令的频率有三种:always 、everysec和no always配置胜在能记录每一次Redis执行的写命令，几乎不会丢失数据，但对性能会有很大的影响 everysec配置每隔一秒将缓冲区里的数据写入到AOF文件，避免直接对AOF文件操作而性能上有了提升，但是在数据间隔的一秒内如果出现服务宕机的情况会丢失最多一秒的数据 no配置执行频率最低，性能最好，但是可靠性很低，不推荐使用 AOF演示 先使用 cd 命令进入到Redis的安装路径下 使用vi redis.conf命令修改redis配置文件 将之前的save 5 1注释掉，写入save \"\"，表示禁用RDB 将appendonly修改为yes，开启AOF AOF执行频率的命令配置默认为appendfsync everysec，不需要修改 修改完毕后回到终端，使用rm -rf *.rdb删除之前的RDB文件 可以看到当前目录下rdb文件已删除 使用redis-server redis.conf命令重启Redis 发现日志中出现没有对RDB的读取，修改成功 在另一终端打开命令行，输入如下指令 返回空集合，说明所有数据已被清除 img set一个键值对 这时我们打开文件夹进入本机的Redis的安装路径下，发现AOF文件已经被创建成功，打开AOF文件，set命令已经被写入成功，说明AOF已经生效了 接下来验证AOF的重启恢复，先重启Redis服务，红框内的日志表示数据已经从AOF文件加载完毕 这时候我们回到命令行使用keys *命令，返回num，依然有数据，说明AOF重启能保证数据的恢复，证明完毕 RDB和AOF的比较 "},{"title":"VMware软件安装及问题解决","date":"2022-10-08T03:26:00.000Z","url":"/2022/10/08/VMware%E5%AE%89%E8%A3%85/","tags":[["问题解决","/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"]],"categories":[["Linux","/categories/Linux/"]],"content":"VMware软件安装 前言：最近学习Redis时需要使用Linux系统，导致不得不去安装一个虚拟机了，在准备安装VMware软件时遇到了一些问题，这里给出记录和解决方案，以做参考学习使用 准备工作 本文将在Windows系统下使用VMware软件配置Linux虚拟机，下文将会详解VMware软件的安装步骤 VMware软件下载地址： Linux CentOS 7版本下载映像文件地址： 按图片所示下载即可 这里我选择的是CentOS-7.0-x86_64-DVD-2009.iso 版本 在下载路径下右键以管理员身份运行 在这里要敲重点！！！如果你没有以管理员身份运行这个选项，那么就看接下来的问题解决部分，如果你有这个选项请点击跳转自行无视。 问题解决 按住快捷键Win+R打开运行窗口，输入“regedit”， 这样就打开了注册表编辑器 在编辑器左侧依次找到HKEY_CURRENT_USER 然后将RestrictToPermittedSnapins的值设置为0 上面的方法如果输入路径后发现MMC不存在，那么下面这个方法就派上用场了！ 按下Win + R键打开运行，输入gpedit.msc打开组策略编辑器，这里可能你又会惊讶的发现，gpedit.msc打不开了！别着急，下面还有解决方案。当然，如果你能打开组策略编辑器的话可以点击这里继续往下看 对于无法打开组策略编辑器的情况，win + r 键打开运行后，输入notepad打开记事本，复制粘贴以下内容 记事本左上角文件另存为到任意路径下 文件名写为gpedit.cmd，保存类型选择所有文件，编码选择ANSI 点击保存后在你保存的路径下右键以管理员身份运行 等待运行结束后发现win + R键打开的gpedit.msc可以正常打开了 接下来进入组策略编辑器，双击计算机配置 --&gt; Windows设置 --&gt; 安全设置 双击本地策略 进入安全选项找到下面两项选择已启用 大功告成！！！ 安装VMware 当解决上述问题后开始准备下载VM软件了，右键以管理员身份运行后等待片刻来到安装界面 一路下一步来到这个界面，安装路径自己选择，我选择安装在D盘下的目录里 勾选取消“启动时检查产品更新” 一路下一步，点击安装 点击许可证 这里要输入许可证密钥（这里大家自行网络上获取），然后点击输入，安装结束，注意不要误点到跳过了。 输入密钥确认安装后就可以使用VMware了！"}]